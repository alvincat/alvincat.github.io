[{"categories":[""],"contents":"该页面为网站的导航页面。\n汇编语言导航页 C++导航页 算法导航页 数据结构导航页 操作系统导航页 Linux相关内容导航页 工具使用导航页 环境搭建导航页 ","date":"2024-11-13T16:30:08+08:00","permalink":"https://alvincat.top/contents/","tags":[""],"title":"网站导航页"},{"categories":["汇编语言"],"contents":"Introduce the Intel and AT\u0026amp;T Syntax about assembly language\nIntel and AT\u0026amp;T Syntax Intel and AT\u0026amp;T syntax Assembly language are very different from each other in appearance,\nand this will lead to confusion when one first comes across AT\u0026amp;T syntax after having learnt Intel syntax first, or vice versa.\nSo lets start with the basics. Linux use AT\u0026amp;T syntax default.\n1.1 Direction of Operands The direction of the operands in Intel syntax is opposite from that of AT\u0026amp;T syntax.\nIn Intel syntax the first operand is the destination, and the second operand is the source whereas in AT\u0026amp;T syntax the first operand is the source and the second operand is the destination.\nThe advantage of AT\u0026amp;T syntax in this situation is obvious.\nWe read from left to right, we write from left to right, so this way is only natural.\nExample:\nIntel Syntax AT\u0026amp;T Syntax instr dest,source instr source,dest mov eax,[ecx] movl (%ecx),%eax 1.2 Prefixes In Intel syntax there are no register prefixes or immed prefixes.\nIn AT\u0026amp;T however registers are prefixed with a \u0026lsquo;%\u0026rsquo; and immed\u0026rsquo;s are prefixed with a \u0026lsquo;$\u0026rsquo;.\nIntel syntax hexadecimal or binary immed data are suffixed with \u0026lsquo;h\u0026rsquo; and \u0026lsquo;b\u0026rsquo; respectively.\nAlso if the first hexadecimal digit is a letter then the value is prefixed by a \u0026lsquo;0\u0026rsquo;.\nExample:\nIntel Syntax AT\u0026amp;T Syntax mov eax, 1 movl $1, %eax mov ebx, 0ffh movl $0xff, %ebx int 80h int $0x80 1.3 Memory Operands Memory operands as seen above are different also. In Intel syntax the base register is enclosed in \u0026lsquo;[\u0026rsquo; and \u0026lsquo;]\u0026rsquo; whereas in AT\u0026amp;T syntax it is enclosed in \u0026lsquo;(\u0026rsquo; and \u0026lsquo;)\u0026rsquo;.\nExample:\nIntel Syntax AT\u0026amp;T Syntax mov eax, [ebx] movl (%ebx), %eax mov eax, [ebx+3] movl 3(%ebx), %eax The AT\u0026amp;T form for instructions involving complex operations is very obscure compared to Intel syntax. The Intel syntax form of these is segreg:[base+index*scale+disp]. The AT\u0026amp;T syntax form is %segreg: disp(base,index,scale).\nIndex/scale/disp/segreg are all optional and can simply be left out. Scale, if not specified and index is specified, defaults to 1. Segreg depends on the instruction and whether the app is being run in real mode or pmode. In real mode it depends on the instruction whereas in pmode its unnecessary. Immediate data used should not \u0026lsquo;$\u0026rsquo; prefixed in AT\u0026amp;T when used for scale/disp.\nExample:\nIntel Syntax AT\u0026amp;T Syntax instr foo,segreg:[base+index*scale+disp] instr %segreg:disp(base,index,scale), foo mov eax, [ebx+20h] movl 0x20(%ebx), %eax add eax, [ebx+ecx*2h] addl (%ebx,%ecx,0x2), %eax lea eax, [ebx+ecx] leal (%ebx,%ecx), %eax sub eax, [ebx+ecx*4h-20h] subl -0x20(%ebx,%ecx,0x4), %eax As you can see, AT\u0026amp;T is very obscure. [base+index*scale+disp] makes more sense at a glance than disp(base,index,scale).\n1.4 Suffixes As you may have noticed, the AT\u0026amp;T syntax mnemonics have a suffix. The significance of this suffix is that of operand size. \u0026rsquo;l\u0026rsquo; is for long, \u0026lsquo;w\u0026rsquo; is for word, and \u0026lsquo;b\u0026rsquo; is for byte. Intel syntax has similar directives for use with memory operands, i.e. byte ptr, word ptr, dword ptr. \u0026ldquo;dword\u0026rdquo; of course corresponding to \u0026ldquo;long\u0026rdquo;. This is similar to type casting in C but it doesnt seem to be necessary since the size of registers used is the assumed datatype.\nExample:\nIntel Syntax AT\u0026amp;T Syntax mov al,bl movb %bl,%al mov ax,bx movw %bx,%ax mov eax,ebx movl %ebx,%eax mov eax, dword ptr [ebx] movl (%ebx),%eax ","date":"2024-12-23T20:41:51+08:00","permalink":"https://alvincat.top/post/assembly/inter_gun_syntax_difference/","tags":[""],"title":"Intel和AT\u0026T汇编语言语法的差异"},{"categories":[""],"contents":"该页面为汇编语言使用的导航页。\n汇编语言 Intel和AT\u0026amp;T汇编语言语法的差异\n","date":"2024-12-23T18:25:40+08:00","permalink":"https://alvincat.top/index/content_assembly/","tags":[""],"title":"汇编语言导航页"},{"categories":["数据结构"],"contents":"本文介绍B-Tree的特性，以及代码实现。\n","date":"2024-12-17T20:01:46+08:00","permalink":"https://alvincat.top/post/data_structure/tree/b_tree/","tags":["B-Tree"],"title":"B_tree"},{"categories":[""],"contents":"该页面为存储系统的导航页。\n存储系统导航页 [存储系统的基本概念] [Ceph功能简介] [LevelDB原理介绍] [RocksDB原理介绍]\n","date":"2024-12-17T18:25:40+08:00","permalink":"https://alvincat.top/index/content_storage/","tags":[""],"title":"存储系统导航页"},{"categories":[""],"contents":"","date":"2024-12-17T17:51:06+08:00","permalink":"https://alvincat.top/post/storage_system/leveldb/","tags":[""],"title":"LevelDB"},{"categories":[""],"contents":"","date":"2024-12-17T17:50:40+08:00","permalink":"https://alvincat.top/post/storage_system/rocksdb/","tags":[""],"title":"RocksDB"},{"categories":["存储系统"],"contents":"本文介绍Ceph系统的基本组成部分以及一些基本概念。\n","date":"2024-12-17T17:50:30+08:00","permalink":"https://alvincat.top/post/storage_system/ceph/","tags":["Ceph"],"title":"Ceph"},{"categories":[""],"contents":"","date":"2024-12-17T17:49:33+08:00","permalink":"https://alvincat.top/post/storage_system/storage_basic_knowledge/","tags":[""],"title":"Storage_basic_knowledge"},{"categories":["CPP"],"contents":"本文总结C++中的部分关键字的用法。\n1 C++中的部分关键字的用法 1.1 const的用法 1.1.1 定义常量 使用const修饰的变量的值不可改变。\n1 const double PI = 3.1415; 1.1.2 const与指针 指向常量的指针(point to const)\n定义方法： const int *p; int const *p;\n指向常量的指针的特点：const在*前面，不论它在类型前还是类型后作用相同。\n指向常量的指针的特点： 不能通过指针改变所指向的数据 指针本身的内容可以改变 指针指向的内容可以是常量也可以不是常量 指针所指向的内容若为非常量，也可以改变 示例如下：\n1 2 3 4 5 6 7 int a = 100; int b = 50; const int *point1 = \u0026amp;a; //定义指针常量 //*point1 = 50; //非法操作，不能通过指针变量来改变所指向的数据 a = 50; //改变指针常量所指内容的值 point1 = \u0026amp;b; //改变指针常量的值 常量指针(const pointer)\n定义方法： int *const p;\n常量指针就是该指针为常量。因为该指针为一个常量，因此指针的值不能改变。 常量指针的特点： 常量指针必须初始化 一旦初始化后，指针的内容就不能改变 指针所指向的内容可以改变 示例如下：\n1 2 3 4 5 6 int a = 100; int b = 50; int *const point2 = \u0026amp;b; // 定义常量指针 //point2 = \u0026amp;a; //非法操作，不能更改常量指针的值 b = 100; // 可以改变常量指针所指内容的值 指向常量的常指针\n定义方法： const int *const p;\n指向常量的常指针为前面两种情况的综合。因此既不能通过指针变量来改变所指向的数据，也不能更改指针本身的值。 指向常量的常指针： 指针本身的内容不能改变 不能通过指针改变指针所指向的内容 若指针指向的内容为非常量，则指针指向的内容可以改变 示例：\n1 2 3 4 5 6 int a = 100; int b = 50; int c = 80; const int *const point3 = \u0026amp;c; //定义指向常量的常量指针 *point3 = a; //非法操作，不能通过指针变量来改变所指向的数据 point3 = \u0026amp;b; //非法操作，不能更改常量指针的值 1.1.3 函数形参 const修饰函数形参，函数中不能修改const形参对应的实参。例如：\n1 void func(const vector\u0026lt;int\u0026gt;\u0026amp; vec); 1.1.4 const修饰函数返回值 1.1.5 类相关的const 常量成员变量：常成员变量只能通过列表初始化的方式初始化。此后，其值不可改变。 const修饰成员函数：const修饰的成员函数不能修改类中成员变量的值；不能调用非const修饰的成员函数。 const修饰对象，对象指针(引用)：const修饰的对象只能调用cosnt修饰的成员函数。 1.2 static的用法 1.2.1 静态全局变量 该变量在全局数据区分配内存; 未经初始化的静态全局变量会被程序自动初始化为0; 静态全局变量在声明它的整个文件都是可见的，而在文件之外是不可见的; 1.2.2 静态局部变量 该变量在全局数据区分配内存； 静态局部变量在程序执行到该对象的声明处时,首次进行初始化;以后的函数调用不再进行初始化； 静态局部变量一般在声明处初始化，如果没有显式初始化会被程序自动初始化为0； 它始终驻留在全局数据区，直到程序运行结束。但其作用域为局部作用域，当定义它的函数或语句块结束时，其作用域随之结束； 1.2.3 静态函数 静态函数不能被其它文件所用；其它文件中可以定义相同名字的函数，不会发生冲突\n1.2.4 类内静态成员 1.2.4.1 静态数据成员 类中的静态成员与类本身直接相关。而不是与类的各个对象保持关联。类的静态数据成员是属于整个类，而不与任何对象绑定； static关键字只能出现在类内部声明语句中； 类的静态成员存在于任何对象之外，对象中不包含任何与静态数据有关的数据； 静态成员变量使用前必须先初始化； 静态数据成员不能由类的构造函数初始化； 静态数据成员一般应在类的外部初始化。当静态数据成员为静态常量(const static)时，可以在类内初始化。 静态数据成员只能定义一次。 1.2.4.2 静态成员函数 类的静态成员函数也不与任何对象绑定，也不包含this指针。 静态成员函数不能声明为const,也不能在static函数体内使用this指针。 静态成员函数不能使用非静态成员函数，非静态成员函数可以使用静态成员函数。 1.3 C++ 11新增关键字(部分) 1.3.1 = default = default是用于限定构造函数的，要求编译器生成构造函数。它可以出现在类内部，也可以作为定义出现在类外部。 若在类内部，则默认构造函数是内联的，如果在内外部，则该构造函数默认不是内联的。\n1.3.2 constexpr constexpr 和const的功能类似，只值 constexpr 类型在编译时会进行变量类型检查，检查变量的值是否为常量表达式。\n声明为 constexpr的变量一定是常量，而且必须使用常量表达式初始化\n1.3.3 decltype decltype的作用是获取并返回操作数的类型。\n针对的场景：希望从表达式的类型推导出要定义的变量的类型，但是不想用该表达式初始化变量。例如：\n1 2 const int ci = 0; decltype(ci) x = 1; // x的类型为const int 1.3.4 explicit 1.3.4.1 修饰构造函数 explicit用于修饰构造函数是，用于阻止构造函数进行隐式转换。\nexplicit只对拥有一个参数的构造函数有效。 explicit只能在类内部声明构造函数时使用，而且在类外定义该构造函数时不能重复使用该关键字。 explicit声明构造函数时，该构造函数只能安札直接初始化的形式使用。\n1.3.5 final final的作用是阻止派生类覆盖该函数。 当函数使用final修饰后，任何尝试覆盖该函数的操作都会报错。\n1.3.6 override override关键字用在派生类的函数中，用于明确覆盖基类中的同名函数。\n若要在派生类的函数中使用override关键字，需要基类中有同名函数而且该函数为虚函数(virtual修饰)。【只有虚函数才能被覆盖】。 final和override说明符出现在形参列表(包括任何const或引用修饰符)以及尾置返回类型之后。\n","date":"2024-12-15T22:08:28+08:00","permalink":"https://alvincat.top/post/cpp/cpp_some_keywords/","tags":[""],"title":"C++中的部分关键字的用法"},{"categories":["CPP"],"contents":"本文总结C++面向对象的相关理论知识。\n1 面向对象 1.1 面向对象的特征 面向对象的特征：封装、继承、多态。\n封装：把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。（优点：可以隐藏实现细节，使得代码模块化） 继承：可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。（优点：可以扩展已存在的代码模块（类）） 多态：一个类实例的相同方法在不同情形有不同表现形式。多态机制使具有不同内部结构的对象可以共享相同的外部接口。虽然针对不同对象的具体操作不同，但通过一个公共的类，这些操作可以通过相同的方式被调用。\n多态实现的两种方式：父类指针指向子类对象或将一个基类的引用类型赋值为它的派生类实例。（重要：虚函数 + 指针或引用） 1.5 类中的数据成员初始化顺序 一个类中的数据成员初始化的顺序，只与数据成员的定义时的顺序有关，而与初始化列表中数据成员的出现次序无关。\n1.7 构造函数的性质 构造函数的名字和类名相同 构造函数没有返回类型 构造函数不能被声明为const 构造函数可以重载，一般包含默认构造函数，拷贝构造函数。 默认构造函数不需要任何参数 构造函数不能为虚函数 1.7.1 构造函数初始化列表 注意: 如果成员是const、引用或者属于某种未提供默认构造函数的类类型。我们必须通过构造函数初始化列表为这些成员提供初值。\n数据成员初始化的顺序 数据成员初始化的顺序与它们在类中定义时出现的顺序一致，而与它们初始化的顺序无关。一般来说，初始化类成员没有严格的顺序要求。但是如果用一个成员初始化另一个成员时，顺序就很关键。例如：\n1 2 3 4 5 6 7 class X{ int i; int j; public: //未定义的：i在j之前被初始化 X(int val):j(val), i(j){} }; 上例中，从构造函数初始值的形式上看，好像是先用val初始化j，然后再用j初始化i。但实际上，i先被初始化，因此这个初始值的效果是试图使用未定义的j初始化i。\n提示：最好令构造函数初始值的顺序与成员声明的顺序保持一致。而且尽量避免使用某些成员初始化其他成员。\n默认实参和构造函数： 如果一个构造函数为所有参数都提供了默认实参，则它实际上也定义了默认构造函数。\n1.7.2 构造函数初始化时必须采用列表初始化的情形： const修饰的成员变量 引用成员变量 数据成员是某种未提供默认构造函数的类类型 1.7.3 默认构造函数 当对象默认初始化或者值初始化时，会自动调用默认构造函数。\n默认初始化的情况：\n在块作用域内不使用任何初始值定义一个非静态变量或者数组时 当一个类本身包含类类型的成员且使用合成的默认构造函数时 当类类型的成员没有在构造函数初始值列表中显示初始化时 值初始化的情形：\n在数组初始化的过程中若提供的初始值少于数组的大小时 不使用初始值顶一个局部静态变量时 通过形式T()的表达式请求值初始化时，其中T为类型名 温馨提示\n如果在一个类中定义构造函数，最好提供一个默认构造函数。\n1.8 析构函数的性质 析构函数不能重载 析构函数可以为虚函数，基类的析构函数建议定义为虚函数。 基类析构函数使用虚函数的好处：当使用基类的指针保存派生类的对象时，我们在释放基类的指针时不仅会释放基类的成员，还会释放派生的的成员，避免造成内存泄露。例如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class ClxBase { public: ClxBase() {}; virtual ~ClxBase() { cout \u0026lt;\u0026lt; \u0026#34;Output from the destructor of class ClxBase!\u0026#34; \u0026lt;\u0026lt; endl;}; virtual void DoSomething() { cout \u0026lt;\u0026lt; \u0026#34;Do something in class ClxBase!\u0026#34; \u0026lt;\u0026lt; endl; }; }; class ClxDerived : public ClxBase { public: ClxDerived() {}; ~ClxDerived() { cout \u0026lt;\u0026lt; \u0026#34;Output from the destructor of class ClxDerived!\u0026#34; \u0026lt;\u0026lt; endl; }; void DoSomething() override { cout \u0026lt;\u0026lt; \u0026#34;Do something in class ClxDerived!\u0026#34; \u0026lt;\u0026lt; endl; } }; int main() { ClxBase *p = new ClxDerived; p-\u0026gt;DoSomething(); delete p; return 0; } 温馨提示：\n绝不在构造和析构过程中调用virtual函数\n1.9 拷贝初始化发生的情形 用等号(=)定义类类型的对象 将一个对象作为实参传递给一个非引用类型的形参 从一个返回类型为非引用类型的函数返回一个对象 用花括号列表初始化一个数组中的元素或一个聚合类(struct)中的成员 1.10 拷贝构造和拷贝赋值运算符 拷贝构造函数的作用：使用一个存在的对象初始化一个未被初始化的对象。\n拷贝赋值运算符的作用：使用一个存在对象去替换一个已经初始化的对象。\n1.11 深拷贝与浅拷贝 浅拷贝，指的是在对象复制时，只对对象中的数据成员进行简单的赋值，默认拷贝构造函数执行的也是浅拷贝。大多情况下“浅拷贝”已经能很好地工作了，但是一旦对象存在动态成员，那么浅拷贝就会出问题。 “深拷贝”的情况下，对于对象中动态成员，就不能仅仅简单地赋值了，而应该重新动态分配空间。\n在某些状况下，类内成员变量需要动态开辟堆内存，如果实行位拷贝，也就是把对象里的值完全复制给另一个对象，如A=B。这时，如果B中有一个成员变量指针已经申请了内存，那A中的那个成员变量也指向同一块内存。这就出现了问题：当B把内存释放了（如：析构），这时A内的指针就是野指针了，出现运行错误。 深拷贝和浅拷贝可以简单理解为：如果一个类拥有资源，当这个类的对象发生复制过程的时候，资源重新分配，这个过程就是深拷贝，反之，没有重新分配资源，就是浅拷贝。\n1.12 基类和派生类 1.12.1 基类 温馨提示\n基类通常都应该定义一个虚析构函数，即使该函数不执行任何实际操作也是如此。\n派生类可以继承其基类的成员，然而当遇到与类型相关的操作时，派生类必须对其重新定义。即派生类需要对这些操作提供自己的新定义以覆盖(override)从基类继承而来的旧定义。 基类通过在其成员函数的声明语句之前加上关键字virtual使得该函数执行动态绑定。任何构造函数之外的非静态函数都可以是虚函数 。关键字virtual只能出现在类内部的声明语句之前而不能用于类外部的函数定义。 成员函数如果没被声明为虚函数，则其解析过程发生在编译时。\n1.12.2 定义派生类 派生类必须通过使用类派生列表明确指出它是从哪个基类继承而来的。\n派生类必须将其继承而来的成员函数中需要覆盖的那些重新声明。\n1.12.2.1 派生类的声明 派生类的声明与其它类差别不大，声明中包含类名但是不包含它的派生列表：\n1 2 class Bulk_quote : public Quote;\t//错误：派生列表不能出现在这里 class Bulk_quote;\t//正确：声明派生类的正确方式 1.12.2.2 派生类构造函数 尽管在派生类对象中包含有基类继承而来的成员，但是派生类并不能直接初始化这些成员。\n派生类也必须使用基类的构造函数来初始化它的基类部分。\n除非特别指出，否则派生类对象的基类部分会像数据成员一样执行默认初始化。 如果想使用其他的基类构造函数，我们需要一类名加圆括号内的实参列表的形式为构造函数提供初始值。 这些实参将帮助编译器决定应该选用那个构造函数来初始化派生类对象的基础部分。例如：\n1 2 3 //Bluk_quote的基类为Quote，在Bluk_quoute初始化时使用Quote的构造函数 Bluk_quote(const std::string\u0026amp; book, double p, std::size_t qty, double disc): Quoute(book, p), min_qty(qty), discount(disc){} 温馨提示\n首先初始化基类部分，然后按照声明的顺序依次初始化派生类的成员。\n1.12.2.3 派生类初始化的顺序 首先调用虚基类的构造函数 然后调用基类的构造函数。若有多个基类，基类构造函数的初始化顺序与派生类的派生列表一致 然后调用成员对象的构造函数 最后调用对象的本身的构造函数。 1.12.2.4 派生类中的虚函数 派生类经常覆盖它继承的虚函数。如果派生类没有覆盖其基类中的某个虚函数，则该虚函数的行为类似于其他的普通成员，派生类会直接继承其在基类中的版本。\n因为在派生类对象中含有与其基类对应的组成部分，所以我们能把派生类的对象当成基类对象使用。而且我们也能将基类的指针或引用绑定到派生类对象的中的基类部分上。这种转换称为派生类到基类的类型转换。编译器会隐式地执行派生类到基类的转换。 这种隐式特性意味着可以把派生类对象或者派生类对象的引用用在需要基类引用的地方。同样，我们也可以把派生类对象的指针用在需要基类指针的地方。\n1.12.2.5 继承和静态成员 如果基类定义了一个静态成员，则在整个继承体系中只存在该成员的唯一定义。不论从基类中派生出来多少个派生类，对于每个静态成员都只存在唯一的实例。\n静态成员遵循通用的访问控制规则，如果基类中的成员是private，则派生类无权访问它。假设静态成员是可访问的，则我们既能通过基类使用它也能通过派生类使用它。\n1.12.2.6 被用作基类的类 如果我们想使用某个类作为基类，这该类必须已经定义而非仅仅声明。\n1 2 3 class Quote;\t//声明但未定义 //错误：Quote必须已经定义 class Bluk_quote : public Quote{...}; 这一规定的原因显而易见：派生类中包含基类并且可以使用它从基类继承而来的成员，为了使用这些成员，派生类当然要知道它们是什么。因此，一个类不能派生它本身。\n1.12.2.7 防止继承的发生 有时我们定义这样的类，不希望其他类继承它。C++11提供了一种防止继承发生的方法，即在类名后跟一个关键字final：\n1 class NoDerived final{}; //NoDerived不能作为基类 1.13 C++多态特性 C++的多态性实现方式有：编译时多态(静态绑定)和运行时多态(动态绑定)。\n静态绑定：绑定的是对象的静态类型，依赖于对象的静态类型，发生在编译期。函数重载和模板实现的是静态绑定。 动态绑定：绑定的是对象的动态类型，依赖于对象的动态类型，发生在运行期。虚函数实现的是动态绑定。\nvirtual函数是动态绑定，non-virtual函数是静态绑定，缺省参数值也是静态绑定的。 1.13.1 多态性(polymorphism) 引用或指针的静态类型与动态类型不同这一事实是C++语言支持动态性的根本所在。\n当我们使用基类的引用或指针调用基类中定义的一个函数时，我们并不知道该函数真正作用的对象是什么类型。\n因为它可能是一个基类的对象也可能是一个派生类的对象。如果该函数是虚函数，则直到运行时才会决定到底执行哪个版本。\n判断的依据是引用或指针所绑定的对象的真实类型。\n另一方面，对非虚函数的调用在编译时进行绑定。类似的，通过对象进行的函数(虚函数或非虚函数)调用也在编译时绑定。\n对象的类型是确定不变的。通过对象进行的函数调用将在编译时绑定到该对象所属类中的函数版本上。\n1.13.2 动态绑定 只有在我们使用基类的引用或者指针调用基类的虚函数是才会发生动态绑定。\n必须使用基类的指针或者引用； 基类中必须存在这个调用的虚函数。 参见1.5.4的示例程序。 1.13.3 静态绑定 当我们通过一个具有普通类型(非引用非指针)的表达式调用虚函数时，在编译时就会将调用的版本确定下来，称为静态绑定。\n除了动态绑定外，其它情况均为静态绑定。\n例如如下程序的输出结果为：B-\u0026gt;1\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 class A{ public: virtual void func(int val = 1) { std::cout\u0026lt;\u0026lt;\u0026#34;A-\u0026gt;\u0026#34;\u0026lt;\u0026lt;val \u0026lt;\u0026lt;std::endl;} virtual void test(){ func();} }; class B : public A{ public: void func(int val=0){std::cout\u0026lt;\u0026lt;\u0026#34;B-\u0026gt;\u0026#34;\u0026lt;\u0026lt;val \u0026lt;\u0026lt;std::endl;} }; int main(int argc ,char* argv[]){ B* p = new B; p-\u0026gt;test(); return 0; } 上述程序的执行过程是：首先执行new B，调用类B的默认构造函数创建类B的对象。然后类B类型的指针指向以上新建的对象。 而后指针p调用test()函数。因为类B继承至类A，而且类B没有test()函数。因此此时的test()函数是类A的test()函数。 又因为类B拥有与类A形参列表相同的函数func()，而且类A的func()函数为虚函数。因此类B的func()函数会覆盖类A的函数。 因此类B在执行test()函数时，调用的是类B的func()函数。但是因为缺省参数是静态绑定的，因此val的值是基类A中的默认参数。因此就有： “绝不重新定义继承而来的缺省参数（Never redefine function’s inherited default parameters value.）”\n在构造函数中不要调用虚函数。在基类构造的时候，虚函数是非虚函数，不会走到派生类中，既是采用的静态绑定。 当我们构造一个子类的对象时，先调用基类的构造函数，构造子类中基类部分，子类还没有构造，还没有初始化，如果在基类的构造中调用虚函数，如果可以的话就是调用一个还没有被初始化的对象，那是很危险的。 在析构函数中也不要调用虚函数。在析构的时候会首先调用子类的析构函数，析构掉对象中的子类部分，然后在调用基类的析构函数析构基类部分。\n1.13.4 虚函数的性质 类中除了构造函数，静态函数以外的函数都可以为虚函数。 派生类要想覆盖(override)基类的虚函数，必须与基类的虚函数拥有相同的函数参数列表。\n在C++语言中，当我们使用基类的引用或指针调用一个虚成员函数时会执行动态绑定。因为我们知道运行时才知道调用了哪个版本的虚函数，所以所有虚函数都必须有定义。因此，我们必须为每一个虚函数都提供定义，而不管它是否被用到。只是因为，编译器也无法确定到底会使用哪个虚函数。\n对虚函数的调用可能在运行时才能被解析\n当某个虚函数通过指针或引用调用时，编译器产生的代码直到运行时才能确定应该调用哪个版本的函数。被调用的函数是与绑定到指针或引用上的对象的动态类型相匹配的哪一个。\n1 2 3 4 Quoute base(\u0026#34;0-201-82470-1\u0026#34;, 50); print_total(cout, base, 10);\t//调用Quote::net_price Bulk_quote derived(\u0026#34;0-201-82470-1\u0026#34;, 50, 5, 0.19); print_total(cout, derived, 10);\t//调用Bulk_quote:net_price 1.13.4.1 派生类中的虚函数 当我们在派生类中覆盖了某个虚函数时，可以再一次使用virtual关键字指出该函数的性质。\n然而这么做并非必须，因为一旦某个函数被声明为虚函数，则在所有派生类中它都是虚函数。\n一个派生类的函数如果覆盖了某个继承而来的虚函数，则它的形参类型必须与被它覆盖的基类函数完全一致。\n同样，派生类中虚函数的返回类型也必须与基类函数匹配。该规则存在一个例外, 当类的虚函数返回类型是类本身的指针或引用时，可以不遵循上述规则。例如，如果D由B派生得到，则基类的虚函数可以返回B*而派生类的对应函数可以返回D*。只不过这样的返回类型要求从D到B的类型转换是可访问的。\n温馨提示\n基类中的虚函数在派生类中隐含地也是一个虚函数。当派生类覆盖了某个虚函数时，该函数在基类中的形参必须与派生类中的形参严格匹配。\n1 2 3 4 5 6 7 8 9 10 11 struct B{ virtual void f1(int) const; virtual void f2(); void f3(); }; struct D1 : B{ void f1(int) const override; //正确：f1与基类中的f1匹配 void f2(int) override; //错误：B没有形如f2(int)的函数 void f3() override; //错误：B中f3不是虚函数 void f4() override; //错误：B中没有名为f4的函数 } 因为只有虚函数才能被覆盖。所以编译器会拒绝D1的f3。\n该函数不是B中的虚函数，因此它不能被覆盖。类似的，f4的声明也会发生错误，因为B中根本就没有名为f4的函数。\n我们还能把某个函数指定为final，如果我们已经把函数定义为final，则之后任何尝试覆盖该函数的操作都将引发错误：\n1 2 3 4 5 6 7 8 struct D2 : B{ //从B继承f2()和f3(),覆盖f1(int) void f1(int) const final; }; struct D3 : D2{ void f2();\t//正确：覆盖从间接基类B继承而来的f2 void f1(int) const;\t//错误：D2已经将f2声明为final }; 1.13.4.2 虚函数与默认实参 和其他函数一样，虚函数也可以拥有默认实参。如果某次函数调用使用了默认实参，则该实参值由本次调用的静态类型决定。 换句话说，如果我们通过基类的引用或指针 调用函数，则使用基类中定义的默认实参，即使实际运行的派生类中的函数版本也是如此。此时，传入派生类函数的将是基类函数定义的默认实参。如果派生类函数依赖不同的实参，则程序结果将与我们的与其不符。\n1.13.4.3 回避虚函数的机制 在某些情况下，我们希望对虚函数的调用不要进行动态绑定，而是强迫其执行虚函数的某个特定版本。使用作用域运算符可以实现这一目的。例如：\n1 2 //强行调用基类中定义的函数版本而不管baseP的动态类型到底是什么 double undiscounted = baseP-\u0026gt;Quote::net_price(42); 1.13.4.4 虚函数表 C++中虚函数使用虚函数表和虚函数表指针实现。\n虚函数表(vtabel,virtual function table):虚函数表是编译器在编译阶段生成的。虚函数表中存放的是虚函数的指针。\n编译器在每个含有虚函数的类中包含了一个虚函数表指针*__vptr。当创建一个该类的实例时，虚函数表指针将指向虚函数表。虚函数表存放在只读区(.rodata区)。\n1.14 访问控制与继承 继承类成员的访问级别\n成员权限(下)/ 继承权限(右) public protected private public public protected private protected protected protected private private 不可访问 不可访问 不可访问 ","date":"2024-12-15T22:08:07+08:00","permalink":"https://alvincat.top/post/cpp/cpp_oop/","tags":["OOP"],"title":"C++面向对象理论知识"},{"categories":["Tools"],"contents":"1 Qt下载与安装 QT5.9下载地址\n2 QT经典示例程序 简单计算器示例代码\n3 QT视频教程 传智播客《QT从入门到实战完整版》 \u0026ndash;\u0026gt; 视频配套代码\n","date":"2024-12-15T14:40:46+08:00","permalink":"https://alvincat.top/post/tools/qt_usful_tips/","tags":["QT"],"title":"QT入门"},{"categories":[""],"contents":"GCC总结常用编译命令和常用内置函数。\n1 GCC常用编译选项 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 file.c\tC语言源代码 file.i\t预处理后的C语言源文件 file.s\tGUN汇编代码 file.o\t链接文件 .a 归档库文件(Archive file) -o file\t指定生成的可执行文件的文件名为file -c\t编译或者汇编源代码，但是不执行链接操作；生成file.o文件 -E\t对源文件进行预处理,得到的信息显示在stdin;一般重定位到某个文件中，例如： gcc -E main.c \u0026gt; main.i -g\t在目标程序中加入调试信息，用于debug -I\t指定头文件所在的文件夹 -L\t指定函数库所在的文件夹 -O 对编译代码进行优化，后跟优化级别。例如-O3 -S\t将源代码编译为汇编代码；生成file.s文件 -std=standard standard,其中standard为C/C++的标准，例如c89,c99,c++0x,c++11 -Wall\t打开所有警告信息 2 gcc编译时使用asan的方法 环境安装和gcc版本对应的libasan版本。 编译代码时添加-fsanitize=address参数。 例如：\n1 gcc -Wall -g -std=c99 -fsanitize=address lru.c -o lru 备注：ubuntu系统中不同asan版本和gcc的对应关系。\nlibasan0: gcc-4.8 libasan2: gcc-5 libasan3: gcc-6 libasan4: gcc-7 libasan5: gcc-8 3 gcc编译c代码的流程","date":"2024-12-14T19:44:49+08:00","permalink":"https://alvincat.top/post/tools/gcc_usful_tips/","tags":[""],"title":"GCC常用编译命令和常用内置函数"},{"categories":["CPP"],"contents":"本文总结vector的原理和使用方法。\n1 vector的实现原理 1.2 vector保存在栈上还是堆上？ 示例代码1: 1 2 3 4 5 6 7 8 9 10 11 12 13 vector\u0026lt;int\u0026gt;* test_vec(void) { vector\u0026lt;int\u0026gt; vec; vec.push_back(1); vec.push_back(2); return \u0026amp;vec; } int main() { vector\u0026lt;int\u0026gt;* o_vec = test_vec(); printf(\u0026#34;%d\\n\u0026#34;, (*o_vec)[0]); return 0; } 在编译时会有如下提示：warning: reference to local variable 'vec' returned [-Wreturn-local-addr]。 而忽略该告警直接编译运行，进程会coredump。\n示例代码2 1 2 3 4 5 6 7 8 9 10 11 12 13 vector\u0026lt;int\u0026gt; test_vec(void) { vector\u0026lt;int\u0026gt; vec; vec.push_back(1); vec.push_back(2); return vec; } int main() { vector\u0026lt;int\u0026gt; o_vec = test_vec(); printf(\u0026#34;%d\\n\u0026#34;, o_vec[0]); return 0; } 该段代码可以正常编译运行，无任何报错。\n示例代码3 1 2 3 4 5 6 7 8 9 10 11 12 13 vector\u0026lt;int\u0026gt;* test_vec(void) { vector\u0026lt;int\u0026gt;* vec = new vector\u0026lt;int\u0026gt;; vec-\u0026gt;push_back(1); vec-\u0026gt;push_back(2); return vec; } int main() { vector\u0026lt;int\u0026gt;* o_vec = test_vec(); printf(\u0026#34;%d\\n\u0026#34;, (*o_vec)[0]); return 0; } 这段代码可以正常运行。\n原因分析：\n为什么示例代码1和实例代码2中的函数test_vec()相同，为啥返回vector变量的地址会coredump，而直接将vector的名字返回却可以正常运行呢？ 答：因为C++ 11新特性中支持直接返回容器名会默认调用move()函数,参考1.3.1和1.3.2的内容。 1.3 C++中返回一个vector的方法 1.3.1 通过value返回 1 2 3 4 5 6 #include \u0026lt;vector\u0026gt; std::vector\u0026lt;int\u0026gt; createVector() { std::vector\u0026lt;int\u0026gt; vec = {1, 2, 3, 4, 5}; return vec; // Move semantics will be applied here } 1.3.2 通过move()函数 1 2 3 4 std::vector\u0026lt;int\u0026gt; createVector() { std::vector\u0026lt;int\u0026gt; vec = {1, 2, 3, 4, 5}; return std::move(vec); // Explicitly moving the vector } 1.3.3 返回静态引用 1 2 3 4 std::vector\u0026lt;int\u0026gt;\u0026amp; getGlobalVector() { static std::vector\u0026lt;int\u0026gt; vec = {1, 2, 3, 4, 5}; return vec; // Return a reference to a static vector } 1.3.4 通过传入引用实现 1 2 3 void fillVector(std::vector\u0026lt;int\u0026gt;\u0026amp; vec) { vec = {1, 2, 3, 4, 5}; // Modify the existing vector } 1.3.5 使用std::optional 1 2 3 4 5 6 7 8 9 #include \u0026lt;optional\u0026gt; #include \u0026lt;vector\u0026gt; std::optional\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; createVector(bool shouldCreate) { if (shouldCreate) { return std::vector\u0026lt;int\u0026gt;{1, 2, 3, 4, 5}; } return std::nullopt; // No vector created } 相关参考文档：\nIs there a way to return a vector more efficiently\n一文带你详细介绍c++中的std::move函数\n【Modern C++】深入理解左值、右值\n2 vector的使用方法 2.1 vector初始化的方法 1 2 3 4 5 6 7 std::vector\u0026lt;int\u0026gt; first; // empty vector of ints std::vector\u0026lt;int\u0026gt; second(4, 100); // four ints with value 100 std::vector\u0026lt;int\u0026gt; third(second.begin(),second.end()); // iterating through second std::vector\u0026lt;int\u0026gt; fourth(third); // a copy of third int tmp[] = { 10, 20, 30 }; std::vector\u0026lt;int\u0026gt; v(tmp, tmp + 3 ); // use some utility to avoid hardcoding the size here 2.2 vector容量相关 1 2 3 std::vector\u0026lt;int\u0026gt; vec(3, 235); vec.size(); // return the number of elements vec.empty(); // checks whether the container is empty 2.3 vector数据修改 1 2 3 std::vector\u0026lt;int\u0026gt; vec(3, 235); // init vector vec.push_back(12); // adds an element to the end vec.pop_back(); // removes the last element ","date":"2024-12-13T22:45:13+08:00","permalink":"https://alvincat.top/post/cpp/stl/vector/","tags":["STL","vector"],"title":"Vector"},{"categories":["CPP"],"contents":"1 C++数据处理 1.1 获取浮点型数的小数部分 1 2 float value; float rear = value - (int)value; //获取浮点数的小数部分 1.2 double保留指定位数的小数 1 2 3 4 5 6 double round(double number, unsigned int bits) { stringstream ss; ss \u0026lt;\u0026lt; fixed \u0026lt;\u0026lt; setprecision(bits) \u0026lt;\u0026lt; number; ss \u0026gt;\u0026gt; number; return number; } 2 动态数组初始化方法 1 2 3 4 5 int size = 50; int *p=new int[size]; //申请动态数组 delete [] p; //释放动态数组 ","date":"2024-12-13T22:39:33+08:00","permalink":"https://alvincat.top/post/cpp/cpp_common_tips/","tags":[""],"title":"C++编码中常用的基础知识"},{"categories":["Tools"],"contents":"1 本文的gdb脚本的使用方法 将步骤2中的脚本拷贝到文件.gdbinit文件中； 然后就可以在gdb中使用对应的命令，查看c++容器中的内容。 2 GDB打印C++中容器内容的gdb脚本 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 # # STL GDB evaluators/views/utilities - 1.03 # # The new GDB commands: # are entirely non instrumental # do not depend on any \u0026#34;inline\u0026#34;(s) - e.g. size(), [], etc # are extremely tolerant to debugger settings # # This file should be \u0026#34;included\u0026#34; in .gdbinit as following: # source stl-views.gdb or just paste it into your .gdbinit file # # The following STL containers are currently supported: # # std::vector\u0026lt;T\u0026gt; -- via pvector command # std::list\u0026lt;T\u0026gt; -- via plist or plist_member command # std::map\u0026lt;T,T\u0026gt; -- via pmap or pmap_member command # std::multimap\u0026lt;T,T\u0026gt; -- via pmap or pmap_member command # std::set\u0026lt;T\u0026gt; -- via pset command # std::multiset\u0026lt;T\u0026gt; -- via pset command # std::deque\u0026lt;T\u0026gt; -- via pdequeue command # std::stack\u0026lt;T\u0026gt; -- via pstack command # std::queue\u0026lt;T\u0026gt; -- via pqueue command # std::priority_queue\u0026lt;T\u0026gt; -- via ppqueue command # std::bitset\u0026lt;n\u0026gt; -- via pbitset command # std::string -- via pstring command # std::widestring -- via pwstring command # # The end of this file contains (optional) C++ beautifiers # Make sure your debugger supports $argc # # Simple GDB Macros writen by Dan Marinescu (H-PhD) - License GPL # Inspired by intial work of Tom Malnar, # Tony Novac (PhD) / Cornell / Stanford, # Gilad Mishne (PhD) and Many Many Others. # Contact: dan_c_marinescu@yahoo.com (Subject: STL) # # Modified to work with g++ 4.3 by Anders Elton # Also added _member functions, that instead of printing the entire class in map, prints a member. # # std::vector\u0026lt;\u0026gt; # define pvector if $argc == 0 help pvector else set $size = $arg0._M_impl._M_finish - $arg0._M_impl._M_start set $capacity = $arg0._M_impl._M_end_of_storage - $arg0._M_impl._M_start set $size_max = $size - 1 end if $argc == 1 set $i = 0 while $i \u0026lt; $size printf \u0026#34;elem[%u]: \u0026#34;, $i p *($arg0._M_impl._M_start + $i) set $i++ end end if $argc == 2 set $idx = $arg1 if $idx \u0026lt; 0 || $idx \u0026gt; $size_max printf \u0026#34;idx1, idx2 are not in acceptable range: [0..%u].\\n\u0026#34;, $size_max else printf \u0026#34;elem[%u]: \u0026#34;, $idx p *($arg0._M_impl._M_start + $idx) end end if $argc == 3 set $start_idx = $arg1 set $stop_idx = $arg2 if $start_idx \u0026gt; $stop_idx set $tmp_idx = $start_idx set $start_idx = $stop_idx set $stop_idx = $tmp_idx end if $start_idx \u0026lt; 0 || $stop_idx \u0026lt; 0 || $start_idx \u0026gt; $size_max || $stop_idx \u0026gt; $size_max printf \u0026#34;idx1, idx2 are not in acceptable range: [0..%u].\\n\u0026#34;, $size_max else set $i = $start_idx while $i \u0026lt;= $stop_idx printf \u0026#34;elem[%u]: \u0026#34;, $i p *($arg0._M_impl._M_start + $i) set $i++ end end end if $argc \u0026gt; 0 printf \u0026#34;Vector size = %u\\n\u0026#34;, $size printf \u0026#34;Vector capacity = %u\\n\u0026#34;, $capacity printf \u0026#34;Element \u0026#34; whatis $arg0._M_impl._M_start end end document pvector Prints std::vector\u0026lt;T\u0026gt; information. Syntax: pvector \u0026lt;vector\u0026gt; \u0026lt;idx1\u0026gt; \u0026lt;idx2\u0026gt; Note: idx, idx1 and idx2 must be in acceptable range [0..\u0026lt;vector\u0026gt;.size()-1]. Examples: pvector v - Prints vector content, size, capacity and T typedef pvector v 0 - Prints element[idx] from vector pvector v 1 2 - Prints elements in range [idx1..idx2] from vector end # # std::list\u0026lt;\u0026gt; # define plist if $argc == 0 help plist else set $head = \u0026amp;$arg0._M_impl._M_node set $current = $arg0._M_impl._M_node._M_next set $size = 0 while $current != $head if $argc == 2 printf \u0026#34;elem[%u]: \u0026#34;, $size p *($arg1*)($current + 1) end if $argc == 3 if $size == $arg2 printf \u0026#34;elem[%u]: \u0026#34;, $size p *($arg1*)($current + 1) end end set $current = $current._M_next set $size++ end printf \u0026#34;List size = %u \\n\u0026#34;, $size if $argc == 1 printf \u0026#34;List \u0026#34; whatis $arg0 printf \u0026#34;Use plist \u0026lt;variable_name\u0026gt; \u0026lt;element_type\u0026gt; to see the elements in the list.\\n\u0026#34; end end end document plist Prints std::list\u0026lt;T\u0026gt; information. Syntax: plist \u0026lt;list\u0026gt; \u0026lt;T\u0026gt; \u0026lt;idx\u0026gt;: Prints list size, if T defined all elements or just element at idx Examples: plist l - prints list size and definition plist l int - prints all elements and list size plist l int 2 - prints the third element in the list (if exists) and list size end define plist_member if $argc == 0 help plist_member else set $head = \u0026amp;$arg0._M_impl._M_node set $current = $arg0._M_impl._M_node._M_next set $size = 0 while $current != $head if $argc == 3 printf \u0026#34;elem[%u]: \u0026#34;, $size p (*($arg1*)($current + 1)).$arg2 end if $argc == 4 if $size == $arg3 printf \u0026#34;elem[%u]: \u0026#34;, $size p (*($arg1*)($current + 1)).$arg2 end end set $current = $current._M_next set $size++ end printf \u0026#34;List size = %u \\n\u0026#34;, $size if $argc == 1 printf \u0026#34;List \u0026#34; whatis $arg0 printf \u0026#34;Use plist_member \u0026lt;variable_name\u0026gt; \u0026lt;element_type\u0026gt; \u0026lt;member\u0026gt; to see the elements in the list.\\n\u0026#34; end end end document plist_member Prints std::list\u0026lt;T\u0026gt; information. Syntax: plist \u0026lt;list\u0026gt; \u0026lt;T\u0026gt; \u0026lt;idx\u0026gt;: Prints list size, if T defined all elements or just element at idx Examples: plist_member l int member - prints all elements and list size plist_member l int member 2 - prints the third element in the list (if exists) and list size end # # std::map and std::multimap # define pmap if $argc == 0 help pmap else set $tree = $arg0 set $i = 0 set $node = $tree._M_t._M_impl._M_header._M_left set $end = $tree._M_t._M_impl._M_header set $tree_size = $tree._M_t._M_impl._M_node_count if $argc == 1 printf \u0026#34;Map \u0026#34; whatis $tree printf \u0026#34;Use pmap \u0026lt;variable_name\u0026gt; \u0026lt;left_element_type\u0026gt; \u0026lt;right_element_type\u0026gt; to see the elements in the map.\\n\u0026#34; end if $argc == 3 while $i \u0026lt; $tree_size set $value = (void *)($node + 1) printf \u0026#34;elem[%u].left: \u0026#34;, $i p *($arg1*)$value set $value = $value + sizeof($arg1) printf \u0026#34;elem[%u].right: \u0026#34;, $i p *($arg2*)$value if $node._M_right != 0 set $node = $node._M_right while $node._M_left != 0 set $node = $node._M_left end else set $tmp_node = $node._M_parent while $node == $tmp_node._M_right set $node = $tmp_node set $tmp_node = $tmp_node._M_parent end if $node._M_right != $tmp_node set $node = $tmp_node end end set $i++ end end if $argc == 4 set $idx = $arg3 set $ElementsFound = 0 while $i \u0026lt; $tree_size set $value = (void *)($node + 1) if *($arg1*)$value == $idx printf \u0026#34;elem[%u].left: \u0026#34;, $i p *($arg1*)$value set $value = $value + sizeof($arg1) printf \u0026#34;elem[%u].right: \u0026#34;, $i p *($arg2*)$value set $ElementsFound++ end if $node._M_right != 0 set $node = $node._M_right while $node._M_left != 0 set $node = $node._M_left end else set $tmp_node = $node._M_parent while $node == $tmp_node._M_right set $node = $tmp_node set $tmp_node = $tmp_node._M_parent end if $node._M_right != $tmp_node set $node = $tmp_node end end set $i++ end printf \u0026#34;Number of elements found = %u\\n\u0026#34;, $ElementsFound end if $argc == 5 set $idx1 = $arg3 set $idx2 = $arg4 set $ElementsFound = 0 while $i \u0026lt; $tree_size set $value = (void *)($node + 1) set $valueLeft = *($arg1*)$value set $valueRight = *($arg2*)($value + sizeof($arg1)) if $valueLeft == $idx1 \u0026amp;\u0026amp; $valueRight == $idx2 printf \u0026#34;elem[%u].left: \u0026#34;, $i p $valueLeft printf \u0026#34;elem[%u].right: \u0026#34;, $i p $valueRight set $ElementsFound++ end if $node._M_right != 0 set $node = $node._M_right while $node._M_left != 0 set $node = $node._M_left end else set $tmp_node = $node._M_parent while $node == $tmp_node._M_right set $node = $tmp_node set $tmp_node = $tmp_node._M_parent end if $node._M_right != $tmp_node set $node = $tmp_node end end set $i++ end printf \u0026#34;Number of elements found = %u\\n\u0026#34;, $ElementsFound end printf \u0026#34;Map size = %u\\n\u0026#34;, $tree_size end end document pmap Prints std::map\u0026lt;TLeft and TRight\u0026gt; or std::multimap\u0026lt;TLeft and TRight\u0026gt; information. Works for std::multimap as well. Syntax: pmap \u0026lt;map\u0026gt; \u0026lt;TtypeLeft\u0026gt; \u0026lt;TypeRight\u0026gt; \u0026lt;valLeft\u0026gt; \u0026lt;valRight\u0026gt;: Prints map size, if T defined all elements or just element(s) with val(s) Examples: pmap m - prints map size and definition pmap m int int - prints all elements and map size pmap m int int 20 - prints the element(s) with left-value = 20 (if any) and map size pmap m int int 20 200 - prints the element(s) with left-value = 20 and right-value = 200 (if any) and map size end define pmap_member if $argc == 0 help pmap_member else set $tree = $arg0 set $i = 0 set $node = $tree._M_t._M_impl._M_header._M_left set $end = $tree._M_t._M_impl._M_header set $tree_size = $tree._M_t._M_impl._M_node_count if $argc == 1 printf \u0026#34;Map \u0026#34; whatis $tree printf \u0026#34;Use pmap \u0026lt;variable_name\u0026gt; \u0026lt;left_element_type\u0026gt; \u0026lt;right_element_type\u0026gt; to see the elements in the map.\\n\u0026#34; end if $argc == 5 while $i \u0026lt; $tree_size set $value = (void *)($node + 1) printf \u0026#34;elem[%u].left: \u0026#34;, $i p (*($arg1*)$value).$arg2 set $value = $value + sizeof($arg1) printf \u0026#34;elem[%u].right: \u0026#34;, $i p (*($arg3*)$value).$arg4 if $node._M_right != 0 set $node = $node._M_right while $node._M_left != 0 set $node = $node._M_left end else set $tmp_node = $node._M_parent while $node == $tmp_node._M_right set $node = $tmp_node set $tmp_node = $tmp_node._M_parent end if $node._M_right != $tmp_node set $node = $tmp_node end end set $i++ end end if $argc == 6 set $idx = $arg5 set $ElementsFound = 0 while $i \u0026lt; $tree_size set $value = (void *)($node + 1) if *($arg1*)$value == $idx printf \u0026#34;elem[%u].left: \u0026#34;, $i p (*($arg1*)$value).$arg2 set $value = $value + sizeof($arg1) printf \u0026#34;elem[%u].right: \u0026#34;, $i p (*($arg3*)$value).$arg4 set $ElementsFound++ end if $node._M_right != 0 set $node = $node._M_right while $node._M_left != 0 set $node = $node._M_left end else set $tmp_node = $node._M_parent while $node == $tmp_node._M_right set $node = $tmp_node set $tmp_node = $tmp_node._M_parent end if $node._M_right != $tmp_node set $node = $tmp_node end end set $i++ end printf \u0026#34;Number of elements found = %u\\n\u0026#34;, $ElementsFound end printf \u0026#34;Map size = %u\\n\u0026#34;, $tree_size end end document pmap_member Prints std::map\u0026lt;TLeft and TRight\u0026gt; or std::multimap\u0026lt;TLeft and TRight\u0026gt; information. Works for std::multimap as well. Syntax: pmap \u0026lt;map\u0026gt; \u0026lt;TtypeLeft\u0026gt; \u0026lt;TypeRight\u0026gt; \u0026lt;valLeft\u0026gt; \u0026lt;valRight\u0026gt;: Prints map size, if T defined all elements or just element(s) with val(s) Examples: pmap_member m class1 member1 class2 member2 - prints class1.member1 : class2.member2 pmap_member m class1 member1 class2 member2 lvalue - prints class1.member1 : class2.member2 where class1 == lvalue end # # std::set and std::multiset # define pset if $argc == 0 help pset else set $tree = $arg0 set $i = 0 set $node = $tree._M_t._M_impl._M_header._M_left set $end = $tree._M_t._M_impl._M_header set $tree_size = $tree._M_t._M_impl._M_node_count if $argc == 1 printf \u0026#34;Set \u0026#34; whatis $tree printf \u0026#34;Use pset \u0026lt;variable_name\u0026gt; \u0026lt;element_type\u0026gt; to see the elements in the set.\\n\u0026#34; end if $argc == 2 while $i \u0026lt; $tree_size set $value = (void *)($node + 1) printf \u0026#34;elem[%u]: \u0026#34;, $i p *($arg1*)$value if $node._M_right != 0 set $node = $node._M_right while $node._M_left != 0 set $node = $node._M_left end else set $tmp_node = $node._M_parent while $node == $tmp_node._M_right set $node = $tmp_node set $tmp_node = $tmp_node._M_parent end if $node._M_right != $tmp_node set $node = $tmp_node end end set $i++ end end if $argc == 3 set $idx = $arg2 set $ElementsFound = 0 while $i \u0026lt; $tree_size set $value = (void *)($node + 1) if *($arg1*)$value == $idx printf \u0026#34;elem[%u]: \u0026#34;, $i p *($arg1*)$value set $ElementsFound++ end if $node._M_right != 0 set $node = $node._M_right while $node._M_left != 0 set $node = $node._M_left end else set $tmp_node = $node._M_parent while $node == $tmp_node._M_right set $node = $tmp_node set $tmp_node = $tmp_node._M_parent end if $node._M_right != $tmp_node set $node = $tmp_node end end set $i++ end printf \u0026#34;Number of elements found = %u\\n\u0026#34;, $ElementsFound end printf \u0026#34;Set size = %u\\n\u0026#34;, $tree_size end end document pset Prints std::set\u0026lt;T\u0026gt; or std::multiset\u0026lt;T\u0026gt; information. Works for std::multiset as well. Syntax: pset \u0026lt;set\u0026gt; \u0026lt;T\u0026gt; \u0026lt;val\u0026gt;: Prints set size, if T defined all elements or just element(s) having val Examples: pset s - prints set size and definition pset s int - prints all elements and the size of s pset s int 20 - prints the element(s) with value = 20 (if any) and the size of s end # # std::dequeue # define pdequeue if $argc == 0 help pdequeue else set $vec = ($arg0) # size of one data element set $datasize = sizeof(**$vec._M_impl._M_map) # bufsize is the number of nodes per memory page set $bufsize = $datasize \u0026lt; 512 ? 512/$datasize : 1 set $iter = $vec._M_impl._M_start set $enditer = $vec._M_impl._M_finish set $mnode = $iter._M_node set $mfirst = $iter._M_first set $mlast = $iter._M_last set $mcur = $iter._M_cur set $size = 0 while ($mcur != $enditer._M_cur) if $argc == 2 printf \u0026#34;elem[%u]: \u0026#34;, $size p *($arg1*)($mcur) end if $argc == 3 if $size == $arg2 printf \u0026#34;elem[%u]: \u0026#34;, $size p *($arg1*)($mcur) end end if $argc == 1 printf \u0026#34;elem[%u]: \u0026#34;, $size p *$mcur end # now imitate iter.operator++ set $mcur++ if ($mcur == $mlast) set $mnode++ set $mfirst = *$mnode set $mlast = $mfirst + $bufsize set $mcur = $mfirst end set $size++ end printf \u0026#34;Dequeue size = %u\\n\u0026#34;, $size end end document pdequeue Prints std::dequeue\u0026lt;T\u0026gt; information. Syntax: pdequeue \u0026lt;dequeue\u0026gt;: Prints dequeue size, if T defined all elements Deque elements are listed \u0026#34;left to right\u0026#34; (left-most stands for front and right-most stands for back) Example: pdequeue d - prints all elements and size of d end # # std::stack # define pstack if $argc == 0 help pstack else set $start_cur = $arg0.c._M_impl._M_start._M_cur set $finish_cur = $arg0.c._M_impl._M_finish._M_cur set $size = $finish_cur - $start_cur set $i = $size - 1 while $i \u0026gt;= 0 p *($start_cur + $i) set $i-- end printf \u0026#34;Stack size = %u\\n\u0026#34;, $size end end document pstack Prints std::stack\u0026lt;T\u0026gt; information. Syntax: pstack \u0026lt;stack\u0026gt;: Prints all elements and size of the stack Stack elements are listed \u0026#34;top to buttom\u0026#34; (top-most element is the first to come on pop) Example: pstack s - prints all elements and the size of s end # # std::queue # define pqueue if $argc == 0 help pqueue else set $start_cur = $arg0.c._M_impl._M_start._M_cur set $finish_cur = $arg0.c._M_impl._M_finish._M_cur set $size = $finish_cur - $start_cur set $i = 0 while $i \u0026lt; $size p *($start_cur + $i) set $i++ end printf \u0026#34;Queue size = %u\\n\u0026#34;, $size end end document pqueue Prints std::queue\u0026lt;T\u0026gt; information. Syntax: pqueue \u0026lt;queue\u0026gt;: Prints all elements and the size of the queue Queue elements are listed \u0026#34;top to bottom\u0026#34; (top-most element is the first to come on pop) Example: pqueue q - prints all elements and the size of q end # # std::priority_queue # define ppqueue if $argc == 0 help ppqueue else set $size = $arg0.c._M_impl._M_finish - $arg0.c._M_impl._M_start set $capacity = $arg0.c._M_impl._M_end_of_storage - $arg0.c._M_impl._M_start set $i = $size - 1 while $i \u0026gt;= 0 p *($arg0.c._M_impl._M_start + $i) set $i-- end printf \u0026#34;Priority queue size = %u\\n\u0026#34;, $size printf \u0026#34;Priority queue capacity = %u\\n\u0026#34;, $capacity end end document ppqueue Prints std::priority_queue\u0026lt;T\u0026gt; information. Syntax: ppqueue \u0026lt;priority_queue\u0026gt;: Prints all elements, size and capacity of the priority_queue Priority_queue elements are listed \u0026#34;top to buttom\u0026#34; (top-most element is the first to come on pop) Example: ppqueue pq - prints all elements, size and capacity of pq end # # std::bitset # define pbitset if $argc == 0 help pbitset else p /t $arg0._M_w end end document pbitset Prints std::bitset\u0026lt;n\u0026gt; information. Syntax: pbitset \u0026lt;bitset\u0026gt;: Prints all bits in bitset Example: pbitset b - prints all bits in b end # # std::string # define pstring if $argc == 0 help pstring else printf \u0026#34;String \\t\\t\\t= \\\u0026#34;%s\\\u0026#34;\\n\u0026#34;, $arg0._M_data() printf \u0026#34;String size/length \\t= %u\\n\u0026#34;, $arg0._M_rep()._M_length printf \u0026#34;String capacity \\t= %u\\n\u0026#34;, $arg0._M_rep()._M_capacity printf \u0026#34;String ref-count \\t= %d\\n\u0026#34;, $arg0._M_rep()._M_refcount end end document pstring Prints std::string information. Syntax: pstring \u0026lt;string\u0026gt; Example: pstring s - Prints content, size/length, capacity and ref-count of string s end # # std::wstring # define pwstring if $argc == 0 help pwstring else call printf(\u0026#34;WString \\t\\t= \\\u0026#34;%ls\\\u0026#34;\\n\u0026#34;, $arg0._M_data()) printf \u0026#34;WString size/length \\t= %u\\n\u0026#34;, $arg0._M_rep()._M_length printf \u0026#34;WString capacity \\t= %u\\n\u0026#34;, $arg0._M_rep()._M_capacity printf \u0026#34;WString ref-count \\t= %d\\n\u0026#34;, $arg0._M_rep()._M_refcount end end document pwstring Prints std::wstring information. Syntax: pwstring \u0026lt;wstring\u0026gt; Example: pwstring s - Prints content, size/length, capacity and ref-count of wstring s end # # C++ related beautifiers (optional) # set print pretty on set print object on set print static-members on set print vtbl on set print demangle on set demangle-style gnu-v3 set print sevenbit-strings off set follow-fork-mode child set detach-on-fork off ","date":"2024-12-13T22:15:25+08:00","permalink":"https://alvincat.top/post/tools/gdb_print_stl_tool/","tags":["GDB"],"title":"GDB打印C++ STL容器中的内容的方法"},{"categories":["Linux"],"contents":"本文介绍Linux系统中各种钩子的使用方法以及使用场景。\n1 用户态钩子 2 内核态钩子","date":"2024-12-13T15:49:45+08:00","permalink":"https://alvincat.top/post/linux/linux_hook/","tags":["hook"],"title":"Linux系统中钩子的使用方法"},{"categories":["算法"],"contents":"本文介绍拓扑排序的原理和代码实现。\n1 拓扑排序的基本原理 能够使用拓扑排序的图一定是一个有向无环图(DAG, Directed Acyclic Graph)。若是一个有向有环图，则任务无法完成，存在循环依赖问题。\n2 拓扑排序的代码实现 2.1 使用深度优先遍历 2.2 使用广度优先遍历 2.3 课程表 课程表相关的LeetCode题目:\n207. 课程表\n210. 课程表 II\n2050. 并行课程 III\n2.3.1 207. 课程表 保存每个结点的入度数量； 保存每个结点的出度结点； 每次将入度为0的结点添加至队列，出队列时，将其关联的出度结点的入度减1； 当遍历完所有结点时，若存在入度不为0的结点，说明这个图存在环，任务无法完成；否则任务可以完成； 实际上该算法是用于判断这个有向图是否存在环。拓扑排序要求图为有向图无环。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class Solution { public: bool canFinish(int numCourses, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; prerequisites) { vector\u0026lt;int\u0026gt; indegree(numCourses, 0); unordered_map\u0026lt;int, vector\u0026lt;int\u0026gt;\u0026gt; outdegreeNode; // init indegree and outdegreeNode for (int i = 0; i \u0026lt; prerequisites.size(); ++i) { int out = prerequisites[i][0]; int in = prerequisites[i][1]; indegree[out]++; outdegreeNode[in].push_back(out); } queue\u0026lt;int\u0026gt; que; int count = numCourses; // node count for (int i = 0; i \u0026lt; numCourses; ++i) { if (indegree[i] == 0) { indegree[i] = -1; que.push(i); --count; } } while (!que.empty() \u0026amp;\u0026amp; count != 0) { int front = que.front(); que.pop(); for (int item : outdegreeNode[front]) { if (indegree[item] \u0026gt; 0) { --indegree[item]; if (indegree[item] == 0) { indegree[item] = -1; que.push(item); --count; } } } } return count == 0; } }; 2.3.2 210. 课程表 II 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 bool canFinish(int numCourses, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; prerequisites) { vector\u0026lt;int\u0026gt; indegree(numCourses, 0); unordered_map\u0026lt;int, vector\u0026lt;int\u0026gt;\u0026gt; outdegreeNode; // init indegree and outdegreeNode for (int i = 0; i \u0026lt; prerequisites.size(); ++i) { int out = prerequisites[i][0]; int in = prerequisites[i][1]; indegree[out]++; outdegreeNode[in].push_back(out); } queue\u0026lt;int\u0026gt; que; int count = numCourses; // node count for (int i = 0; i \u0026lt; numCourses; ++i) { if (indegree[i] == 0) { indegree[i] = -1; que.push(i); --count; } } while (!que.empty() \u0026amp;\u0026amp; count \u0026gt;= 0) { int front = que.front(); que.pop(); for (int item : outdegreeNode[front]) { if (indegree[item] \u0026gt; 0) { --indegree[item]; if (indegree[item] == 0) { indegree[item] = -1; que.push(item); --count; } } } } if (count == 0) { return res; } return {}; } 2.3.3 2050. 并行课程 III 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 int minimumTime(int n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; relations, vector\u0026lt;int\u0026gt;\u0026amp; time) { vector\u0026lt;int\u0026gt; indegree(n+1, 0); vector\u0026lt;int\u0026gt; indegreeMaxTime(n+1, 0); // 记录每个结点的入度结点中的最大值 unordered_map\u0026lt;int, vector\u0026lt;int\u0026gt;\u0026gt; outdegreeNode; vector\u0026lt;int\u0026gt; node_time(time.begin(), time.end()); // init indegree and outdegreeNode for (int i = 0; i \u0026lt; relations.size(); ++i) { int in = relations[i][0]; int out = relations[i][1]; indegree[out]++; indegreeMaxTime[out] = max(indegreeMaxTime[out], node_time[in-1]); outdegreeNode[in].push_back(out); } queue\u0026lt;int\u0026gt; que; for (int i = 1; i \u0026lt;= n; ++i) { if (indegree[i] == 0) { indegree[i] = -1; que.push(i); } } while (!que.empty()) { int front = que.front(); que.pop(); node_time[front-1] = indegreeMaxTime[front] + node_time[front-1]; for (int item : outdegreeNode[front]) { if (indegree[item] \u0026gt; 0) { --indegree[item]; indegreeMaxTime[item] = max(indegreeMaxTime[item], node_time[front-1]); if (indegree[item] == 0) { indegree[item] = -1; que.push(item); } } } } return *max_element(node_time.begin(), node_time.end()); } ","date":"2024-12-13T12:07:28+08:00","permalink":"https://alvincat.top/post/data_structure/graph/topological_sorting/","tags":["有向图","拓扑排序"],"title":"拓扑排序"},{"categories":["CPP"],"contents":"本文总结C++中容易混淆的概念。\n1 常见易混淆知识点 1.1 内存控制 1.1.1 malloc/free, new/delete的区别 malloc和free是C/C++语言的标准库函数,而new/delete是C++的运算符。它们都可以用于动态申请和释放内存。 new/delete运算符不仅可以申请/释放内存，还可以对申请的对象进行初始化和销毁操作。 C++既可以使用new/delete，也可以调用malloc/free。而C语言只能用malloc/free管理动态内存。 1.1.2 new/delete new/delete就是C++的运算符。new的全称为new operator, delete的全称为delete operator。其作用是为分配并初始化一个对象数组。\nC++执行new操作实际上后台执行了以下3步操作： 调用operate new或者operate new []的标准库函数。该函数分配一块原始的、足够大的、未命名的存储特定类型对象的空间； 编译器运行相应的构造函数以构造这些特定对象(或对象数组)； 对象被构造完成并分配的空间，返回一个指向该对象的指针。 C++执行delete操作实际上后台执行了以下2步操作：\n对所指向的对象或者对象数组执行对应的析构函数； 编译器调用operate delete(或者operate delete[])的标准库函数释放内存空间。 使用示例：\n1 2 3 4 5 int* p = new int; delete p; int* pa = new int[10]; delete [] pa; 1.1.3 operate new/delete operate new/delte是C++的标准函数。用于用于为特定类型的对象分配或者释放内存空间。operate new/delete的函数原型定义如下： 1 2 3 4 5 6 7 8 9 10 void* operate new(size_t); // 分配一个对象 void* operate new[](size_t); // 分配一个对象数组 void* operate delete(void*) noexpect; // 释放一个对象 void* operate delete[](void*) noexpect; // 释放一个对象数组 // 不会抛出异常的函数，功能同上 void* operate new(size_t, nothrow_t\u0026amp;) noexpect; void* operate new[](size_t, nothrow_t\u0026amp;) noexpect; void* operate delete(void*, nothrow_t\u0026amp;) noexpect; void* operate delete[](void*, nothrow_t\u0026amp;) noexpect; 如果应用程序希望自己控制内存的分配和释放，就需要自己定义operate new和operate delete函数，从而让编译器使用自定义的版本替换标准库中定义的版本。 应用程序可以在全局作用域中定义oprerate new/delete函数或者定义为类的成员函数。\n如果分配或者释放的的对象是类对象，则首先在类中查找是否有自定义的oprerate new/delete函数。若没查找到，再到全局作用域中查找。\n我们也可以直接指定查找全局作用域的函数：使用::new ::delete可以指定查找全局作用域的函数。 因为operate new用在构造函数之前而operate delete用在对象销毁之后，所以这两个成员函数必须是静态函数，而且不能操作类的任何数据成员。\n例外：不能重载以下形式的operate new函数：\n1 void* operate new(size_t, void*); 这种形式只供标准库使用，不能被用户重新定义。\n温馨提示：\n实际上C++也有和operate new/delete功能相似的标准库allocator类，用于为指定类型的对象分配内存。它非配的内存是原始、未构造的。\n1.1.4 placement new placement new用于对使用operate new的方式申请的内存上构造对象。placement new的几种形式：\n1 2 3 4 new (place_address) type new (place_address) type (initializers) new (place_address) type [size] new (place_address) type [size] {braced initializer list} 其中place_address必须是一个指针，同时在initializers中提供一个(可能为空)的逗号分隔的初始化列表，该初始值列表用于构造新分配的对象。\n1.1.5 智能指针 1.1.5.1 shared_ptr 1.1.5.2 unique_ptr 1.1.5.3 weak_ptr 1.2 指针与引用的区别 指针本身就是一个对象，其内容是某个内存单元的地址，允许对指针赋值和拷贝；而引用并非对象，它只是一个已经存在的对象的一个别名。 指针在它的生命周期内可以指向不同的对象；而引用一旦初始化完成，将和它的初始值始终绑定在一起。 指针无须在定义时赋初值；而引用必须初始化，绑定到一个已经存在的对象。指针可以为空，但引用不可以。 sizeof操作指针和引用的结果不同；sizeof操作引用得到的是引用所绑定的对象的大小；而sizeof操作指针得到的是指针本身的大小。 引用是类型安全的，而指针不是。 1.3 struct和class的区别 struct的成员(成员函数和数据成员)的访问控制属性默认是共有的；而class的成员默认是私有的。 struct的继承默认是共有继承，而class的默认继承方式是私有的。 1.4 const修饰常量与define的区别 const定义的常量在编译阶段进行处理；#define定义的常量在预处理阶段进行处理； const定义的常量要进行类型检查；#define定义的常量只是简单的文本替换，没有类型，不进行类型检查； const定义的常量要分配内存；#define定义的常量为宏定义，不需要分配内存； const定义的常量存放在数据区，只有一份拷贝；#define定义的常量不分配存储空间，使用过程中只是简单的执行文本替换； 1.5 重载覆盖隐藏的区别 1.5.1 重载 重载的特点：\n相同的范围（在同一个类中） 函数名字相同 参数不同 virtual 关键字可有可无 1.5.2 覆盖 覆盖是指派生类函数覆盖基类虚函数。其特征为：\n不同的范围（分别位于派生类与基类）； 函数名字相同 参数相同 基类函数必须有virtual 关键字 1.5.3 隐藏 “隐藏”是指派生类的函数屏蔽了与其同名的基类函数，规则如下：\n如果派生类的函数与基类的函数同名，但是参数不同。此时，不论有无virtual关键字，基类的函数将被隐藏（注意别与重载混淆）。 如果派生类的函数与基类的函数同名，并且参数也相同而且基类函数没有virtual 关键字。此时，基类的函数被隐藏（注意别与覆盖混淆） 1.5.4 覆盖隐藏的示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 class Base { public: virtual void fcn() { cout \u0026lt;\u0026lt; \u0026#34;This is Base fcn().\u0026#34; \u0026lt;\u0026lt; endl; } }; class FristDerived : public Base { public: // FristDerived继承Base中的虚函数fcn() // 形参与Base::fcn()中的不一致，隐藏基类的fcn() void fcn(int) { cout \u0026lt;\u0026lt; \u0026#34;This is FristDerived fcn().\u0026#34; \u0026lt;\u0026lt; endl; } // 新增一个虚函数，在Base中不存在 virtual void display() { cout \u0026lt;\u0026lt; \u0026#34;This is FristDerived display().\u0026#34; \u0026lt;\u0026lt; endl; } }; class SecondDerived : public FristDerived { public: // 隐藏FristDerived::fcn(int) void fcn(int a) { cout \u0026lt;\u0026lt; \u0026#34;This is SecondDerived fcn(\u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34;).\u0026#34; \u0026lt;\u0026lt; endl; } void fcn() { // 覆盖Base中的虚函数fcn() cout \u0026lt;\u0026lt; \u0026#34;This is SecondDerived fcn().\u0026#34; \u0026lt;\u0026lt; endl; } void display() { // 覆盖FristDerived中的虚函数display()函数 cout \u0026lt;\u0026lt; \u0026#34;This is SecondDerived display().\u0026#34; \u0026lt;\u0026lt; endl; } }; int main() { Base base_obj; FristDerived fd_obj; SecondDerived sd_obj; Base* bp1 = \u0026amp;base_obj; Base* bp2 = \u0026amp;fd_obj; Base* bp3 = \u0026amp;sd_obj; bp1-\u0026gt;fcn(); // Base::fcn() bp2-\u0026gt;fcn(); // Base::fcn() bp3-\u0026gt;fcn(); // SecondDerived::fcn() cout \u0026lt;\u0026lt; \u0026#34;----------\u0026#34; \u0026lt;\u0026lt; endl; FristDerived* fd = \u0026amp;fd_obj; SecondDerived* sd = \u0026amp;sd_obj; // bp2-\u0026gt;display(); // 错误，Base没有display()函数 fd-\u0026gt;display(); // FristDerived::display() sd-\u0026gt;display(); // SecondDerived::display() return 0; } ","date":"2024-12-13T12:06:32+08:00","permalink":"https://alvincat.top/post/cpp/cpp_interview_knowledge/","tags":[""],"title":"C++中一些易混淆的基础知识"},{"categories":["Linux"],"contents":"本文介绍进程打印堆栈的原理。\n1.1 涉及结构体 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 struct dl_phdr_info { ElfW(Addr) dlpi_addr; /* Base address of object */ const char *dlpi_name; /* (Null-terminated) name of object */ const ElfW(Phdr) *dlpi_phdr; /* Pointer to array of ELF program headers for this object */ ElfW(Half) dlpi_phnum; /* # of items in dlpi_phdr */ /* The following fields were added in glibc 2.4, after the first version of this structure was available. Check the size argument passed to the dl_iterate_phdr callback to determine whether or not each later member is available. */ unsigned long long dlpi_adds; /* Incremented when a new object may have been added */ unsigned long long dlpi_subs; /* Incremented when an object may have been removed */ size_t dlpi_tls_modid; /* If there is a PT_TLS segment, its module ID as used in TLS relocations, else zero */ void *dlpi_tls_data; /* The address of the calling thread\u0026#39;s instance of this module\u0026#39;s PT_TLS segment, if it has one and it has been allocated in the calling thread, otherwise a null pointer */ }; typedef struct { Elf32_Word p_type; /* Segment type */ Elf32_Off p_offset; /* Segment file offset */ Elf32_Addr p_vaddr; /* Segment virtual address */ Elf32_Addr p_paddr; /* Segment physical address */ Elf32_Word p_filesz; /* Segment size in file */ Elf32_Word p_memsz; /* Segment size in memory */ Elf32_Word p_flags; /* Segment flags */ Elf32_Word p_align; /* Segment alignment */ } Elf32_Phdr; typedef struct { Elf64_Word st_name; /* Symbol name */ unsigned char st_info; /* Symbol type and binding */ unsigned char st_other; /* Symbol visibility */ Elf64_Section st_shndx; /* Section index */ Elf64_Addr st_value; /* Symbol value */ Elf64_Xword st_size; /* Symbol size */ } Elf64_Sym; typedef struct { const char *dli_fname; /* Pathname of shared object that contains address */ void *dli_fbase; /* Base address at which shared object is loaded */ const char *dli_sname; /* Name of symbol whose definition overlaps addr */ void *dli_saddr; /* Exact address of symbol named in dli_sname */ } Dl_info; typedef struct { size_t dls_size; /* Size in bytes of the whole buffer */ unsigned int dls_cnt; /* Number of elements in \u0026#39;dls_serpath\u0026#39; */ Dl_serpath dls_serpath[1]; /* Actually longer, \u0026#39;dls_cnt\u0026#39; elements */ } Dl_serinfo; typedef struct { char *dls_name; /* Name of library search path directory */ unsigned int dls_flags; /* Indicates where this directory came from */ } Dl_serpath; struct link_map { ElfW(Addr) l_addr; /* Difference between the address in the ELF file and the address in memory */ char *l_name; /* Absolute pathname where object was found */ ElfW(Dyn) *l_ld; /* Dynamic section of the shared object */ struct link_map *l_next, *l_prev; /* Chain of loaded objects */ /* Plus additional fields private to the implementation */ }; 1.2 涉及接口 1 2 3 4 5 6 7 8 #include \u0026lt;dlfcn.h\u0026gt; int dl_iterate_phdr(int (*callback)(struct dl_phdr_info *info, size_t size, void *data), void *data); void *dlopen(const char *filename, int flags); void *dlsym(void *restrict handle, const char *restrict symbol); int dlclose(void *handle); int dladdr(const void *addr, Dl_info *info); int dlinfo(void *restrict handle, int request, void *restrict info); char *dlerror(void); ","date":"2024-12-12T16:48:23+08:00","permalink":"https://alvincat.top/post/linux/backtrace/","tags":["ELF","backtrace"],"title":"Linux系统中进程打印堆栈的原理"},{"categories":["Linux"],"contents":"本文介绍并发程序中经常遇到的几个经典问题以及解决方法。\n1 Thundering herd problem(惊群效应) 解决方法：\nEvent Multiplexing: Use event-driven programming models (e.g., select, poll, epoll in Linux) that allow a single thread or process to handle multiple events.\nLoad Distribution: Distribute the load more evenly among multiple processes or threads using techniques like load balancers. Load balancing involves distributing incoming requests across multiple servers to prevent any one server from becoming overwhelmed. By distributing the load across multiple servers, the likelihood of a thundering herd problem occurring can be reduced.\nSerialized Access: Implement locking mechanisms or use queueing to serialize access to the shared resource, ensuring that only one process or thread handles the event at a time. Queuing: Queuing involves placing incoming requests in a queue and processing them in a controlled and orderly manner. By queuing requests, the load on the resource can be controlled, and the likelihood of a thundering herd problem occurring can be minimized.\nRate Limiting: Introduce rate limits to control the frequency at which processes or threads are woken up. Throttling involves limiting the rate at which requests are processed. By limiting the rate at which requests are processed, the load on the resource can be controlled, and the likelihood of a thundering herd problem occurring can be minimized.\nConnection pooling: Connection pooling involves reusing existing connections to a resource rather than creating a new connection for each request. By reusing existing connections, the load on the resource can be reduced, and the likelihood of a thundering herd problem occurring can be minimized.\n2 lock problem 2.1 deadlock(死锁) 2.2 livelock(活锁) 活锁产生的背景是：若获取多个锁时，若无法获取全部的锁时，会释放已经持有的锁，防止死锁。\n下面考虑这种场景：\n线程1(t1)需要获取lock1和lock2才能工作。线程2(t2)也需要获取lock1和lock2才能工作。\nt1先拿到lock1,尝试去获取lock2；t2先拿到lock2,尝试获取lock1;如果t1获取lock1和t2获取到lock2是同时发生的，他们在尝试获取另外一个锁时都会失败，然后同时释放自己的锁后重新按照原流程进程尝试。这样就会导致两个线程一直重试而无法继续进行。\n活锁类似于生活中两个有礼貌的人让路的场景：两个人都很客气的让路给对方，但是两人同时移动到同一侧，又继续冲突，再移动回来又冲突，一直这样持续下去，那么就会发生活锁。\n2.3 Starvation(饿死) 2.3 Lock convoy 2.5 Pessimistic Concurrency Control(悲观锁) 悲观锁策略：认为修改读写数据是不安全的，需要在操作数据前加锁，操作完数据后再解锁。也就是传统意义上的加锁动作。\n2.6 Optimistic Concurrency Control(乐观锁) 乐观锁的策略：乐观锁在更新数据前先获暂存数据，然后执行修改数据的操作。\n在将数据写回时，确认数据是否被修改，若数据被修改，就放弃更新的动作。\n乐观锁，一般用在数据冲突比较小的场景。\n2.7 False Sharing(伪共享) 2.4 Non-blocking algorithm 2.4.1 ring buffer FIFO a single-reader single-writer\n2.4.2 disruptor 2.4.2.1 disruptor 的原理介绍 How the Disruptor works and how to use it\ndisruptor的原理中文翻译\n2.4.2.2 disruptor的ringbuffer结构 内部结构为数组实现的环状队列，大小一般设置为$2^n$个，这样可以通过使用\u0026amp;运算替代%运算，加快计算速度。例如对于有8($2^3$)个数据的环状队列。 只需要将数字编号n\u0026amp;7(8-1)即可得访问对应的内容。 其中的数据的编号从0开始，不断增长。随着你不停地填充这个buffer（可能也会有相应的读取），这个序号会一直增长，直到绕过这个环。 2.4.2.3 从ring Buffer中读数据的原理 假设Ring Buffer中已经写入了一些数据，如下图所示，怎样从Ring Buffer读出这些数据呢？ 这里增加几个基本概念：\n消费者(Consumer)：消费者(Consumer)是一个想从Ring Buffer里读取数据的线程。就像Ring Buffer需要一个序号才能找到下一个可用节点一样，消费者也需要知道它将要处理的序号——每个消费者都需要找到下一个它要访问的序号。　ConsumerBarrier对象： ConsumerBarrier是消费者和Ring Buffer沟通的桥梁，用于两者之间的通信。 这个对象由RingBuffer创建并且代表消费者与RingBuffer进行交互。\n消费者可以调用ConsumerBarrier对象的waitFor()方法，传递它所需要的下一个序号.\n1 final long availableSeq = consumerBarrier.waitFor(nextSequence); 在上面的例子中，消费者处理完了Ring Buffer里序号8之前（包括8）的所有数据，那么它期待访问的下一个序号是9。 但是ConsumerBarrier从RingBuffer获取到的最大可访问序号是12。如下图所示： 注意：\n对于这个环状队列，其中的编号要经过对环的大小取余，才是其实际的编号。\n针对该示例，RingBuffer返回的最大可访问序列号是12（实际对应的数组编号是2），而消费者期望访问的编号是9。 所以消费者需要等待数据填充到9以及已有的区域时才可以访问。（实际分析问题是，可以认为只能按照顺时针去访问数据，不能逆时针访问。）\nConsumerBarrier有一个WaitStrategy方法来决定它如何等待这个序号\n接下来怎么做？\n接下来消费者会一直原地停留，等待更多数据被写入Ring Buffer。并且一旦数据写入后消费者会收到通知——节点9，10，11和12 已写入。现在序号12到了，消费者可以让ConsumerBarrier去拿这些序号节点里的数据了。如下图所示：\n2.4.2.4 向ringbuffer中写数据的原理","date":"2024-12-11T16:11:22+08:00","permalink":"https://alvincat.top/post/linux/linux_some_typical_problem/","tags":[""],"title":"并发编程中常见的问题"},{"categories":["数据结构"],"contents":"本文描述如何使用C语言实现一个队列的功能，展示如何使用数组、链表结构实现队列的方法。\n1 队列的基本功能 队列的基本功能包括：创建队列、销毁队列、判断队列是否为空、进队列、出队列、获取队列中的元素个数、获取队列头部元素、获取队列尾部元素。\n2 使用单链表实现队列 实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 struct Node { int val; struct Node* next; }; typedef struct Node Node; typedef struct { Node* head; Node* tail; int size; } myQueue; myQueue* initQueue(void) { // init head Node* node = (Node*)malloc(sizeof(Node)); if (!node) { printf(\u0026#34;Init que head node failed, not mem.\\n\u0026#34;); return NULL; } node-\u0026gt;val = -1; node-\u0026gt;next = NULL; // init queue myQueue* queue = (myQueue*)malloc(sizeof(myQueue)); if (!queue) { printf(\u0026#34;Init que failed, not mem.\\n\u0026#34;); return NULL; } queue-\u0026gt;head = node; queue-\u0026gt;tail = node; queue-\u0026gt;size = 0; return queue; } void destroyLinklist(Node* head) { while (head) { Node* next = head-\u0026gt;next; free(head); head = next; } } void destroyQueue(myQueue* que) { if (que) { destroyLinklist(que-\u0026gt;head); que-\u0026gt;size = 0; free(que); } } int isQueueEmpty(myQueue* que) { return que-\u0026gt;size == 0; } int getQueueSize(myQueue* que) { return que-\u0026gt;size; } void pushQueue(myQueue* que, int value) { Node* node = (Node*)malloc(sizeof(Node)); if (!node) { return; } node-\u0026gt;val = value; node-\u0026gt;next = NULL; que-\u0026gt;tail-\u0026gt;next = node; que-\u0026gt;tail = node; ++(que-\u0026gt;size); } void popQueue(myQueue* que) { if (isQueueEmpty(que)) { return; } Node* cur = que-\u0026gt;head-\u0026gt;next; que-\u0026gt;head-\u0026gt;next = cur-\u0026gt;next; if (que-\u0026gt;tail == cur) { que-\u0026gt;tail = que-\u0026gt;head; } free(cur); --(que-\u0026gt;size); } int getQueueFront(myQueue* que) { if (isQueueEmpty(que)) { return -1; } return que-\u0026gt;head-\u0026gt;next-\u0026gt;val; } int getQueueTail(myQueue* que) { if (isQueueEmpty(que)) { return -1; } return que-\u0026gt;tail-\u0026gt;val; } void printQueue(myQueue* que) { Node* head = que-\u0026gt;head-\u0026gt;next; printf(\u0026#34;que:\u0026#34;); while (head != que-\u0026gt;tail) { printf(\u0026#34;[%d|-]-\u0026gt;\u0026#34;, head-\u0026gt;val); head = head-\u0026gt;next; } printf(\u0026#34;[%d|^].\\n\u0026#34;, que-\u0026gt;tail-\u0026gt;val); } void reverseQueue(myQueue* que) { if (isQueueEmpty(que)) { return; } Node* front = que-\u0026gt;head-\u0026gt;next; if (front != que-\u0026gt;tail) { que-\u0026gt;head-\u0026gt;next = front-\u0026gt;next; front-\u0026gt;next = NULL; que-\u0026gt;tail-\u0026gt;next = front; que-\u0026gt;tail = front; } } 3 使用数组实现队列(环形队列) 实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 #define QUE_LEN 100 typedef struct { int arr[QUE_LEN]; int front; int tail; int size; int capacity; } myQueue; myQueue* initQueue(void) { // init queue myQueue* queue = (myQueue*)malloc(sizeof(myQueue)); if (!queue) { printf(\u0026#34;Init que failed, not mem.\\n\u0026#34;); return NULL; } queue-\u0026gt;front = 0; queue-\u0026gt;tail = 0; queue-\u0026gt;size = 0; queue-\u0026gt;capacity = QUE_LEN; return queue; } void destroyQueue(myQueue* que) { if (que) { que-\u0026gt;size = 0; free(que); } } int isQueueEmpty(myQueue* que) { return (que-\u0026gt;size == 0 \u0026amp;\u0026amp; que-\u0026gt;front == que-\u0026gt;tail); } int isQueueFull(myQueue* que) { return (que-\u0026gt;size == que-\u0026gt;capacity \u0026amp;\u0026amp; que-\u0026gt;front == que-\u0026gt;tail); } int getQueueSize(myQueue* que) { return que-\u0026gt;size; } void pushQueue(myQueue* que, int value) { if (isQueueFull(que)) { return; } int capacity = que-\u0026gt;capacity; int tail = que-\u0026gt;tail; que-\u0026gt;arr[tail] = value; que-\u0026gt;tail = (tail + 1) % capacity; ++(que-\u0026gt;size); } void popQueue(myQueue* que) { if (isQueueEmpty(que)) { return; } int front = que-\u0026gt;front; que-\u0026gt;front = (front + 1) % que-\u0026gt;capacity; --(que-\u0026gt;size); } int getQueueFront(myQueue* que) { if (isQueueEmpty(que)) { return -1; } int front = que-\u0026gt;front; return que-\u0026gt;arr[front]; } int getQueueTail(myQueue* que) { if (isQueueEmpty(que)) { return -1; } int tail = (que-\u0026gt;tail + que-\u0026gt;capacity - 1) % que-\u0026gt;capacity; return que-\u0026gt;arr[tail]; } void printQueue(myQueue* que) { if (isQueueEmpty(que)) { printf(\u0026#34;que is empty().\\n\u0026#34;); return; } printf(\u0026#34;queue:\u0026#34;); for (int i = 0; i \u0026lt; que-\u0026gt;size; ++i) { int front = (que-\u0026gt;front + i) % que-\u0026gt;capacity; printf(\u0026#34;|%d\u0026#34;, que-\u0026gt;arr[front]); } printf(\u0026#34;|.\\n\u0026#34;); } void reverseQueue(myQueue* que) { if (isQueueEmpty(que)) { return; } if (isQueueFull(que)) { que-\u0026gt;front = (que-\u0026gt;front + 1) % que-\u0026gt;capacity; que-\u0026gt;tail = (que-\u0026gt;tail + 1)% que-\u0026gt;capacity; return; } int front = getQueueFront(que); popQueue(que); pushQueue(que, front); } ","date":"2024-12-10T10:39:32+08:00","permalink":"https://alvincat.top/post/data_structure/queue/implement_a_queue/","tags":["队列","环形队列"],"title":"C语言实现一个队列的功能"},{"categories":["数据结构"],"contents":"本文描述如何使用C语言实现一个栈的功能。\n1 栈的基本功能 栈的基本功能包括：创建栈、销毁栈、判断栈是否为空、进栈、出栈、获取栈中的元素个数、获取栈顶元素。\n2 使用数组实现一个固定大小的栈 实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 #define SIZE 101 typedef struct { int arr[SIZE]; int size; } myStack; myStack* stack_init(void) { myStack* stk = (myStack*)malloc(sizeof(myStack)); if (stk == NULL) { return NULL; } memset(stk, 0, sizeof(myStack)); return stk; } int stack_is_empty(myStack* stk) { return (stk-\u0026gt;size == 0); } int get_stack_size(myStack* stk) { return stk-\u0026gt;size(); } void push_stack(myStack* stk, int val) { int idx = stk-\u0026gt;size; stk-\u0026gt;arr[idx] = val; ++(stk-\u0026gt;size); } void pop_stack(myStack* stk) { if (stack_is_empty(stk)) { return; } --(stk-\u0026gt;size); } int get_stack_top(myStack* stk) { if (stack_is_empty) { return -1; } int idx = stk-\u0026gt;size; return stk-\u0026gt;arr[idx-1]; } void destroy_stack(myStack* stk) { if (stk) { stk-\u0026gt;size = 0; free(stk); stk = NULL; } } ","date":"2024-12-10T10:39:32+08:00","permalink":"https://alvincat.top/post/data_structure/stack/implement_a_stack/","tags":["栈"],"title":"C语言实现一个栈的功能"},{"categories":["算法"],"contents":"本文总结动态规划算法的原理和使用场景。\n1 动态规划问题的特征 具有最优子结构 子结构之间存在依赖关系。 是用来求解最优解的问题的，因此符合上面两条，然后存在最大(多/少)等字眼的，可以尝试用动态规划求解。 2 动态规划问题的求解步骤 定义子问题 写出状态转移方程 确定计算顺序(top-down/down-top)：大多数都是采用自底向上的方法。 ","date":"2024-12-08T16:05:29+08:00","permalink":"https://alvincat.top/post/algorithm/dynamic_programming/","tags":["动态规划"],"title":"动态规划"},{"categories":["Linux"],"contents":"本文介绍进程间同步的3种方法，分别是文件锁，信号量和互斥量。 并且介绍它们是如何实现进程间同步的。\n1.1 文件锁（记录锁） 文件锁，在APUE中称为记录锁（record locking)，是保证某一时刻只有一个进程修改文件中的一个指定区域的锁。\n1.1.1 fcntl() fcntl()函数原型：int fcntl(int fd, int cmd, struct flock* fllockptr)。\n对于函数fcntl()来说，记录锁是通过cmd来控制的。记录锁的对应的cmd有：F_GETLK，F_SETLK和F_SETLKW。\nflock结构体的定义如下：\n1 2 3 4 5 6 7 struct flock { short l_type; /* F_RDLCK, F_WRLCK, F_UNLCK */ short l_whence; /* SEEK_SET, SEEK_CUR, SEEK_END */ short l_start; /* offset in bytes, relative to l_whence */ short l_len; /* length, in byte, 0 means lock of EOF */ short l_pid; /* returned with F_GETLK */ } flock结构中各个成员的含义说明：\nl_type表示文件锁的类型：F_RDLCK表示共享读锁, F_WRLCK为独占写锁, F_UNLCK为解锁指定文件区域\nl_whence, l_start和lseek()中的whence、offset功能相同；\n1.1.2 文件锁的使用方法 对整个文件加锁的方法：将l_start和l_len都设置为0, l_whece设置为SEEK_SET。\n如果一个进程对一个文件区域已经加了锁，后续如果该进程再次对同一区域再次加锁。则新锁将替换已持有的锁。\n加读锁时，该文件描述符必须是读打开的。加写锁时，该描述符必须是写打开的。\nfcntl函数中，文件锁三种参数的的说明：\nF_GETLK：判断对flockptr指定的文件区域加锁是否可以会被阻塞。\nF_SETLK：尝试获取一把锁，若无法获取锁，则返回错误码EACCES，EAGAIN。\nF_SETLKW：这个命令是F_SETLK的阻塞版本（w表示wait)。锁所设置的文件区域已经加锁而我们又无法获取该锁时，那么当前进程会被阻塞。只有等请求的锁可用或者休眠被信号中断，该进程才会被唤醒。\n1.1.3 文件锁的继承和释放 文件锁和进程、文件关联。以下几种场景都会关闭文件锁。\n进程退出：当一个进程退出时，它所建立的锁全部关闭。 文件关闭：文件描述符关闭，则该文件关联的锁全部关闭。 由fork创建的子进程不继承父进程设置的锁。\n在执行exec后，新程序可以继承原执行程序的锁。但是，如果文件设置了(O_CLOEXEC)。\n1.2 信号量 信号量的使用方法见进程间通信文章中的相关内容。\n1.3 互斥量 使用互斥量在多个进程之间实现同步，需要做如下处理：\n多个进程之间需要使用共享内存。\n互斥量需要在共享内存中中初始化；\n互斥量的属性需要设置为PTHREAD_PROCESS_SHARED。\n进程间使用互斥量的示例如下：\n","date":"2024-12-07T17:59:12+08:00","permalink":"https://alvincat.top/post/linux/apue/process_synchronization/","tags":["APUE","进程同步"],"title":"进程同步的方法"},{"categories":["Linux"],"contents":"本文说明UNIX系统中常见的几种标准，以及它们之间的关系。\n1.1 ISO C ISO C是C语言的标准。 ISO C标准现在有ISO/IEC的C程序设计语言国际标准工作组开发和维护。\nISO C标准的目的是提供C程序的可移植性，使其能适合于大量不同的操作系统，而不仅仅是UNIX系统。\n1.2 POSIX POSIX最初是由IEEE指定的标准。该标准的目的是提升应用程序在各种UNIX系统环境之间的可移植性。POSIX标准经过不断演进，发展出很多后续版本。本书统称为POSIX.1。\n1.2.1 XSI POSIX中的XSI(X/Open System Interface)选项描述了POSXI.1中可选接口和定义，以及它们要实现的内容。\n1.3 SUS SUS(Single UNIX Specification)。可以认为POSIX是SUS的子集。它定义了一些附加接口用于扩展POSIX.1规范的功能。POSIX.1相当于SUS中的基本规范。\n1.4 专业术语 ANSI: American National Standards Institute BSD: Berkeley Softwar eDistribution CAE: Common Application Environment COSE: Common Open Software Environment IEC: International Electrotechnical Commission IEEE: Institute of Electrical and Electronics Engineers ISO: International Organization for Standardization OSF: Open Softwar eFoundation POSIX: Portable Operating System Interface SUS: Single UNIX Specification SVID: System V Interface Definition SVR4: UNIX System V Release 4 USL: UNIX System Laboratories XSI: X/Open System Interface ","date":"2024-12-07T17:41:42+08:00","permalink":"https://alvincat.top/post/linux/apue/unix_standardization/","tags":["APUE","UNIX标准"],"title":"UNIX标准说明"},{"categories":["算法"],"contents":"本文介绍贪心算法的原理和实际应用，以及解决贪心算法的常见思路。\n1.3 贪心算法的典型应用 1.3.1 找零钱问题 1.3.1 背包问题 1.3.1 0-1背包问题 1.3.2 完全背包问题 1.3.2 Dijkstra’s algorithm 1.3.3 Kruskal’s algorithm 1.3.4 Huffman coding 1.3.5 Prim’s Algorithm","date":"2024-12-06T09:48:43+08:00","permalink":"https://alvincat.top/post/algorithm/greedy_algorithm/","tags":["贪心算法"],"title":"贪心算法"},{"categories":["Linux"],"contents":"本文总结UNIX环境中一个进程是如何启动和终止的，如何向进程传递参数表和环境变量。\n还介绍了进程内部的存储空间布局方式。\n1.1 main函数 1.2 进程退出的方式 1.3 C程序的内存空间布局 UNIX系统中C程序的内存布局如下图所示:\n程序中各部分的内容说明如下：\n正文段(Text Segment): 该部分包含了CPU执行的机器指令。通常这个段的内容是可共享、在内存中频繁被执行的单副本程序。通常正文段是只读的，以防止被修改。 已初始化数据段(Initialized Data Segment): 它包含了程序中已明确初始化的变量。例如，明确初始化的全局变量。 未初始化数据段(Uninitialized Data segment): 通常称为bss(block started by symbol)段。在程序开始执行前，内核将此段中的变量数据初始化为0或者空指针。例如，未初始化的全局变量。 栈(stack): 存放函数中的临时变量，函数的参数以及函数返回地址等。 堆(heap): 动态分配的内存存放在堆区。堆区在未初始化数据段的上方。 只有正文段和已初始化的数据段是存放在磁盘中。\n通过size命令可以查看二进制各个区域占用的大小。例如查看bash二进制的各个区域大小：size /usr/bin/bash\n1.4 存储空间分配 1.5 共享库","date":"2024-12-05T22:37:40+08:00","permalink":"https://alvincat.top/post/linux/apue/process_environment/","tags":["APUE","存储空间布局","环境变量"],"title":"进程环境"},{"categories":["Linux"],"contents":"本文总结Linux环境中的信号相关知识以及和信号相关的接口的使用方法。\n1.1 信号的基本概念 信号是软中断的一种，是典型的异步事件处理机制之一。因为产生信号的时间时随机出现的，没有任何规律。\n当某个信号出现时，可以告诉内核按照如下3种方式处理，称为信号处理：\n忽略信号\n大多数信号可以采用这种方式。但是SIGKILL(9)和SIGSTOP(19)这两个信号不能忽略。\n捕捉信号 为了捕捉信号，需要通知内核在某种信号发生时，调用一个用户函数。在用户函数中，用户事先定制了该信号发生时要执行的操作。\n执行系统的默认动作\n操作系统为每种信号设置默认的操作。但是大多数信号的系统默认操作都是终止进程。\n1.2 异步信号安全函数(可重入) 不可重入函数的特征：\n使用了静态数据结构的函数 调用malloc()或free()的函数 标准IO函数 1.2.1 Linux系统异步信号安全函数 abort faccessat linkat select socketpair accept fchmod listen sem_post stat access fchmodat lseek send symlink aio_error fchown lstat sendmsg symlinkat aio_return fchownat mkdir sendto tcdrain aio_suspend fcntl mkdirat setgid tcflow alarm fdatasync mkfifo setpgid tcflush bind fexecve mkfifoat setsid tcgetattr cfgetispeed fork mknod setsockopt tcgetpgrp cfgetospeed fstat mknodat setuid tcsendbreak cfsetispeed fstatat open shutdown tcsetattr cfsetospeed fsync openat sigaction tcsetpgrp chdir ftruncate pause sigaddset time chmod futimens pipe sigdelset timer_getoverrun chown getegid poll sigemptyset timer_gettime clock_gettime geteuid posix_trace_event sigfillset timer_settime close getgid pselect sigismember times connect getgroups raise signal umask creat getpeername read sigpause uname dup getpgrp readlink sigpending unlink dup2 getpid readlinkat sigprocmask unlinkat execl getppid recv sigqueue utime execle getsockname recvfrom sigset utimensat execv getsockopt recvmsg sigsuspend utimes execve getuid rename sleep wait _Exit kill renameat sockatmark waitpid _exit link rmdir socket write 1.3 信号相关函数 1.4 自定义信号处理函数","date":"2024-12-05T21:58:39+08:00","permalink":"https://alvincat.top/post/linux/apue/signals/","tags":["APUE","信号"],"title":"信号"},{"categories":["Linux"],"contents":"本文总结内存映射相关接口的用法和注意事项。\n1.1 内存映射IO的实现方法 内存映射IO(memory-mapped I/O)将一个磁盘中的文件映射到内存的一个缓冲区中，从而可以通过操作内存中的缓冲区达到操作文件的目的。例如读取映射在内存中的缓冲区，就等同于读取对应的磁盘文件。\n1.1.1 内存映射IO的优缺点 优点：\n读写文件直接编程操作缓冲区，更加简单； 对于两个文件之间的读写操作而言，直接进行文件读写操作的话，read需要先将内核缓冲区中的内容读到应用缓冲区(read_buffer),然后write再将应用缓冲区(write_buffer)的数据拷贝到内核缓冲区。若使用内存映射IO，则直接将数据从内核的一个缓冲区拷贝到另外一个缓冲区即可,开销很小(开销来自于可能发生缺页中断)。 1.2 内存映射IO相关的接口 1.2.1 内存映射IO相关的函数声明 1 2 3 4 5 #include \u0026lt;sys/mman.h\u0026gt; void* mmap(void* addr, size_t length, int prot, int flag, int fd, off_t offset); int mprotect(void *addr, size_t len, int prot); int msync(void *addr, size_t length, int flags); int munmap(void *addr, size_t length); 1.2.2 mmap函数 mmap函数参数说明：\naddr参数用于指定映射内存区的起始地址。通常设置为NULL，表示由系统选择该映射区的首地址。 length参数用于指定要映射的内存区域的长度。length必须是虚拟内存页面的整数倍。 prot用于指定内存映射区域的保护方式： PROT_READ：映射区可读 PROT_WRITE：映射区可写 PROT_EXEC：映射区可执行 PROT_NONE：映射区不可访问 prot可以设置为PROT_NONE，也可以设置为PROT_READ,PROT_WRITE, PROT_EXEC一个或者多个组合按位或。 对指定内存映射区的保护不能超过被映射文件打开时的访问权限。例如文件是只读打开的，那么对映射内存区就不能指定PROT_WRITE属性。 当prot设置为PROT_NONE时：这块映射的缓冲区不可读写，读写时会触发SIGSEGV。 用于实现对特定区域的保护，例如可以检测内存越界。典型应用：pthread_attr_setguardsize/pthread_attr_getguardsize. prot的属性PROT_EXEC的作用是：将内存映射区域的内容当作CPU可以执行的的机器指令进行执行。 flag参数：用于设置映射区域的属性。\nMAP_SHARED：该属性表示共享当前映射的内存区。映射区域的更新对其它映射了同一文件区域的进程可见。更新映射区域就会更新对应的映射文件。 MAP_PRIVATE: 该属性表示创建一个私有的映射副本。映射区域的更新对其它映射了同一文件区域的进程不可见。更新映射区域也不会更新对应的映射文件。任何修改都只影响映射文件的副本，而不影响源文件。 必须指定MAP_SHARED或者MAP_PRIVATE其中的一个，但是不能同时指定。 fd参数：指定要被映射的文件描述符。注意，在进行文件映射之前，文件必须先打开。但是关闭文件描述符并不会解除映射区。\noffset参数：offset为被映射的文件中偏移，offset必须是虚拟内存页面的整数倍。虚拟内存页面的大小通过sysconf(_SC_PAGE_SIZE)获取。\n若offset或者length不是内存页面大小的整数倍，操作系统如何处理？例如文件长度96字节，系统页面大小4096字节，则系统会提供4096字节的内存映射区，其中4000字节会被设置为0。虽然可以在映射区中修改4000字节区域，但是修改不会影响到被映射的文件。 1.2.3 mprotect()函数 函数参数说明：\naddr必须是内存页面的整数倍。 mprotect()函数用于修改调用它的进程的访问指定页面中数据的访问权限。如果调用mprotect()函数的进程尝试违反设置的保护方式访问指定的内存区域，则操作系统会给进程返回一个SIGSEGV。利用这特性，我们可以用来定位踩内存问题。 可以通过mprotect()函数来修改内存映射区的保护属性。prot参数和mmap中的参数相同。 1.2.4 msync()函数 函数参数和功能说明：\naddr必须是内存页面的整数倍。 flags参数说明： MS_ASYNC: 函数执行更新操作后立刻返回。 MS_SYNC: 函数需要等待写操作完成才返回。函数必须指定M_ASYNC或M_SYNC中的一个。 MS_INVALIDATE: msync()函数的用途说明：\n如果是用MAP_SHARED标识进行的内存映射，当映射区更新后，修改并不会立刻写会到被映射文件中。而何时将修改的脏页写会磁盘取决于操作系统内核的策略。 脏页写回的策略是：只要某个页面有一个字节被修改，整个页面都会被写回。 如果内存映射区被修改，可以调用msync()函数将脏页下刷到被映射的文件中。 1.2.5 munmap()函数 函数功能说明： munmap()用于解除内存和文件的映射关系。\n相关特性说明：\n当进程退出时会自动解除内存映射。 关闭内存映射时的文件描述符并不能解除和文件的内存映射关系。 调用munmap()函数并不会将内存映射区的内容更新到被映射的文件呢中。 当内存映射区解除映射后，映射时设置为MAP_PRIVATE的内存区的修改会被丢弃。 1.2.6 映射区的一些特性 与映射区相关的信号\nSIGSEGV：信号SIGSEGV通常在进程访问到它不可用的内存区时产生。例如映射区被设置为只读时，进程若尝试修改这个映射区是就会触发SIGSEGV。或者试图访问设置了PROT_NONE的映射区域。\nSIGBUS：如果映射区的某部分在访问时不存在，会触发SIGBUS信号。\n子进程可以通过fork基础父进程的内存映射区。但是不能通过exec继承映射区。\n1.3 内存映射IO的使用示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;sys/mman.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #define COPYINCR (4*1024) int main(int argc, char** argv) { int fdin; int fdout; void* src; void* dst; size_t copysz; struct stat sbuf; off_t fsz = 0; if (argc != 3) { printf(\u0026#34;input argv invalid(%d).\\n\u0026#34;, argc); exit(1); } if ((fdin = open(argv[1], O_RDONLY)) \u0026lt; 0) { printf(\u0026#34;open file(%s) failed, errno(%d).\\n\u0026#34;, argv[1], errno); exit(1); } if (fstat(fdin, \u0026amp;sbuf) \u0026lt; 0) { printf(\u0026#34;get file(%s) stat failed, errno(%d).\\n\u0026#34;, argv[1], errno); exit(1); } if ((fdout = open(argv[2], O_CREAT | O_RDWR | O_TRUNC)) \u0026lt; 0) { printf(\u0026#34;open file(%s) failed, errno(%d).\\n\u0026#34;, argv[2], errno); exit(1); } if (ftruncate(fdout, sbuf.st_size) \u0026lt; 0) { printf(\u0026#34;change file(%s) size failed, errno(%d).\\n\u0026#34;, argv[2], errno); exit(1); } while (fsz \u0026lt; sbuf.st_size) { if (sbuf.st_size - fsz \u0026gt; COPYINCR) { copysz = COPYINCR; } else { copysz = sbuf.st_size - fsz; } src = mmap(NULL, copysz, PROT_READ, MAP_PRIVATE, fdin, fsz); if (src == MAP_FAILED) { printf(\u0026#34;mmap file(%s) offset(%ld)len(%ld) size failed, errno(%d).\\n\u0026#34;, argv[1], fsz, copysz, errno); exit(1); } dst = mmap(NULL, copysz, PROT_WRITE, MAP_SHARED, fdout, fsz); if (src == MAP_FAILED) { printf(\u0026#34;mmap file(%s) offset(%ld)len(%ld) size failed, errno(%d).\\n\u0026#34;, argv[2], fsz, copysz, errno); exit(1); } memcpy(dst, src, copysz); munmap(src, copysz); munmap(dst, copysz); fsz += copysz; } return 0; } ","date":"2024-12-05T11:39:06+08:00","permalink":"https://alvincat.top/post/linux/apue/memory_mapped_io/","tags":["APUE","内存映射"],"title":"内存映射IO"},{"categories":["Linux"],"contents":"本文总结进程间通信的方法和各种方法的差异，以及注意事项。\n1 Linux支持的进程间通信方式 IPC类型 进程关系 半双工管道(匿名) 主机内的进程 FIFO(命名管道) 主机内的进程 消息队列 主机内的进程 信号量 主机内的进程 共享内存 主机内的进程 socket(套接字) 主机内或者主机间的进程 2 管道 3 FIFO 4 消息队列 5 共享内存 共享内存和内存映射IO的不同之处在于，共享内存不需要关联文件，使用的是虚拟内存中的匿名段。\n体现在用法上，就是共享内存不需要关联文件，通过shm_open()创建一个共享内存(虚拟的文件)，所有的进程就可以使用mmap来进行共享了。\n5.1 XSI共享内存 XSI共享内存相关接口：\n1 2 3 4 5 6 7 8 9 10 11 12 #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;sys/ipc.h\u0026gt; #include \u0026lt;sys/shm.h\u0026gt; key_t ftok(const char *pathname, int proj_id); int shmget(key_t key, size_t size, int shmflg); // get or create a shared memory int shmctl(int shmid, int cmd, struct shmid_ds *buf); void *shmat(int shmid, const void *shmaddr, int shmflg); // attach shared memory int shmdt(const void *shmaddr); void *shmat(int shmid, const void *shmaddr, int shmflg); // detach shard memory int shmdt(const void *shmaddr); XSI共享内存的用法见APUE第三版的15.9节。\n5.2 POSIX共享内存 POSIX共享内存接口最早出现在Linux kernel 2.4和glibc 2.2版本。通过man 7 shm_overview可以查看详细说明。POSIX共享内存接口使用更方便，通用性更强。\nPOSIX共享内存相关接口：\n1 2 3 4 5 6 7 8 9 10 11 12 #include \u0026lt;sys/mman.h\u0026gt; int shm_open(const char *name, int oflag, mode_t mode); int shm_unlink(const char *name); void* mmap(void* addr, size_t length, int prot, int flag, int fd, off_t offset); int munmap(void *addr, size_t length); // Set the size of the shared memory object. (A newly created shared memory object has a length of zero.) int ftruncate(int fd, off_t length); // Close the file descriptor allocated by shm_open(3) when it is no longer needed. int close(int fd); 链接时需要增加链接选项-lrt。\nshm_open()：shm_open接口和open接口作用类似。只不过shm_open是为了创建一个用于共享内存的文件而已。因此shm_open()创建的文件描述符同样用close()关闭。\nname：为了具有更好的可移植性，最好将name命名为以/开头的字符串。除了开头的/外不包含其他字符串。而name的长度也要符合当前系统的文件名长度的要求。\noflag：为了确保创建一个新的共享内存，可以将oflag参数设置为O_CREAT | O_EXEL。这样当name已经存在时，就会返回错误，保证只有不存在才会创建。\nshm_unlink()：shm_unlink()删除shm_open创建的共享内存。\n而要实现不同的进程共同使用同一片共享内存，只需要其中约定某个进程创建一个共享内存，然后将该共享内存的名字提供出来。其他进程就可以使用mmap来使用这个共享内存了。\n6 信号量 6.1 XSI信号量 SUS提供的信号量机制，提供了相当全面的功能。但是和POSIX信号量相比，使用更加复杂，而且性能也不如POSIX信号量。\n因此linux环境中一般使用POSIX信号量。感兴趣的可以阅读APUE第三版15.8节了解它的使用细节。\nXSI 信号量相关接口：\n1 2 3 4 #include \u0026lt;sys/sem.h\u0026gt; int semget(key_t key, int nsems, int semflg); int semctl(int semid, int semnum, int cmd, ...); int semop(int semid, struct sembuf *sops, size_t nsops); 6.2 POSIX信号量 信号量相关接口：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;semaphore.h\u0026gt; typedef union { char __size[__SIZEOF_SEM_T]; long int __align; } sem_t; int sem_init(sem_t *sem, int pshared, unsigned int value); int sem_destroy(sem_t *sem); sem_t *sem_open(const char *name, int oflag); sem_t *sem_open(const char *name, int oflag, mode_t mode, unsigned int value); int sem_unlink(const char *name); int sem_close(sem_t *sem); int sem_wait(sem_t *sem); int sem_trywait(sem_t *sem); int sem_timedwait(sem_t *sem, const struct timespec *abs_timeout); int sem_post(sem_t *sem); int sem_getvalue(sem_t *sem, int *sval); // POSIX信号量有两种：匿名型号量和命名信号量。它们的除了创建和销毁方式不同，其它没什么区别。\n匿名信号量只存在于内存中，只有可以访问对应内存的进程才可以使用。这意味着只有同一个进程中的线程可以使用或者已经映射相同内存内容到它们的地址空间的不同进程中的线程。 命名信号量可以通过名字访问，因此知道它们的名字的进程都可以使用。 6.2.1 信号量通用接口 sem_wait()：该函数用来实现信号量的减1操作。也可以理解为申请1个资源。调用该函数时，若信号量为0就会被阻塞。直到成功将信号量减1或者被一个信号中断。\nsem_try_wait()：该函数功能和sem_wait相同，都是用来对信号减1的。但是该函数在遇到信号量为0时不会被阻塞，而是返回-1并且将errno设置为EAGAIN。\nsem_timedwait()：该函数也是用于对信号量进行减1操作的。不同之处在于，它可以设置一个超时时间，当遇到信号量为0时，等待一个指定时间后仍然未能对信号量减1，就返回-1并将errno设置为ETIMEDOUT。\nsem_post()：该函数用来实现信号量的加1操作。也可以理解为释放1个资源。在调用sem_post()时，存在被信号量阻塞的进程，那么被阻塞的线程会被唤醒。而且被sem_post()加1的信号量会再次被sem_wait()或者sem_timedwait()函数减1。\nsem_getvalue()：获取当前信号量的值。该函数的操作不是原子的，即该函数返回是这个值可能已经改变，若需要获取准确的值，需要自行保证获取value的原子性。\n6.2.2 匿名信号量 如果信号量只在某个进程内部使用，使用匿名信号量更方便。\nsem_init()：创建匿名信号量。\nsem：sem用于保存新创建的匿名信号量的地址，需要事先定义好。\n若只在进程内部使用，需要对使用该信号量的线程均可见。例如全局变量或者在堆内存中申请内存的变量。\n若需要在两个进程之间使用，则变量需要在两个进程共享内存区域中。\npshared：pshared参数用于指定当前信号量的共享方式。若只在进程内使用，则将值设置为0；若在进程间使用，将值设置为非0值，例如1。\nvalue：value用于设置信号量的初始值。\nsem_destroy()：销毁匿名信号量。调用sem_destroy()后，不能再使用任何带有sem的函数了。\n6.2.3 命名信号量 sem_open()：sem_open()可以用来创建一个新的命名信号量或者使用一个已经存在的命名信号量。\n创建一个新的信号量的方法：如果要确保创建一个新的信号量，可以将oflag设置为O_CREAT|O_EXCL。当指定name的信号量已经存在时，会返回sem_open失败。\n使用已经存在的信号量的方法：使用只包含name和flag参数的sem_open函数，而且oflag设置为0。\nname：name参数用于指定信号量的名字。为了增加可移植性，建议名字以/开头。而且除了开头的/外，不能有其他的/存在。信号量的名字有最大长度限制，其长度不应该超过_POSIX_NAME_MAX。\noflag：oflag用于控制创建信号量的行为，参见前面两条说明。\nmode：mode为创建的信号量的文件访问权限，同open()函数的mode。\nvalue：value为创建的信号量的初始值。\n返回值：sem_open()函数的返回值为sem_t类型的指针，作为只用这个变量对该信号量执行其他操作。\nsem_close()：sem_close()用于释放进程申请的所有和该命名信号量相关的资源。\n如果进程在退出前，没有主动关闭命名信号量，那么内核会自动关闭该进程打开所有信号量。\n命名信号量关闭后，不会影响信号量的值。进程退出后由内核自动关闭的信号量也是一样的。\nsem_unlink()：sem_unlink()删除命名信号量的名字。调用该函数后信号量的名字会被立刻删除。但是只有当所有的信号量的使用者均关闭了该信号量，信号量才会被销毁。\n6.2.3 二进制信号量 二值信号量和计数信号量的差异在于初始化和使用信号量。如果信号量的值只有0和1，那它就是二值信号量。\n当二值信号量为1时，表示它处于\u0026quot;解锁状态\u0026quot;；当信号量的值为\u0026quot;0\u0026quot;时，表示他处于”加锁“状态。\n7 sockek socket相关的内容比较多，单独作为一篇文章介绍。\n","date":"2024-12-05T11:37:06+08:00","permalink":"https://alvincat.top/post/linux/apue/interprocess_communication/","tags":["APUE","IPC","进程间通信"],"title":"进程间通信的方法"},{"categories":["Linux"],"contents":"本文总结多线程的特性和同步方法。\n多线程 多线程的复杂性来源：\nCPU任务可抢占 多核并发 线程让渡 1 线程数据 1.1 线程私有数据 线程有如下私有数据：\n线程ID，线程ID在进程内部唯一。 一组寄存器 栈 调度优先级和调度策略 信号屏蔽字 errno变量 线程私有数据 1.2 线程共享数据 一个进程中的所有信息对该进程中的所有线程都是共享的。包含如下信息：\n可执行程序的代码\n程序的全局变量\n堆内存\n栈\n文件描述符\n1 线程同步方法 原子操作相关的接口由GCC自身提供，使用时无需包含其他头文件。pthread相关接口由glibc提供，使用时需要包含pthread.h头文件。\n1.1 原子操作 原子操作主要用于对整数进行简单的取值、加减、交换操作。由GCC提供的原子操作：\nn++类 1 2 3 4 5 6 7 8 type __sync_fetch_and_add(type *ptr, type value, ...); // m+n type __sync_fetch_and_sub(type *ptr, type value, ...); // m-n type __sync_fetch_and_or(type *ptr, type value, ...); // m|n type __sync_fetch_and_and(type *ptr, type value, ...); // m\u0026amp;n type __sync_fetch_and_xor(type *ptr, type value, ...); // m^n type __sync_fetch_and_nand(type *ptr, type value, ...); // (~m)\u0026amp;n /* 对应的伪代码 */ { tmp = *ptr; *ptr op= value; return tmp; }{ tmp = *ptr; *ptr = (~tmp) \u0026amp; value; return tmp; } // nand ++n类 1 2 3 4 5 6 7 8 type __sync_add_and_fetch(type *ptr, type value, ...); // m+n type __sync_sub_and_fetch(type *ptr, type value, ...); // m-n type __sync_or_and_fetch(type *ptr, type value, ...); // m|n type __sync_and_and_fetch(type *ptr, type value, ...); // m\u0026amp;n type __sync_xor_and_fetch(type *ptr, type value, ...); // m^n type __sync_nand_and_fetch(type *ptr, type value, ...); // (~m)\u0026amp;n /* 对应的伪代码 */ { *ptr op= value; return *ptr; }{ *ptr = (~*ptr) \u0026amp; value; return *ptr; } // nand 3.CAS类\n1 2 3 4 bool __sync_bool_compare_and_swap (type *ptr, type oldval, type newval, ...); type __sync_val_compare_and_swap (type *ptr, type oldval, type newval, ...); /* 对应的伪代码 */ { if (*ptr == oldval) { *ptr = newval; return true; } else { return false; } }{ if (*ptr == oldval) { *ptr = newval; } return oldval; } 1.2 自旋锁(spinklock) 自旋锁使用场景：执行时间短的任务。\n等待自旋锁的过程中，不会让渡CPU资源，盲等。\n1.2.1 pthread自旋锁接口 1 2 3 4 5 6 #include \u0026lt;pthread.h\u0026gt; int pthread_spin_init(pthread_spinlock_t* lock, int pshared); // init spink lock int pthread_spin_destroy(pthread_spinlock_t* lock); // destroy spin lock int pthread_spin_lock(pthread_spinlock_t* lock); int pthread_spin_unlock(pthread_spinlock_t* lock); int pthread_spin_trylock(pthread_spinlock_t* lock); 1.2.2 pthread_spin_lock实现 以x86系统为例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 int pthread_spin_lock ( pthread_spinlock_t *lock) { asm (\u0026#34;\\n\u0026#34; \u0026#34;1:\\t\u0026#34; LOCK_PREFIX \u0026#34;decl %0\\n\\t\u0026#34; \u0026#34;jne 2f\\n\\t\u0026#34; \u0026#34;.subsection 1\\n\\t\u0026#34; \u0026#34;.align 16\\n\u0026#34; \u0026#34;2:\\trep; nop\\n\\t\u0026#34; \u0026#34;cmpl $0, %0\\n\\t\u0026#34; \u0026#34;jg 1b\\n\\t\u0026#34; \u0026#34;jmp 2b\\n\\t\u0026#34; \u0026#34;.previous\u0026#34; : \u0026#34;=m\u0026#34; (*lock) : \u0026#34;m\u0026#34; (*lock)); return 0; } 1.2.2 pthread_spin_unlock实现 1 2 3 4 5 6 7 8 9 10 11 12 13 .globl pthread_spin_unlock .type pthread_spin_unlock,@function .align 16 pthread_spin_unlock: movl 4(%esp), %eax movl $1, (%eax) xorl %eax, %eax ret .size pthread_spin_unlock,.-pthread_spin_unlock /* The implementation of pthread_spin_init is identical. */ .globl pthread_spin_init pthread_spin_init = pthread_spin_unlock 1.3 互斥量(mutex) 对互斥量进行加锁以后，任何其它试图再次对互斥量加锁的线程都会被阻塞，直到当前你线程释放该互斥锁。如果释放互斥锁时有一个以上的线程阻塞，那么所有阻塞在该互斥量上的线程都会变为可运行状态。但是只有第一个可运行状态的线程可以获取互斥锁而得以继续运行，其他线程仍然需要继续等待。\n1.3.1 pthread mutex接口 1 2 3 4 5 6 7 8 9 10 // pthread_mutex_t结构定义： // nptl\\sysdeps\\unix\\sysv\\linux\\x86_64\\bits\\pthreadtypes.h #include \u0026lt;pthread.h\u0026gt; int pthread_mutex_init(pthread_mutex_t* mutex, const pthread_mutexattr_t* attr); int pthread_mutex_destroy(pthread_mutex_t* mutex); int pthread_mutex_lock(pthread_mutex_t* mutex); int pthread_mutex_trylock(pthread_mutex_t* mutex); int phtread_mutex_unlock(pthread_mutex_t* mutex); 1.3.2 pthread_mutex结构 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // x86_64结构 typedef union { struct __pthread_mutex_s { int __lock; unsigned int __count; int __owner; unsigned int __nusers; int __kind; int __spins; __pthread_list_t __list; # define __PTHREAD_MUTEX_HAVE_PREV 1 } __data; char __size[__SIZEOF_PTHREAD_MUTEX_T]; long int __align; } pthread_mutex_t; 1.4 读写锁(rw_lock) 1.4.1 读写锁特性 读写锁可以有3种状态：读模式下加锁状态，写模式下加锁状态和不加锁状态。一次只有一个线程可以占有写模式的读写锁，但是多个线程可以同时占有读模式的读写锁。\n当读写锁是写加锁状态时，在这个锁被解锁前，所有试图对这个锁加锁的线程都会被阻塞。当读写锁在读加锁状态时，所有试图以读模式对它进行加锁的线程都可以的到访问权。但是任何希望以写模式对此锁进行加锁的线程都会阻塞，直到所有的线程释放它们的读锁为止。该模式为读锁优先模式，存在申请写锁的线程饥饿问题。\n优化方案：当读写锁处于读模式锁住的状态，而这时有一个线程试图以写模式获取锁时，读写锁通常会阻塞随后的读模式锁请求。这样可以避免读模式锁长期占用，写模式锁一直等待的问题。\n1.4.2 读写锁接口 1 2 3 4 5 6 7 8 #include \u0026lt;pthread.h\u0026gt; int pthread_rwlock_init(phread_rwlock_t* rwlock, pthread_rwlockattr_t* attr); //init int pthread_rwlock_destroy(pthread_rwlok_t* rwlock); // destroy int pthread_rwlock_rdlock(pthread_rwlock_t* rwlock); // set read lock int pthread_rwlock_wrlock(pthread_rwlock_t* rwlock); // set write lock int pthread_rwlock_unlock(pthread_rwlock_t* unlock); // unlock read/write lock 1.5 条件变量(condition variable) 1.5.1 条件变量相关接口 1 2 3 4 5 6 7 8 9 10 int pthread_cond_init(pthread_cond_t* cond, const pthread_condattr_t* attr); int pthread_cond_destroy(pthread_cond_t* cond); int pthread_cond_wait(pthread_cond_t* cond, pthread_mutex_t* mutex); int pthread_cond_timedwait(pthread_cond_t* cond, pthread_mutex_t* mutex, const struct timespec* tsptr); int pthread_cond_signal(pthread_cond_t* cond); int pthread_cond_broadcast(pthread_cond_t* cond); 1.5.2 条件变量实例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 1 #include \u0026lt;stdio.h\u0026gt; 2 #include \u0026lt;unistd.h\u0026gt; 3 #include \u0026lt;pthread.h\u0026gt; 4 #include \u0026lt;errno.h\u0026gt; 5 6 int done = 0; 7 pthread_mutex_t m_lock = PTHREAD_MUTEX_INITIALIZER; 8 pthread_cond_t c_lock = PTHREAD_COND_INITIALIZER; 9 10 void thread_join(void) 11 { 12 pthread_mutex_lock(\u0026amp;m_lock); 13 while (done == 0) { 14 pthread_cond_wait(\u0026amp;c_lock, \u0026amp;m_lock); 15 } 16 pthread_mutex_unlock(\u0026amp;m_lock); 17 } 18 19 void thread_exit(void) 20 { 21 pthread_mutex_lock(\u0026amp;m_lock); 22 done = 1; 23 printf(\u0026#34;thread end.\\n\u0026#34;); 24 pthread_cond_signal(\u0026amp;c_lock); 25 pthread_mutex_unlock(\u0026amp;m_lock); 26 } 28 void* t_func(void* arg) 29 { 30 printf(\u0026#34;thread is start.\\n\u0026#34;); 31 thread_exit(); 32 return NULL; 33 } 34 35 int main(void) 36 { 37 printf(\u0026#34;parent start.\\n\u0026#34;); 38 pthread_t tid; 39 int ret = pthread_create(\u0026amp;tid, NULL, t_func, NULL); 40 if (ret != 0) { 41 printf(\u0026#34;create pthread failed, errno(%d).\\n\u0026#34;, errno); 42 } 43 thread_join(); 44 45 printf(\u0026#34;parent end.\\n\u0026#34;); 46 return 0; 47 } 1.6 二进制信号量 二进制信号量也可以用来实现互斥。二进制信号量的作用类似于互斥锁。详细使用方法见进程通信文章中的信号量部分。\n2 死锁 2.1 死锁的产生 2.2 死锁检测 2.2 常见死锁 3 线程安全函数 如果一个函数在相同的时间点可以被多个线程安全的调用，则称该函数是线程安全的。\n如果一个函数对多个线程来说是可重入的，就说这个函数是线程安全的。\n最典型的场景是：使用了静态变量的函数就是线程不安全的函数。因为多个线程调用时，都可以修改该静态变量。\n解决方法是： 将静态变量替换为调用者传入，各个线程自己管理自己的变量。\n","date":"2024-12-05T11:29:06+08:00","permalink":"https://alvincat.top/post/linux/apue/thread_synchronization/","tags":["APUE","多线程","线程同步"],"title":"多线程的特性和同步方法"},{"categories":["算法"],"contents":"本文讲解回溯算法的原理和具体实现。\n1 回溯算法 1.1 回溯算法的原理 回溯算法是暴力搜索法中的一种。回溯法是一种可以找出所有（或一部分）解的一般性算法，尤其适用于约束满足问题。\n在实际实现时采用DFS搜索的方式进行遍历，然后再遍历过程中采用剪枝的策略去掉不满足条件的解。\n对于具体代码实现而言，实际上就是DFS的一种实际应用。 和DFS遍历二叉树不同之处在于，回溯中使用DFS需要有前进和回退的过程，这也是为啥叫做回溯的原因。 一般在回溯算法中，使用递归的方式来进行DFS。\n1.2 解决回溯问题思路 解决回溯问题时，一定要画出遍历路径的多叉树。搞清楚横向遍历的是什么，和纵向遍历的路径是啥？ 例如： 如下图所示，为leetcode 电话号码组合问题中\u0026quot;23\u0026quot;的遍历示意图。其中2对应字符串\u0026quot;abc\u0026quot;, 3对应字符串\u0026quot;def\u0026quot;。\n我们可以看到，横向展开的是每个字符串内的每个字母，纵向是展开的字符串\u0026quot;23\u0026quot;。\n而回溯的递归函数中的for循环内部实现，就是横向展开的体现。\n因此在这个问题中，需要先根据索引获取数字对应的字符串。\n而针对问题39-组合总和问题，可以按照下图所示的思路去分析解决：\n1.1.1 回溯代码的基本框架 1 2 3 4 5 6 7 8 9 10 path = [] def backtrack(path, 选择列表): if 满足结束条件: result.add(item) return for item in 选择列表: path.push(item) // 添加 backtrack(path, 选择列表) path.pop() // 删除 1.2 回溯算法的应用 1.2.1 排列组合问题 问题1: 全排列 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; permute(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int len = nums.size(); if (len == 0) { return res; } vector\u0026lt;int\u0026gt; path; vector\u0026lt;bool\u0026gt; used(len, false); dfs(nums, path, 0, used); return res; } void dfs(vector\u0026lt;int\u0026gt;\u0026amp; nums, vector\u0026lt;int\u0026gt; path, int depth, vector\u0026lt;bool\u0026gt;\u0026amp; used) { int len = nums.size(); if (len == depth) { res.push_back(path); return; } for (int i = 0; i \u0026lt; len; ++i) { if (!used[i]) { path.push_back(nums[i]); used[i] = 1; dfs(nums, path, depth + 1, used); used[i] = 0; path.pop_back(); } } } private: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res; }; 问题2：电话号码的字母组合 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public: vector\u0026lt;string\u0026gt; letterCombinations(string digits) { int len = digits.size(); if (len == 0) { return {}; } string path; backtrack(digits, 0, path); return res; } void backtrack(string digits, int index, string\u0026amp; path) { if (index == digits.size()) { res.push_back(path); return; } char ch = digits[index]; string str = num_map[ch - \u0026#39;0\u0026#39;]; for (int i = 0; i \u0026lt; str.size(); ++i) { path.push_back(str[i]); backtrack(digits, index + 1, path); path.pop_back(); } } private: string num_map[10] = {\u0026#34;\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;abc\u0026#34;, \u0026#34;def\u0026#34;, \u0026#34;ghi\u0026#34;, \u0026#34;jkl\u0026#34;, \u0026#34;mno\u0026#34;, \u0026#34;pqrs\u0026#34;, \u0026#34;tuv\u0026#34;, \u0026#34;wxyz\u0026#34;}; vector\u0026lt;string\u0026gt; res; }; 问题3：组合总和(39) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; combinationSum(vector\u0026lt;int\u0026gt;\u0026amp; candidates, int target) { int size = candidates.size(); if (candidates.size() == 0) { return {}; } sort(candidates.begin(), candidates.end()); vector\u0026lt;int\u0026gt; path; backtrack(candidates, 0, path, target); return res; } void backtrack(vector\u0026lt;int\u0026gt;\u0026amp; cand, int idx, vector\u0026lt;int\u0026gt;\u0026amp; path, int target) { if (target == 0) { res.push_back(path); return; } for (int i = idx; i \u0026lt; cand.size(); ++i) { if (target \u0026lt; cand[i]) { return; } path.push_back(cand[i]); backtrack(cand, i, path, target - cand[i]); path.pop_back(); } } private: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res; }; 1.2.2 N皇后问题 1.3 Leetcode相关题目 17 Letter Combinations of a Phone Number\n22 Generate Parentheses\n39 Combination Sum\n46 Permutations\n51 N-Queens\n52 N-Queens II\n77 Combinations\n78 Subsets\n89 Gray Code\n93 Restore IP Addresses\n111 Minimum Depth of Binary Tree\n112 Path Sum\n113 Path Sum II\n131 Palindrome Partitioning\n140 Word Break II\n","date":"2024-12-02T15:39:46+08:00","permalink":"https://alvincat.top/post/algorithm/backtracking_algorithm/","tags":["排序"],"title":"回溯算法"},{"categories":["算法"],"contents":"本文主要是讲解堆排序的原理和具体实现方法。\n1 堆排序 1.1 堆排序的原理 1.2 堆排序的应用：topk问题 堆排序：堆排序最典型的场景就是topK问题\n使用堆实现top-k问题的技巧：\n获取最大的K个元素，使用小顶堆(优先剔除较小的元素)。\n获取最小的K个元素，使用大顶堆(优先剔除较大的元素)。\nTopK 示例，来源【前 K 个高频元素(LCR060)】，实现原理：\n先使用K个元素构建一个小顶堆。 然后将堆顶元素从堆中删除，然后将新元素插入堆中。 重复这个过程，直到遍历完所有元素。 当遍历完所有元素以后，留在堆中的元素就是最大K个元素。（因为较小的元素都被剔除了。） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 static bool cmp(pair\u0026lt;int, int\u0026gt; left, pair\u0026lt;int, int\u0026gt; right) { return left.second \u0026gt; right.second; } vector\u0026lt;int\u0026gt; topKFrequent(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k) { unordered_map\u0026lt;int, int\u0026gt; num_cnt; for (auto\u0026amp; item : nums) { num_cnt[item]++; } // init priority_queue priority_queue\u0026lt;pair\u0026lt;int, int\u0026gt;, vector\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt;, decltype(\u0026amp;cmp)\u0026gt; little_heap(cmp); for (auto\u0026amp; [num, cnt] : num_cnt) { if (little_heap.size() \u0026lt; k) { little_heap.emplace(num, cnt); } else { if (little_heap.top().second \u0026lt; cnt) { little_heap.pop(); little_heap.emplace(num, cnt); } } } vector\u0026lt;int\u0026gt; res; while (!little_heap.empty()) { res.emplace_back(little_heap.top().first); little_heap.pop(); } reverse(res.begin(), res.end()); return res; } 1.3 大顶堆实现降序序列 使用优先级队列实现大顶堆,默认就是大顶堆。\n大顶堆也可以用来排序：大顶堆排序的结果为降序序列，\n堆出列时，先弹出顶部的元素，而顶部的元素最大，所以的得到序列就是降序的。\n1 2 3 4 5 6 7 8 9 vector\u0026lt;int\u0026gt; vec = {1,8,5,6,3,4,0,9,7,2}; std::priority_queue\u0026lt;int\u0026gt; pri_que; for (int val : vec) { pri_que.push(val); } // 或者自定义比较函数实现 std::vector\u0026lt;int\u0026gt; vec = {3, 1, 4, 1, 5}; std::priority_queue\u0026lt;int\u0026gt; big_heap(std::less\u0026lt;int\u0026gt;(), vec); 1.4 小顶堆实现升序序列 使用优先级队列实现小顶堆需要自定义比较函数。小顶堆的排序结果为升序序列。\n优先级队列中的比较函数的含义：顶部元素和尾部元素的比较结果。\n例如：小顶堆中比较函数是greater的原因是，只有顶部元素比尾部元素大，才需要交换。\n1 2 3 // 使用优先级队列实现小顶堆的方法 std::vector\u0026lt;int\u0026gt; vec = {3, 1, 4, 1, 5}; std::priority_queue\u0026lt;int\u0026gt; little_heap(vec, std::greater\u0026lt;int\u0026gt;()); ","date":"2024-12-02T15:38:46+08:00","permalink":"https://alvincat.top/post/algorithm/heap_sort/","tags":["堆排序","排序"],"title":"堆排序的原理与实现"},{"categories":["算法"],"contents":"本文主要针对各种排序算法之间的特性进行比较。\n1.2 排序总结 排序算法按照排序的种类、稳定性、时间复杂度和空间复杂度进行总结。\n名称 排序类型 排序方式 时间复杂度(平均) 时间复杂度(最好) 时间复杂度(最坏) 空间复杂度 稳定性 冒泡排序 比较 交换排序 $O(n^2)$ $O(n)$ $O(n^2)$ O(1) 稳定 快速排序 比较 交换排序 $O(nlogn)$ $O(nlogn)$ $O(n^2)$ $O(logn)$ 不稳定 插入排序 比较 插入排序 $O(n^2)$ $O(n)$ $O(n^2)$ $O(1)$ 稳定 希尔排序 比较 插入排序 $O(n^{4/3})$ $O(nlogn)$ $O(n^{3/2})$ $O(1)$ 不稳定 选择排序 比较 选择排序 $O(n^2)$ $O(n^2)$ $O(n^2)$ $O(1)$ 不稳定 堆排序 比较 选择排序 $O(nlogn)$ $O(nlogn)$ $O(nlogn)$ O(1) 不稳定 归并排序 比较 归并排序 $O(nlogn)$ $O(nlogn)$ $O(nlogn)$ $O(n)$ 稳定 计数排序 非比较 计数 $O(n+r)$ $O(n+r)$ $O(n+r)$ $O(n)$ 稳定 基数排序 非比较 - $O(n*\\frac{k}{d})$ $O(n)$ $O(n*\\frac{k}{d})$ $O(n+2^d)$ 稳定 桶排序 非比较 - $O(n+r)$ - $O(n+r)$ $O(n+r)$ 稳定 ","date":"2024-12-02T15:38:46+08:00","permalink":"https://alvincat.top/post/algorithm/sort_summary/","tags":["排序"],"title":"排序算法的比较"},{"categories":["cpp"],"contents":"C++中的STL用法总结\nC++中的STL用法总结 2 queue 3 priority_queue 优先队列（Priority Queue）是一种容器适配器，是在容器queue的基础上实现的。它能够在常数时间内查找最大（默认情况下）元素，插入和删除操作的时间复杂度为$O(logn)$。\n3.1 优先级队列常用成员函数 push(): top(): 获取队列顶部元素； pop(): 删除队列顶部元素； size(): 获取优先级队列中元素个数； empty():判断优先级队列是否为空。 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // 遍历优先级队列 template\u0026lt;typename T\u0026gt; void print_queue(T\u0026amp; q) { while(!q.empty()) { std::cout \u0026lt;\u0026lt; q.top() \u0026lt;\u0026lt; \u0026#34; \u0026#34;; q.pop(); } std::cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } std::priority_queue\u0026lt;int\u0026gt; q; for(int n : {1,8,5,6,3,4,0,9,7,2}) { q.push(n); } std::priority_queue\u0026lt;int, std::vector\u0026lt;int\u0026gt;, std::greater\u0026lt;int\u0026gt; \u0026gt; q2; for(int n : {1,8,5,6,3,4,0,9,7,2}) { q2.push(n); } 4 stack 4.1 常用成员函数 top(): accesses the top element\nempty(): checks whether the underlying container is empty\npush(): inserts element at the top\nemplace: constructs element in-place at the top\npop()：removes the top element\n5 deque 6 array 7 list 8 forward_list 9 map系列 9.1 map 9.1.1 map功能说明 C++中的容器map是存放key,value键-值对的数据结构。内部的key唯一且会按照比较函数进行排序。特性如下：\nkey唯一 内部数据有序 内存数据结构：红黑树（平衡二叉树） 迭代器按照key的升序顺序遍历数据 9.2 multimap 9.2.1 multimap功能说明 数据结构和map相同，区别在于内部的key可以重复。特性如下：\nkey可以重复 内部数据有序 内存数据结构：红黑树（平衡二叉树） 迭代器按照key的升序顺序遍历数据，对于相同的键，按照插入顺序排列； 9.3 unordered_map 9.3.1 unordered_map功能说明 C++中的容器map是存放key,value键-值对的数据结构。内部的key唯一，但是不会对键值对进行排序；特性如下：\nkey唯一 内部数据无序 内部数据结构：哈希表 9.3.2 unordered_map常用接口函数 9.3.2.1 迭代方法 1 2 3 4 5 6 7 8 9 10 // 方法1 std::unordered_map\u0026lt;int, std::string\u0026gt; mag = {{1, \u0026#34;foo\u0026#34;}, {3, \u0026#34;bar\u0026#34;}, {2, \u0026#34;baz\u0026#34;}}; for(auto iter = mag.begin(); iter != mag.end(); ++iter) { std::cout \u0026lt;\u0026lt; \u0026#34;fisrt:\u0026#34; \u0026lt;\u0026lt; item-\u0026gt;first \u0026lt;\u0026lt; \u0026#34;, second: \u0026#34; \u0026lt;\u0026lt; item-\u0026gt;second \u0026lt;\u0026lt; std::endl; } // 方法2 for(auto item : mag) { std::cout \u0026lt;\u0026lt; \u0026#34;fisrt:\u0026#34; \u0026lt;\u0026lt; item-\u0026gt;first \u0026lt;\u0026lt; \u0026#34;, second: \u0026#34; \u0026lt;\u0026lt; item-\u0026gt;second \u0026lt;\u0026lt; std::endl; } 9.3.2.1 查找元素：find() 1 2 3 4 5 6 7 8 9 10 11 // find() // insert() std::unordered_map\u0026lt;int,int\u0026gt; example; auto item = example.find(2); // Finds an element with key equivalent to 2 if(item != example.end()) { std::cout \u0026lt;\u0026lt; \u0026#34;Found element, fisrt:\u0026#34; \u0026lt;\u0026lt; item-\u0026gt;first \u0026lt;\u0026lt; \u0026#34;, second: \u0026#34; \u0026lt;\u0026lt; item-\u0026gt;second \u0026lt;\u0026lt; std::endl; item-\u0026gt;second++; } else { std::cout \u0026lt;\u0026lt; \u0026#34;Not found element!\u0026#34; \u0026lt;\u0026lt; std::endl; example[2] = 1; } 9.3.2.2 更新map 1 2 3 4 std::unordered_map\u0026lt;std::string, size_t\u0026gt; word_map; for (const auto \u0026amp;w : { \u0026#34;this\u0026#34;, \u0026#34;sentence\u0026#34;, \u0026#34;is\u0026#34;, \u0026#34;not\u0026#34;, \u0026#34;a\u0026#34;, \u0026#34;sentence\u0026#34;, \u0026#34;this\u0026#34;, \u0026#34;sentence\u0026#34;, \u0026#34;is\u0026#34;, \u0026#34;a\u0026#34;, \u0026#34;hoax\u0026#34;}) { ++word_map[w]; } 9.4 unordered_multimap 9.4.1 unordered_multimap功能说明 数据结构和unordered_map相同，区别在于内部的key可以重复。特性如下：\nkey不唯一，但每个键关联的值可以不同。 内部数据无序 内部数据结构：哈希表 10 set系列 在C++标准模板库（STL）中，set、multiset、unordered_set和unordered_multiset是四种常用的关联容器。\n10.1 set功能说明 C++中的set容器是一种关联容器，内部存储的是有序唯一的key。特性如下：\nkey唯一 内部数据有序 内部数据结构：红黑树（平衡二叉树） 10.2 multiset 10.2.1 multiset功能说明 C++中的multiset容器是一种关联容器，特性和set类似，唯一区别是可以存在重复的key。特性如下：\nkey不唯一 内部数据有序 内部数据结构：红黑树（平衡二叉树） 10.3 unordered_set 10.3.1 unordered_set功能说明 C++中的unordered_set容器是一种关联容器，内部存储的key唯一。特性如下：\nkey唯一 内部数据无序 内部数据结构：哈希表 10.3.2 unordered_set常用成员函数 empty()\nsize():\ninsert(): Inserts element(s) into the container, if the container doesn\u0026rsquo;t already contain an element with an equivalent key.\nemplace(): Inserts a new element into the container constructed in-place with the given args if there is no element with the key in the container.\nerase(): erases elements\nfind(): finds element with specific key\n10.4 unordered_multiset 10.4.1 unordered_multiset功能说明 C++中的unordered_multiset容器是一种关联容器，内部存储的key唯一。特性如下：\nkey不唯一 内部数据无序 内部数据结构：哈希表 ","date":"2024-12-02T15:29:46+08:00","permalink":"https://alvincat.top/post/cpp/stl/cpp_stl/","tags":["STL"],"title":"C++ STL用法总结"},{"categories":["CPP"],"contents":"本文主要是记录c++ string的常用成员函数。\n1 string的常用成员函数 1.1 string的构造方法 1 2 3 4 5 6 7 8 9 10 11 12 std::string s(\u0026#34;Exemplar\u0026#34;); std::string const other(\u0026#34;Exemplar\u0026#34;); std::string s(other); std::string const other(\u0026#34;Exemplary\u0026#34;); std::string s(other, 0, other.length()-1); std::string s(4, \u0026#39;a\u0026#39;); // \u0026#34;aaaa\u0026#34; char mutable_c_str[] = \u0026#34;another C-style string\u0026#34;; std::string s(std::begin(mutable_c_str)+8, std::end(mutable_c_str)-1); 1.2 获取字符串长度:size(), length() 1 2 3 std::string s(\u0026#34;Exemplar\u0026#34;); assert(8 == s.size()); assert(s.size() == s.length()); 1.3 字符串查找:find() 1 2 3 4 5 6 7 8 9 // find(): Finds the first substring equal to the given character sequence. // rfind(): Finds the last substring equal to the given character sequence. string src = \u0026#34;This is a test.\u0026#34; string::size_type index = src.find(\u0026#34;is\u0026#34;); if (index != string::npos) { cout \u0026lt;\u0026lt; \u0026#34;Found, index:\u0026#34; \u0026lt;\u0026lt; index \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;Not found.\u0026#34; \u0026lt;\u0026lt; endl; } 1.4 字符串连接 1.4.1 使用string::append() 示例：\n1 2 3 4 5 6 7 string str1(\u0026#34;foo\u0026#34;); string str2(\u0026#34; bar\u0026#34;); str1.append(str2); cout \u0026lt;\u0026lt; str1 \u0026lt;\u0026lt; endl; // print \u0026#34;foo bar\u0026#34; return 0; 1.4.2 使用连接运算符(+) 1 2 3 4 5 6 7 string str1(\u0026#34;foo\u0026#34;); string str2(\u0026#34; bar\u0026#34;); str1 = str1 + str2; cout \u0026lt;\u0026lt; str1 \u0026lt;\u0026lt; endl; // print \u0026#34;foo bar\u0026#34; return 0; 1.4.3 使用库函数：strcat() 1 2 3 4 5 6 7 string str1(\u0026#34;foo\u0026#34;); string str2(\u0026#34; bar\u0026#34;); strcat(str1, str2); cout \u0026lt;\u0026lt; str1 \u0026lt;\u0026lt; endl; // print \u0026#34;foo bar\u0026#34; return 0; 1.4.3 使用循环 1 2 3 4 5 6 7 8 string str1(\u0026#34;foo\u0026#34;); string str2(\u0026#34; bar\u0026#34;); for (auto i : str2) { str1 += i; } cout \u0026lt;\u0026lt; str1 \u0026lt;\u0026lt; endl; // print \u0026#34;foo bar\u0026#34; return 0; 1.5 C++ string与C字符串互转 1 2 3 4 5 6 7 8 9 10 //string转换为C字符串 string str = \u0026#34;abc\u0026#34;; char arr[100]; strncpy(arr, str.c_str(), str.size()); //c字符串转换为string char cStr[] = \u0026#34;hello\u0026#34;; string str(cStr); 1.6 分割字符串：substr() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 vector\u0026lt;string\u0026gt; SplitString(const string\u0026amp; sourceStr, const string\u0026amp; delimiter) { string tmp = sourceStr; vector\u0026lt;string\u0026gt; output; size_t pos = 0; string token; while ((pos = tmp.find(delimiter)) != string::npos) { token = tmp.substr(0, pos); cout \u0026lt;\u0026lt; token \u0026lt;\u0026lt; endl; output.push_back(token); tmp.erase(0, pos + delimiter.length()); } cout \u0026lt;\u0026lt; tmp \u0026lt;\u0026lt; endl; output.push_back(tmp); return output; } ","date":"2024-12-02T15:28:46+08:00","permalink":"https://alvincat.top/post/cpp/cpp_string/","tags":["string"],"title":"c++ string的常用方法"},{"categories":["cpp"],"contents":"C++中常用库函数\nC++中常用库函数 1 字符串处理 1.1 字符串查找: strstr 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; void find_str(char const* str, char const* substr) { char* pos = strstr(str, substr); if(pos) { printf(\u0026#34;found the string \u0026#39;%s\u0026#39; in \u0026#39;%s\u0026#39; at position: %ld\\n\u0026#34;, substr, str, pos - str); } else { printf(\u0026#34;the string \u0026#39;%s\u0026#39; was not found in \u0026#39;%s\u0026#39;\\n\u0026#34;, substr, str); } } int main(void) { char* str = \u0026#34;one two three\u0026#34;; find_str(str, \u0026#34;two\u0026#34;); find_str(str, \u0026#34;\u0026#34;); find_str(str, \u0026#34;nine\u0026#34;); find_str(str, \u0026#34;n\u0026#34;); return 0; } 2 algorithm库 2.1 排序 2.1.1 sort Sorts the elements in the range [first, last) in ascending order. The order of equal elements is not guaranteed to be preserved.\n说明：sort函数默认将数据按照升序排列。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 // template\u0026lt; class RandomIt \u0026gt; // void sort( RandomIt first, RandomIt last ); std::array\u0026lt;int, 10\u0026gt; s = {5, 7, 4, 2, 8, 6, 1, 9, 0, 3}; // sort using the default operator\u0026lt; std::sort(s.begin(), s.end()); // 自定义比较函数，实现降序排序 // sort using a custom function object struct { bool operator()(int a, int b) { return a \u0026lt; b; } } customLess; std::sort(s.begin(), s.end(), customLess); for (auto a : s) { std::cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } std::cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // sort using a lambda expression std::sort(s.begin(), s.end(), [](int a, int b) { return b \u0026lt; a; }); for (auto a : s) { std::cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } std::cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; 2.1.2 stable_sort() 说明：Sorts the elements in the range [first, last) in ascending order. The order of equal elements is guaranteed to be preserved.\n2.1.3 partial_sort() Rearranges elements such that the range [first, middle) contains the sorted middle - first smallest elements in the range [first, last).\nThe order of equal elements is not guaranteed to be preserved. The order of the remaining elements in the range [middle, last) is unspecified.\n1 2 3 4 5 6 std::array\u0026lt;int, 10\u0026gt; s{5, 7, 4, 2, 8, 6, 1, 9, 0, 3}; std::partial_sort(s.begin(), s.begin() + 3, s.end()); for (int a : s) { std::cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } 2.2 二分查找 2.2.1 binary_search() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // template\u0026lt; class ForwardIt, class T\u0026gt; // bool binary_search( ForwardIt first, ForwardIt last, const T\u0026amp; value ); (1) // template\u0026lt; class ForwardIt, class T, class Compare \u0026gt; // bool binary_search( ForwardIt first, ForwardIt last, const T\u0026amp; value, Compare comp ); (2) // 示例 std::vector\u0026lt;int\u0026gt; haystack {1, 3, 4, 5, 9}; std::vector\u0026lt;int\u0026gt; needles {1, 2, 3}; for (auto needle : needles) { std::cout \u0026lt;\u0026lt; \u0026#34;Searching for \u0026#34; \u0026lt;\u0026lt; needle \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; if (std::binary_search(haystack.begin(), haystack.end(), needle)) { std::cout \u0026lt;\u0026lt; \u0026#34;Found \u0026#34; \u0026lt;\u0026lt; needle \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } else { std::cout \u0026lt;\u0026lt; \u0026#34;no dice!\\n\u0026#34;; } } 2.2.2 lower_bound() 功能说明：Returns an iterator pointing to the first element in the range [first, last) that is not less than (i.e. greater or equal to) value.\n1 2 3 4 5 6 7 8 9 10 11 12 // template\u0026lt; class ForwardIt, class T \u0026gt; // ForwardIt lower_bound( ForwardIt first, ForwardIt last, const T\u0026amp; value ); // template\u0026lt; class ForwardIt, class T, class Compare \u0026gt; // ForwardIt lower_bound( ForwardIt first, ForwardIt last, const T\u0026amp; value, Compare comp ); std::vector\u0026lt;int\u0026gt; data = { 1, 1, 2, 3, 3, 3, 3, 4, 4, 4, 5, 5, 6 }; auto lower = std::lower_bound(data.begin(), data.end(), 4); auto upper = std::upper_bound(data.begin(), data.end(), 4); std::copy(lower, upper, std::ostream_iterator\u0026lt;int\u0026gt;(std::cout, \u0026#34; \u0026#34;)); // 4 4 4 2.2.3 upper_bound() Returns an iterator pointing to the first element in the range [first, last) that is greater than value.\n2.3 revert() 接口定义：\n1 template\u0026lt; class BidirIt \u0026gt; void reverse( BidirIt first, BidirIt last ); 示例：\n1 2 3 std::vector\u0026lt;int\u0026gt; v({1,2,3}); std::reverse(std::begin(v), std::end(v)); std::cout \u0026lt;\u0026lt; v[0] \u0026lt;\u0026lt; v[1] \u0026lt;\u0026lt; v[2] \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; 2.4 heap 2.4.1 make_heap() 接口定义：\n1 2 template\u0026lt; class RandomIt\u0026gt; void make_heap(RandomIt first, RandomIt last); template\u0026lt; class RandomIt, class Compare\u0026gt; void make_heap(RandomIt first, RandomIt last, Compare comp); 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 std::vector\u0026lt;int\u0026gt; v = {3, 1, 4, 1, 5, 9}; std::make_heap(v.begin(), v.end()); // heap: 9 4 5 1 1 3 std::cout \u0026lt;\u0026lt; \u0026#34;heap:\\t\u0026#34;; for (const auto \u0026amp;i : v) { std::cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } std::sort_heap(v.begin(), v.end()); // sorted: 1 1 3 4 5 9 std::cout \u0026lt;\u0026lt; \u0026#34;\\nsorted:\\t\u0026#34;; for (const auto \u0026amp;i : v) { std::cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } std::cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; 2.4.2 sort_heap() 接口定义：\n1 2 template\u0026lt; class RandomIt \u0026gt; void sort_heap( RandomIt first, RandomIt last); template\u0026lt; class RandomIt, class Compare \u0026gt; void sort_heap( RandomIt first, RandomIt last, Compare comp); 2.4.3 push_heap() 接口定义：\n1 2 3 4 template\u0026lt; class RandomIt \u0026gt; void push_heap( RandomIt first, RandomIt last ); template\u0026lt; class RandomIt, class Compare\u0026gt; void push_heap(RandomIt first, RandomIt last, Compare comp ); 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 std::vector\u0026lt;int\u0026gt; v { 3, 1, 4, 1, 5, 9 }; std::make_heap(v.begin(), v.end()); std::cout \u0026lt;\u0026lt; \u0026#34;v: \u0026#34;; // v: 9 5 4 1 1 3 for (auto i : v) std::cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39; \u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; v.push_back(6); std::cout \u0026lt;\u0026lt; \u0026#34;before push_heap: \u0026#34;; // before push_heap: 9 5 4 1 1 3 6 for (auto i : v) std::cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39; \u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::push_heap(v.begin(), v.end()); std::cout \u0026lt;\u0026lt; \u0026#34;after push_heap: \u0026#34;; // after push_heap: 9 5 6 1 1 3 4 for (auto i : v) std::cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39; \u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; 2.4.4 pop_heap() 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 std::vector\u0026lt;int\u0026gt; v { 3, 1, 4, 1, 5, 9 }; std::make_heap(v.begin(), v.end()); std::cout \u0026lt;\u0026lt; \u0026#34;v: \u0026#34;; // v: 9 5 4 1 1 3 for (auto i : v) std::cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39; \u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::pop_heap(v.begin(), v.end()); // moves the largest to the end std::cout \u0026lt;\u0026lt; \u0026#34;after pop_heap: \u0026#34;; // after pop_heap: 5 3 4 1 1 9 for (auto i : v) std::cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39; \u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; int largest = v.back(); v.pop_back(); // actually removes the largest element std::cout \u0026lt;\u0026lt; \u0026#34;largest element: \u0026#34; \u0026lt;\u0026lt; largest \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // largest element: 9 std::cout \u0026lt;\u0026lt; \u0026#34;heap without largest: \u0026#34;; // heap without largest: 5 3 4 1 1 for (auto i : v) std::cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39; \u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; ","date":"2024-12-02T15:26:46+08:00","permalink":"https://alvincat.top/post/cpp/cpp_common_function/","tags":[""],"title":"C++常用库函数的用法"},{"categories":["Tools"],"contents":"本文主要是一些针对程序员入门的一些资料。\n1 一些基础知识 The Missing Semester of Your CS Education\n2 新手如何提问 How-To-Ask-Questions-The-Smart-Way.\n中文版本：提问的智慧\n经典的关键字：\nSTFW\n如果你收到STFW（Search The Fucking Web）的回应，回答者认为你应该到他妈的网上搜索。那人多半也是对的，去搜索一下吧。（更温和一点的说法是 Google 是你的朋友！）\nRTFM\n有一个古老而神圣的传统：如果你收到RTFM（Read The Fucking Manual）的回应，回答者认为你应该去读他妈的手册。当然，基本上他是对的，你应该去读一读。\nRTFSC\nLinux的鼻祖Linus Torvalds在回答有人提出的Minix的一个问题时，所说的第一句话就是\u0026quot;Read The Fucking Source Code\u0026quot;，这就是RTFSC的来由。\n3 理解(讲解)复杂问题的方法 why: 为什么产生的？背景是啥？ what: 是什么？ 解决什么问题的？优缺点？ how: 怎么实现的？ 4 编程的一些经验 机器的结果一定是正确的。当代码结果不符合预期时，可能存在以下几种情况： 代码存在bug? 使用的库函数、系统调用等存在bug? 硬件(CPU/内存/磁盘)异常 总之，不论是什么情况，都是因为存在软件或者硬件异常导致结果不符合预期的。\n没有测试的代码都是不可靠的\n一切外部输入都是不可靠的\n编写代码一定要采用滚雪球的方式进行\n切记贪多求全，全部写完后再进行测试，问题隐藏的更深，更难被发现。 编写代码时，按照功能进行模块化。已经完成的模块都要进行接口测试。 测试阶段多使用assert(), 提前发现不符合预期的bug。 5 一些有用的学习编程资源 南京大学计算机基础实验\n蒋炎岩操作系统课程视频\n蒋炎岩操作系统课程配套课件和代码\n调试理论与实践 (Fault; Failure; Error; 调试一切) [南京大学2023操作系统-P8] (蒋炎岩)\nmusl-libc-精简易读的类glibc库，适合学习glibc内部实现细节\n6 经典的书籍 Computer Systems: A Programmer\u0026rsquo;s Perspective【深入理解计算机系统】(CSAPP) Operating Systems: Three Easy Pieces(OSTEP) Advanced Programming in the UNIX Environment (3rd Edition)【UNIX环境高级编程】 (APUE) TCP-IP Illustrated Volunme 1-The Protocols 7 实用工具 7.1 windows实用工具 本地文件搜索：everyting\n解压工具：7Zip\n剪贴板：ditto\n截图工具：Snipaste\n图片简单编辑工具：GreenShot\n远程连接客户端(开源免费的类Xshell工具)：WindTerm\n7.2 绘图工具 ProcessOn:在线绘图网站\nDrawio Graphviz：开源图形可视化软件\nXMind: 思维导图工具\nExcalidraw: 开源手绘画风绘图工具\nPlantUML：绘制UML的工具\nMatplotlib【配合python使用】 官网\n7.3 indent工具格式化代码 1 2 # indent工具格式化c/c++代码： indent -kr -i8 hello.c #将源代码格式化为内核编码风格 7.4 实用网站 c语言编程书籍推荐\nC++书籍推荐\n操作系统相关知识库\nArchWiki: Arch Linux documentation\n在线LaTeX编辑网站\n计算机自学指南：涵盖计算机相关的网站、书籍等，内容丰富\n开源编程书籍\n计算机相关书籍推荐\n","date":"2024-11-30T19:06:41+08:00","permalink":"https://alvincat.top/post/tools/some_usful_tips/","tags":[""],"title":"程序员入门必读"},{"categories":["Tools"],"contents":"本文介绍markdown的语法和一些实用技巧。\n1 Markdown语法 Markdown语法在线文档\n2 Markdown使用说明 2.1 使用emoji表情符的方法 若markdown支持emoji表情符，直接将对应的表情符添加在文本中即可显示。例如：\n今天天气很好!:sunny:\n显示的结果为：今天天气很好! \u0026#x2600;\u0026#xfe0f;\nemoji表情符在线查询: https://github.com/ikatyang/emoji-cheat-sheet/blob/master/README.md\n2.2 Markdown表格单元格中输入多行内容的方法 方法1：在需要换行的地方添加\u0026lt;br\u0026gt;即可。示例： 动物 猫\n狗\n兔 方法2：在markdown中使用html的表格,转换为html后即可支持显示表格。\nPerson 1\rPerson 2\rPerson 3\rEmil\rTobias\rLinus\r16\n17\n18\r14\r10\r2.3 markdown中设置图片大小的方法 直接使用html中设置图片大小的方法即可，这样转换为html就可以符合预期了。\n1 \u0026lt;img src=\u0026#34;/web_image/about/badminton.svg\u0026#34; width=\u0026#34;30\u0026#34;\u0026gt; ","date":"2024-11-30T10:48:47+08:00","permalink":"https://alvincat.top/post/tools/markdown_usful_tips/","tags":["Markdown"],"title":"Markdown使用技巧"},{"categories":["Tools"],"contents":"本文介绍gdb一些常用命令。\n1 GDB的一些实用的文档 gdb cheat sheet 100-gdb-tips GDB User Manual GDB online 2 gdbinit文件的简单配置方法 在当前用户目录下创建文件：touch ~/.gdbinit\n在~/.gdbinit文件中添加常用的gdb命令即可。常用的配置如下：\n1 2 3 4 directory /usr/src/glibc/glibc-2.27/ # 指定源码所在目录 layout src # 显示源码模式 set pagination off # 输出信息较多时不会暂停输出 set confirm off # gdb退出时不显示提示信息 3 GDB常用命令 3.1 界面配置 命令 功能 layout src 显示源代码 layout asm 显示汇编代码 layout regs 显示寄存器内容 layout split 显示源代码和汇编窗口 layout next 显示下一个layout layout prev 显示上一个layout tui enable 显示layout窗口 tui disable 退出layout窗口 Ctrl + x -\u0026gt; o 在多个窗口间切换 3.2 单步执行 命令 功能 next/n 单步执行，不进入函数内部 step/s 单步执行，是函数则进入函数内部 until line-number 执行到指定行号 where 显示当前行号和当前所在的函数 3.3 断点调试 命令 功能 break/b \u0026lt;where\u0026gt; 在函数入口设置断点 enable \u0026lt;breakpoint\u0026gt; 打开断点 disable \u0026lt;breakpoint\u0026gt; 关闭断点 delete \u0026lt;breakpoint\u0026gt; 删除断点 clear 删除所有断点 info breakpoints [n] 查看断点 break \u0026lt;where\u0026gt; if \u0026lt;condition\u0026gt; 设置条件断点 示例:\n1 2 # 条件断点：第10行中，若变量i等于101则停止。 b 10 if i==101 3.4 观察点 命令 功能 watch \u0026lt;where\u0026gt;/variable 设置观察点 enable \u0026lt;breakpoint\u0026gt; 打开断点 disable \u0026lt;breakpoint\u0026gt; 关闭断点 delete \u0026lt;breakpoint\u0026gt; 删除断点 info watchpoints [n] 查看观察点 watch \u0026lt;where\u0026gt; if \u0026lt;condition\u0026gt; 设置条件观察点 rwatch/rw variable 设置读观察点 awatch/aw variable 设置读写观察点 watch expr thread threadnum 设置指定线程上的观察点 3.5 断点/观察点位置 命令 功能 function_name 函数名 line_num 行号 filenaem:line_num 文件+行号 addr 地址 3.6 打印信息 命令 功能 print \u0026lt;what\u0026gt; 打印指定内容 print /x $rbp-0x8 将计算结果按照16进制输出 print /x ($ebp+8) 将ebp+8内存中的内容按照16进制输出 info proc mappings 打印内存映射信息 x/nfu 0xaddr Examine the contents of memory and specify formatting.\nn: number of display items to print\nf: specify the format for the output\nu: specify the size of the data unit (eg. byte, word, \u0026hellip;)\nExample: x/4dw var n：输出单元的个数。\nf：是输出格式。比如 x 是以16进制形式输出， o 是以8进制形式输出,等等。\nu：标明一个单元的长度。\nb 是一个Byte(8 bit)\nh 是两个Byte （halfword）\nw 是四个Byte （word）\ng 是八个Byte （giant word）。\n3.7 查看栈帧 命令 功能 backtrace/bt 打印栈帧 frame/f \u0026lt;frame#\u0026gt; 显示指定栈帧 info frame 显示当前栈帧的信息 info locals 显示当前帧的局部变量信息 3.8 调试线程 命令 功能 set scheduler-locking on 只允许一个线程运行 set follow-fork-mode child 调试子进程 set detach-on-fork off 调试父子进程 info threads 查看线程信息 thread \u0026lt;thread#\u0026gt; 切换调试线程 3.9 修改程序中的值 命令 功能 set var \u0026lt;variable_name\u0026gt;=\u0026lt;value\u0026gt; 修改变量的值 return \u0026lt;expression\u0026gt; 强制将当前函数按照指定值返回 3.10 汇编运行 命令 功能 info line number 显示指定位置的汇编代码 stepi/si 单步运行汇编指令 nexti/ni 单步运行汇编指令 disassemble 0xstart 0xend 反汇编指定地址的代码 info registers 显示当前寄存器的值 info registers rip 仅显示pc的值 info registers rbp rsp 仅显示rbp, rsp的值 3.11 GDB打印C++ STL中常见结构的内容的方法 3.11.1 通用方法 1 2 3 //vector\u0026lt;int\u0026gt; vec = {1, 2, 3, 4, 5}; print *(vec._M_impl._M_start)@vec.size() print *(vec._M_impl._M_start)@n //print first n element 3.11.2 使用gdb脚本进行打印 使用方法见文章：GDB打印STL中各种容器的内容的方法\n","date":"2024-11-29T16:31:59+08:00","permalink":"https://alvincat.top/post/tools/gdb_usful_tips/","tags":["GDB"],"title":"GDB常用命令和一些实用方法"},{"categories":["数据结构"],"contents":"本文介绍二叉树的构造方式。\n1 二叉树的构造方法 1.1 通过前序遍历和中序遍历序列构造二叉树 前提条件：\npreorder 和 inorder 均 无重复 元素 inorder 均出现在 preorder preorder 保证 为二叉树的前序遍历序列 inorder 保证 为二叉树的中序遍历序列 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Solution { public: TreeNode* buildTree(vector\u0026lt;int\u0026gt;\u0026amp; preorder, vector\u0026lt;int\u0026gt;\u0026amp; inorder) { init_map(inorder); int left = 0; int right = inorder.size() - 1; int mid = node_idx[preorder[0]]; int left_len = mid - left; int right_len = right - mid; TreeNode* root = new TreeNode(preorder[0]); root-\u0026gt;left = innerBuildTree(preorder, inorder, left, mid - 1, left + 1, left + left_len); root-\u0026gt;right = innerBuildTree(preorder, inorder, mid + 1, right, left + left_len + 1, right); return root; } private: unordered_map\u0026lt;int, int\u0026gt; node_idx; void init_map(vector\u0026lt;int\u0026gt;\u0026amp; inorder) { for (int i = 0; i \u0026lt; inorder.size(); ++i) { node_idx[inorder[i]] = i; } } TreeNode* innerBuildTree(vector\u0026lt;int\u0026gt;\u0026amp; preorder, vector\u0026lt;int\u0026gt;\u0026amp; inorder, int left, int right, int pre_left, int pre_right) { if (left \u0026gt; right || pre_left \u0026gt; pre_right) { return nullptr; } int mid = node_idx[preorder[pre_left]]; int left_len = mid - left; int right_len = right - mid; TreeNode* node = new TreeNode(inorder[mid]); node-\u0026gt;left = innerBuildTree(preorder, inorder, left, mid - 1, pre_left + 1, pre_left + left_len); node-\u0026gt;right = innerBuildTree(preorder, inorder, mid + 1, right, pre_left + left_len + 1, pre_right); return node; } }; ","date":"2024-11-28T10:30:58+08:00","permalink":"https://alvincat.top/post/data_structure/tree/binary_tree_create/","tags":["二叉树"],"title":"创建二叉树的方法"},{"categories":["数据结构"],"contents":"本文介绍二叉树的遍历方法和具体代码实现。\n1 二叉树的遍历方法 二叉树的遍历方法根据访问根结点的先后顺序分为先序、中序、后序遍历。\n下面1.1，1.2，1.3节将分别介绍各种遍历方式的递归实现和非递归实现方法。\n1.1 二叉树的先序遍历 二叉树先序遍历的过程为：遍历根结点，先序遍历左子树，先序遍历右子树。\n1.1.1 二叉树先序遍历的递归实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public: vector\u0026lt;int\u0026gt; preorderTraversal(TreeNode* root) { preorder(root); return res; } void preorder(TreeNode* root) { if (root == NULL) { return; } res.push_back(root-\u0026gt;val); preorder(root-\u0026gt;left); preorder(root-\u0026gt;right); } private: vector\u0026lt;int\u0026gt; res; }; 1.1.2 二叉树先序遍历的非递归实现 先序遍历的非递归实现方式采用DFS的遍历算法，使用栈来保存中间结果。\n方法1：传统方式，首先将根结点添加至栈中，然后循环添加根结点的左孩子结点。\n当左孩子为空时，弹出栈顶结点，并将栈顶的右孩子结点作为根结点重复进行该过程。\n因为是先序遍历，因此所有结点在进栈前进行访问。具体代码如下所示： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public: vector\u0026lt;int\u0026gt; preorderTraversal(TreeNode* root) { vector\u0026lt;int\u0026gt; res; if (root == NULL) { return res; } stack\u0026lt;TreeNode*\u0026gt; stk; TreeNode* top = root; while (!stk.empty() || top) { while (top) { res.push_back(top-\u0026gt;val); stk.push(top); top = top-\u0026gt;left; } top = stk.top(); stk.pop(); top = top-\u0026gt;right; } return res; } }; 方法2：因为栈的特性是后进先出。入栈和出栈的顺序相反，因此可以利用这一特性简化代码流程：\n具体方法为：在根结点出栈前进行访问，然后分别将其右孩子和左孩子进栈。循环进行，直到栈为空为止。\n这样就会在访问的时候先访问左孩子再访问右孩子。具体实现方式如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public: vector\u0026lt;int\u0026gt; preorderTraversal(TreeNode* root) { vector\u0026lt;int\u0026gt; res; if (root == NULL) { return res; } stack\u0026lt;TreeNode*\u0026gt; stk; stk.push(root); while (!stk.empty()) { TreeNode* top = stk.top(); res.push_back(top-\u0026gt;val); stk.pop(); if (top-\u0026gt;right) { stk.push(top-\u0026gt;right); } if (top-\u0026gt;left) { stk.push(top-\u0026gt;left); } } return res; } }; 1.2 二叉树的中序遍历 二叉树先序遍历的过程为：中序序遍历左子树，遍历根结点，中序遍历右子树。\n1.2.1 二叉树的中序遍历的递归实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public: vector\u0026lt;int\u0026gt; inorderTraversal(TreeNode* root) { vector\u0026lt;int\u0026gt; res; inorder(root, res); return res; } void inorder(TreeNode* root, vector\u0026lt;int\u0026gt;\u0026amp; res) { if (root == nullptr) { return; } if (root-\u0026gt;left != nullptr) { inorder(root-\u0026gt;left, res); } res.emplace_back(root-\u0026gt;val); if (root-\u0026gt;right != nullptr) { inorder(root-\u0026gt;right, res); } } }; 1.2.2 二叉树的中序遍历的非递归实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public: vector\u0026lt;int\u0026gt; inorderTraversal(TreeNode* root) { vector\u0026lt;int\u0026gt; res; if (root == NULL) { return res; } stack\u0026lt;TreeNode*\u0026gt; stk; TreeNode* top = root; while (!stk.empty() || top) { while (top) { stk.push(top); top = top-\u0026gt;left; } top = stk.top(); res.push_back(top-\u0026gt;val); stk.pop(); top = top-\u0026gt;right; } return res; } }; 1.3 二叉树的后序遍历 二叉树先序遍历的过程为：中序序遍历左子树，遍历根结点，中序遍历右子树。\n1.3.1 二叉树的后序遍历的递归实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public: vector\u0026lt;int\u0026gt; postorderTraversal(TreeNode* root) { vector\u0026lt;int\u0026gt; res; postorder(root, res); return res; } void postorder(TreeNode* root, vector\u0026lt;int\u0026gt;\u0026amp; vec) { if (root == nullptr) { return; } postorder(root-\u0026gt;left, vec); postorder(root-\u0026gt;right, vec); vec.push_back(root-\u0026gt;val); } }; 1.3.2 二叉树的后序遍历的非递归实现 方法1：传统方法+访问标记 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public: vector\u0026lt;int\u0026gt; postorderTraversal(TreeNode* root) { vector\u0026lt;int\u0026gt; res; if (root == nullptr) { return res; } stack\u0026lt;pair\u0026lt;TreeNode*, bool\u0026gt;\u0026gt; stk; TreeNode* top = root; while (!stk.empty() || top) { while (top) { auto new_node = std::make_pair(top, false); stk.push(new_node); top = top-\u0026gt;left; } pair\u0026lt;TreeNode*, bool\u0026gt; head = stk.top(); stk.pop(); TreeNode* node = head.first; int sign = head.second; if (sign == false) { head.second = true; stk.push(head); top = node-\u0026gt;right; } else { res.push_back(node-\u0026gt;val); top = nullptr; } } return res; } }; 方法2：使用两个栈\n该方法类似于先序遍历的非递归方式中的方法2。\n只是为了得到中-右-左的序列，因此是先让左孩子入栈，再让右孩子入栈。\n最终的得到的序列和目标序列顺序相反，在使用一个栈将顺序调整过来即可。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public: vector\u0026lt;int\u0026gt; postorderTraversal(TreeNode* root) { vector\u0026lt;int\u0026gt; res; if (root == nullptr) { return res; } stack\u0026lt;TreeNode*\u0026gt; stk; stack\u0026lt;TreeNode*\u0026gt; stk_sec; stk.push(root); while (!stk.empty()) { TreeNode* top = stk.top(); stk.pop(); stk_sec.push(top); if (top-\u0026gt;left) { stk.push(top-\u0026gt;left); } if (top-\u0026gt;right) { stk.push(top-\u0026gt;right); } } while (!stk_sec.empty()) { TreeNode* top = stk_sec.top(); res.push_back(top-\u0026gt;val); stk_sec.pop(); } return res; } }; 方法3：使用一个栈\n原理同方法2：但是是通过特殊的先序遍历(遍历的方式为中-右-左的方式)的方式得到中-右-左的序列。 然后将得到的序列翻转一下即可。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public: vector\u0026lt;int\u0026gt; postorderTraversal(TreeNode* root) { vector\u0026lt;int\u0026gt; res; if (root == nullptr) { return res; } stack\u0026lt;TreeNode*\u0026gt; stk; TreeNode* top = root; while (!stk.empty() || top) { while (top) { res.push_back(top-\u0026gt;val); stk.push(top); top = top-\u0026gt;right; } top = stk.top(); stk.pop(); top = top-\u0026gt;left; } reverse(res.begin(), res.end()); return res; } }; 1.4 二叉树的层次遍历 二叉树的层次遍历实际上是对二叉树的广度优先遍历。\n原理参考BFS原理的讲解。具体代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; levelOrder(TreeNode* root) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res; if (root == NULL) { return res; } queue\u0026lt;TreeNode*\u0026gt; que_level; que_level.push(root); while (!que_level.empty()) { int que_size = que_level.size(); vector\u0026lt;int\u0026gt; level_vec; for (int i = 0; i \u0026lt; que_size; ++i) { TreeNode* head = que_level.front(); if (head-\u0026gt;left) { que_level.push(head-\u0026gt;left); } if (head-\u0026gt;right) { que_level.push(head-\u0026gt;right); } level_vec.push_back(head-\u0026gt;val); que_level.pop(); } res.push_back(level_vec); level_vec.clear(); } return res; } }; 2 二叉树的遍历方法总结 二叉树的前序中序、后序遍历都属于深度优先遍历(DFS)，而层次遍历属于广度优先遍历(BFS)。\n深度优先遍历需要使用栈作为存储中间过程的数据结构，而广度优先遍历需要使用队列作为中间过程的数据结构。 通过1.1,1.2,1.3的递归实现和非递归实现，我们不难发现。\n三种递归遍历方式实现代码较为简洁，三种遍历的方式的差异在于访问根结点的时机。迭代是访问根结点的时机和对应的遍历方式对应。\n三种非递归方式的实现都有可以使用传统遍历框架，区别在于访问结点的差异：\n先序遍历：先访问结点，再放入栈； 中序遍历：先放入栈，出栈时再访问结点； 后序遍历：增加标记，结点进栈两次，第二次出栈时再访问结点； 先序遍历和后续遍历：可以通过栈后进先出的特性调整顺序，简化操作。\n","date":"2024-11-27T11:11:07+08:00","permalink":"https://alvincat.top/post/data_structure/tree/binary_tree_traverse/","tags":["二叉树"],"title":"二叉树的遍历"},{"categories":["算法"],"contents":"本文讲解DFS算法的核心思想和代码基本框架。\n1 DFS算法的核心思想 DFS的英文全称为(Depth-first search),称为深度优先搜索算法。 该算法是用于在树形结构中按照某种规则搜索结点的算法。\n该算法的核心思想是从起始点出发，沿着某一条路径一直向前搜索，直到没有路径后结束。然后再回到起点继续遍历还未遍历的结点，直到遍历完所有结点。\n","date":"2024-11-26T16:31:22+08:00","permalink":"https://alvincat.top/post/algorithm/dfs/","tags":["DFS"],"title":"遍历-DFS"},{"categories":["算法"],"contents":"本文讲解BFS算法的核心思想和代码基本框架。\n1 BFS算法的核心思想 BFS的英文全称为(Breadth-first search),称为广度优先搜索算法。 该算法是用于在树形结构中按照某种规则搜索结点的算法。 该算法的核心思想是从起始点出发，依次遍历完起始点周围的结点，不断重复该过程直至扩散至所有结点。\n2 BFS算法的代码框架 基于BFS的特点：代码实现时，采用队列来保存每一轮迭代的结果。\n首次将起始点或初始状态的结点插入队列。 在出队列时，将和该结点关联的结点进队。 操作结束的条件：队列为空。 温馨提示：\n若需要区分每层遍历的结果，可以通过记录队列中元素的个数来实现。\n1 2 3 4 5 6 7 8 9 10 queue.push(root); while (!queue.empty()) { int size = 0; for (int idx = 0; idx \u0026lt; size; ++i) { head = queue.front(); xxx;// 执行和队列头部相关的操作 queue.push(head-\u0026gt;child); queue.pop(); } } ","date":"2024-11-26T16:29:32+08:00","permalink":"https://alvincat.top/post/algorithm/bfs/","tags":["BFS"],"title":"遍历-BFS"},{"categories":["操作系统"],"contents":"本文总结Linux系统启动的详细流程以及启动流程涉及的基础知识。\n1 Linux系统的传统启动流程 主机上电，运行BIOS MBR 进入引导程序(GRUB） 运行kernel init 2 BIOS和UEFI BIOS(Basic Input Output System) UEFI(Unified Extensible Firmware Interface)\n3 MBR和GPT MBR(Master Boot Record), GPT (GUID Partition Table),\n4 引导程序简介 5 常见linux发布版本启动的差异(CentOS/Ubuntu)","date":"2024-11-20T20:56:16+08:00","permalink":"https://alvincat.top/post/operating_system/linux_kernel/kernel_boot_process/","tags":["kernel_boot_process"],"title":"Kernel_boot_process"},{"categories":["Linux"],"contents":"本文记录Linux系统常用的系统设置的方法。\n1 Linux系统配置coredump的方法 1.1 临时配置方法 设置ulimit中core大小限制 执行命令：ulimit -c unlimited\n配置coredump的生成路径 执行命令：echo \u0026quot;/path/core-%e-%p-%s-%t\u0026quot; \u0026gt; /proc/sys/kernel/core_pattern\n该配置方法，当系统重启后就会失效。\n1.2 永久配置方法 配置当前用户的corefile size大小 在配置文件中增加一行配置项，如下所示： 1 2 #\u0026lt;domain\u0026gt; \u0026lt;type\u0026gt; \u0026lt;item\u0026gt; \u0026lt;value\u0026gt; root hard core 100000 其中，对于item为core的配置项，value的单位为KB.\n然后再/etc/profile文件中增加配置： 1 2 # No core files by default ulimit -S -c unlimited \u0026gt; /dev/null 2\u0026gt;\u0026amp;1 然后再进程的启动脚本中添加如下命令： 1 echo \u0026#34;/path/core-%e-%p-%s-%t\u0026#34; \u0026gt; /proc/sys/kernel/core_pattern 参考文档：\nHow to enable core file dumps when an application crashes or segmentation faults\n2 修改Hostname 1 hostnamectl set-hostname new_host_name ","date":"2024-11-19T15:48:31+08:00","permalink":"https://alvincat.top/post/linux/linux_common_setting/","tags":["linux系统设置"],"title":"Linux系统常用的系统配置"},{"categories":["Tools"],"contents":"本文记录vim常用参数的配置方法已经常用命令。\n1.1 vim常用设置 1.1 增加vim配置文件的方法 新建~/.vimrc文件。\n1.2 vim 常用设置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 \u0026#34; Turn syntax highlighting on. syntax on \u0026#34; Add numbers to each line on the left-hand side. set number \u0026#34; Highlight cursor line underneath the cursor horizontally. set cursorline \u0026#34; Highlight cursor line underneath the cursor vertically. \u0026#34;set cursorcolumn \u0026#34; Set shift width to 4 spaces. set shiftwidth=4 \u0026#34; Set tab width to 4 columns. set tabstop=4 \u0026#34; Use space characters instead of tabs. set expandtab \u0026#34; Do not save backup files. set nobackup \u0026#34; Do not let cursor scroll below or above N number of lines when scrolling. set scrolloff=10 \u0026#34; Do not wrap lines. Allow long lines to extend as far as the line goes. set nowrap \u0026#34; While searching though a file incrementally highlight matching characters as you type. set incsearch \u0026#34; Ignore capital letters during search. \u0026#34;set ignorecase \u0026#34; Override the ignorecase option if searching for capital letters. \u0026#34; This will allow you to search specifically for capital letters. set smartcase \u0026#34; Show partial command you type in the last line of the screen. set showcmd \u0026#34; Show the mode you are on the last line. set showmode \u0026#34; Show matching words during a search. set showmatch \u0026#34; Use highlighting when doing a search. set hlsearch \u0026#34; Set the commands to save in history default number is 20. set history=1000 \u0026#34; set autoindent \u0026#34; Set c language auto indent set cindent 参考文档:\nVimrc Configuration Guide - How to Customize Your Vim Code Editor with Mappings, Vimscript, Status Line, and More\n2 vim常用命令 2.1 vim替换字符串命令 替换当前行\n命令：:s/foo/bar/g\n替换第 n 行开始到最后一行中字符串\n命令： n,$s/foo/bar/\n替换文件中所有行的字符串\n命令：:%s/foo/bar/g\n2.2 vim直接输入tab的方法 因为在vim配置文件中配置tab键转换为4个空格，因此在编写makefile时直接按tab间无法达到输入tab的目的。\n在编辑模式或者命令模式下(界面最下方有冒号)，先按快捷键ctrl+v，然后按tab键即可。\n2.2 vim中执行命令的方法 进入命令模式，输入!加在终端输入的命令即可。例如： :!./hello\t//执行hello\n","date":"2024-11-19T15:17:40+08:00","permalink":"https://alvincat.top/post/tools/vim_usful_setting/","tags":["vim"],"title":"Vim常用设置以及常用命令"},{"categories":["操作系统"],"contents":"本文记录Ubutun操作系统常用的系统配置的设置方法和常用命令的用法。\n1 ubuntu系统配置apt源的方法 备份/etc/apt/sources.list文件 mv /etc/apt/sources.list /etc/apt/sourses.list.backup\n新建/etc/apt/sources.list文件并添加以下内容\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #163源 deb http://mirrors.163.com/ubuntu/ bionic main restricted universe multiverse deb http://mirrors.163.com/ubuntu/ bionic-security main restricted universe multiverse deb http://mirrors.163.com/ubuntu/ bionic-updates main restricted universe multiverse deb http://mirrors.163.com/ubuntu/ bionic-proposed main restricted universe multiverse deb http://mirrors.163.com/ubuntu/ bionic-backports main restricted universe multiverse deb-src http://mirrors.163.com/ubuntu/ bionic main restricted universe multiverse deb-src http://mirrors.163.com/ubuntu/ bionic-security main restricted universe multiverse deb-src http://mirrors.163.com/ubuntu/ bionic-updates main restricted universe multiverse deb-src http://mirrors.163.com/ubuntu/ bionic-proposed main restricted universe multiverse deb-src http://mirrors.163.com/ubuntu/ bionic-backports main restricted universe multiverse #中科大源 deb https://mirrors.ustc.edu.cn/ubuntu/ bionic main restricted universe multiverse deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-security main restricted universe multiverse deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic main restricted universe multiverse deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-security main restricted universe multiverse deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse #阿里云源 deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse #清华源 deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse 2 apt常用命令 1 2 3 4 5 6 7 8 apt-get update # 更新源 apt-get install package # 安装包 apt-get remove package # 删除包 apt-get upgrade # 更新已安装的包 apt-cache search package # 查询软件包 apt list --installed # 查询系统已安装的软件包 3 Ubuntu设置root登陆的方法 使用安装系统时的高级用户解锁root用户 1 sudo passwd root 设置root用户密码： 1 sudo passwd -u root 切换到root用户，执行命令：su\n解除root用户登陆限制： 打开文件/etc/ssh/sshd_config, 找如下内容：\n1 2 3 4 5 #LoginGraceTime 2m #PermitRootLogin prohibit-password #StrictModes yes #MaxAuthTries 6 #MaxSessions 10 然后将配置修改为：\n1 2 3 4 5 LoginGraceTime 2m PermitRootLogin yes StrictModes yes MaxAuthTries 3 MaxSessions 10 然后重启ssh服务：systemctl restart ssh.service 4 制作deb包的方法 创建工作目录并执行以下命令： 1 2 # 假设创建的软件为：myProject mkdir myProject \u0026amp;\u0026amp; mkdir myProject/DEBIAN 拷贝文件至工作目录 将需要打包到deb包中的文件拷贝到工作目录中。\n若希望deb软件包安装后将二进制存在在指定目录下，需要在工作目录下提前创建好对应的目录，然后将文件拷贝到对应的目录下。\n例如，希望将test.sh安装在/usr/local/bin/目录下，按照如下步骤操作即可： 1 2 mkdir -p myProject/usr/local/bin/; cp /usr/local/bin/test.sh myProject/usr/local/bin/ 创建配置文件 在DEBIAN目录下创建配置文件control，这个配置文件包含了软件的很多关键信息，例如：软件名称、版本、维护者、架构和描述信息等。\n创建post-installation文件 除以上几步以外，还可以添加post-installation文件，该文件用于在软件安装完成后执行一系列收尾工作。\n要添加该文件，需要在DEBIAN目录下创建名称为postinst的文件，并且确保该文件可以执行。\n创建软件包 切换到在工作目录所在目录，然后执行命令创建软件包：dpkg-deb --build myProject 创建的软件包会保存在工作目录下。\n可以使用如下命令安装文件： dpkg -i myProject.deb\n","date":"2024-11-19T15:17:20+08:00","permalink":"https://alvincat.top/post/operating_system/ubuntu_setting/","tags":["ubuntu"],"title":"Ubuntu系统常用设置和命令"},{"categories":["数据结构"],"contents":"本文介绍LRU的原理和具体c代码实现。\nLRU的英文全称为Least Recently Used，即最近最少使用。该算法为cache淘汰算法，将最近最少使用的元素淘汰掉。具体代码是由hashTable和一个双向链表实现的。\n使用双向链表存放key-value，使用哈希表存储双向链表的结点地址，保证访问结点的复杂度为 $O(1)$。通常来讲，对数据的读写都算做对数据的访问。\n1 LRU的C代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;assert.h\u0026gt; /* define struct start */ #define FREE(ptr) \\ free(ptr); \\ ptr = NULL; typedef int KEY; typedef int VAL; typedef struct ForwardListNode { KEY key; VAL val; struct ForwardListNode* prev; struct ForwardListNode* next; } ForwardListNode; typedef struct HashNode { ForwardListNode* dNode; struct HashNode* next; } HashNode; typedef struct HashTable { HashNode** bucket; int (*destroy)(struct HashTable* tb); int (*hash)(struct HashTable* tb, KEY key); int (*insert)(struct HashTable* tb, HashNode* node); int (*remove)(struct HashTable* tb, KEY key); HashNode* (*find)(struct HashTable* tb, KEY key); int bucket_num; } HashTable; typedef struct { ForwardListNode* head; HashTable* ht; int capacity; int size; } LRUCache; /* ------------------------ */ /* LinkList function start */ int insertListNode(HashNode** head, HashNode* node) { if (*head == NULL) { *head = node; return 0; } node-\u0026gt;next = *head; *head = node; return 0; } int removeListNode(HashNode** head, HashNode* node) { if (*head == node) { *head = (*head)-\u0026gt;next; FREE(node); return 0; } HashNode* prev = *head; HashNode* cur = (*head)-\u0026gt;next; while (cur) { if (cur == node) { prev-\u0026gt;next = cur-\u0026gt;next; FREE(node); return 0; } prev = prev-\u0026gt;next; cur = cur-\u0026gt;next; } return -1; } HashNode* findListNode(HashNode* head, KEY key) { if (head == NULL) { return NULL; } while (head) { if (head-\u0026gt;dNode-\u0026gt;key == key) { return head; } head = head-\u0026gt;next; } return NULL; } void ListNodeDestroy(HashNode* head) { if (head == NULL) { return; } HashNode* cur = head; while (cur) { HashNode* prev = cur-\u0026gt;next; FREE(cur); cur = prev; } } /* ------------------------ */ /* HashTable function */ HashNode* initHashNode(ForwardListNode* node) { HashNode* hNode = (HashNode*)malloc(sizeof(HashNode)); if (hNode == NULL) { return NULL; } hNode-\u0026gt;dNode = node; hNode-\u0026gt;next = NULL; return hNode; } int hashFunc(HashTable* tb, KEY key) { return key % tb-\u0026gt;bucket_num; } HashNode* findHashNode(HashTable* tb, KEY key) { int index = tb-\u0026gt;hash(tb, key); assert(index \u0026gt;= 0 \u0026amp;\u0026amp; index \u0026lt; tb-\u0026gt;bucket_num); return findListNode(tb-\u0026gt;bucket[index], key); } int insertHashNode(HashTable* tb, HashNode* node) { int index = tb-\u0026gt;hash(tb, node-\u0026gt;dNode-\u0026gt;key); assert(index \u0026gt;= 0 \u0026amp;\u0026amp; index \u0026lt; tb-\u0026gt;bucket_num); return insertListNode(\u0026amp;tb-\u0026gt;bucket[index], node); } int removeHashNode(HashTable* tb, KEY key) { int index = tb-\u0026gt;hash(tb, key); assert(index \u0026gt;= 0 \u0026amp;\u0026amp; index \u0026lt; tb-\u0026gt;bucket_num); if (tb-\u0026gt;bucket[index] == NULL) { return -1; } HashNode** head = \u0026amp;tb-\u0026gt;bucket[index]; HashNode* node = findListNode(*head, key); return removeListNode(head, node); } HashTable* initHashTableMem(void) { HashTable* ht = (HashTable*)malloc(sizeof(HashTable)); if (ht == NULL) { return NULL; } memset(ht, 0, sizeof(HashTable)); return ht; } int destroyHashTable(struct HashTable* tb) { for (int i = 0; i \u0026lt; tb-\u0026gt;bucket_num; ++i) { HashNode* head = tb-\u0026gt;bucket[i]; if (head == NULL) { continue; } ListNodeDestroy(head); } FREE(tb-\u0026gt;bucket); FREE(tb); return 0; } int initializeHashTable(struct HashTable* tb, int num) { tb-\u0026gt;hash = hashFunc; tb-\u0026gt;insert = insertHashNode; tb-\u0026gt;remove = removeHashNode; tb-\u0026gt;find = findHashNode; tb-\u0026gt;destroy = destroyHashTable; if (num == 0) { printf(\u0026#34;input bucket num must greater then 0.\\n\u0026#34;); return -1; } tb-\u0026gt;bucket_num = num; tb-\u0026gt;bucket = (HashNode**)malloc(sizeof(HashNode*) * num); if (tb-\u0026gt;bucket == NULL) { printf(\u0026#34;malloc failed.\\n\u0026#34;); return -1; } memset(tb-\u0026gt;bucket, 0, sizeof(HashNode*) * num); return 0; } /*------------------------------------------*/ /* forward_list function */ ForwardListNode* initForwardListNode(KEY key, VAL val) { ForwardListNode* DNode = (ForwardListNode*)malloc(sizeof(ForwardListNode)); if (DNode == NULL) { return NULL; } DNode-\u0026gt;key = key; DNode-\u0026gt;val = val; DNode-\u0026gt;prev = DNode; DNode-\u0026gt;next = DNode; return DNode; } void insertToHead(ForwardListNode* head, ForwardListNode* node) { if (head-\u0026gt;next != head) { node-\u0026gt;next = head-\u0026gt;next; head-\u0026gt;next-\u0026gt;prev = node; head-\u0026gt;next = node; node-\u0026gt;prev = head; } else { head-\u0026gt;next = node; head-\u0026gt;prev = node; node-\u0026gt;prev = head; node-\u0026gt;next = head; } } void removeFromTail(ForwardListNode* head) { if (head-\u0026gt;next != head) { ForwardListNode* tail = head-\u0026gt;prev; tail-\u0026gt;next-\u0026gt;prev = tail-\u0026gt;prev; tail-\u0026gt;prev-\u0026gt;next = tail-\u0026gt;next; FREE(tail); } } void updateForwardList(ForwardListNode* head, ForwardListNode* node) { if (head == NULL) { return; } node-\u0026gt;prev-\u0026gt;next = node-\u0026gt;next; node-\u0026gt;next-\u0026gt;prev = node-\u0026gt;prev; insertToHead(head, node); } void destroyForwardListNode(ForwardListNode* head) { if (head == NULL) { return; } ForwardListNode* cur = head-\u0026gt;next; while (cur \u0026amp;\u0026amp; cur != head) { ForwardListNode* next = cur-\u0026gt;next; FREE(cur); cur = next; } FREE(head); } /*------------------------------------------*/ /* LRUCache function */ LRUCache* lRUCacheCreate(int capacity) { LRUCache* lru = (LRUCache*)malloc(sizeof(LRUCache)); if (lru == NULL) { return NULL; } memset(lru, 0, sizeof(LRUCache)); lru-\u0026gt;head = initForwardListNode(-1, -1); if (lru-\u0026gt;head == NULL) { FREE(lru); } lru-\u0026gt;ht = initHashTableMem(); if (lru-\u0026gt;ht == NULL) { FREE(lru-\u0026gt;head); FREE(lru); return NULL; } int ret = initializeHashTable(lru-\u0026gt;ht, capacity); if (ret != 0) { FREE(lru-\u0026gt;ht); FREE(lru-\u0026gt;head); FREE(lru); return NULL; } lru-\u0026gt;size = 0; lru-\u0026gt;capacity = capacity; return lru; } int lRUCacheGet(LRUCache* obj, int key) { HashTable* ht = obj-\u0026gt;ht; ForwardListNode* DouList = obj-\u0026gt;head; HashNode* node = ht-\u0026gt;find(ht, key); if (node == NULL) { return -1; } updateForwardList(DouList, node-\u0026gt;dNode); return node-\u0026gt;dNode-\u0026gt;val; } void lRUCachePut(LRUCache* obj, int key, int value) { HashTable* ht = obj-\u0026gt;ht; ForwardListNode* DouListHead = obj-\u0026gt;head; int index = ht-\u0026gt;hash(ht, key); HashNode* hNode = findListNode(ht-\u0026gt;bucket[index], key); if (hNode == NULL) { ForwardListNode* dNode = initForwardListNode(key, value); if (dNode == NULL) { printf(\u0026#34;mem alloc failed.\\n\u0026#34;); return; } HashNode* new_node = initHashNode(dNode); if (new_node == NULL) { FREE(dNode); printf(\u0026#34;mem alloc failed.\\n\u0026#34;); return; } insertToHead(DouListHead, dNode); insertListNode(\u0026amp;ht-\u0026gt;bucket[index], new_node); ++obj-\u0026gt;size; // del node from tail if (obj-\u0026gt;size \u0026gt; obj-\u0026gt;capacity) { ForwardListNode* tail = DouListHead-\u0026gt;prev; ht-\u0026gt;remove(ht, tail-\u0026gt;key); removeFromTail(DouListHead); obj-\u0026gt;size--; } } else { if (hNode-\u0026gt;dNode-\u0026gt;val != value) { hNode-\u0026gt;dNode-\u0026gt;val = value; } updateForwardList(DouListHead, hNode-\u0026gt;dNode); } } void lRUCacheFree(LRUCache* obj) { destroyForwardListNode(obj-\u0026gt;head); obj-\u0026gt;ht-\u0026gt;destroy(obj-\u0026gt;ht); FREE(obj); } 1.1 关键函数功能简介 LRU的代码实现可以分为4部分。\n1.1.1 单向链表的操作 int insertListNode(HashNode** head, HashNode* node)\n功能说明：向单链表的头部插入一个结点\nint removeListNode(HashNode** head, HashNode* node)\n功能说明：从单链表中移出指定的结点\nHashNode* findListNode(HashNode* head, KEY key)\n功能说明： 在单链表中查找包含指定key的结点\nvoid ListNodeDestroy(HashNode* head)\n功能说明：销毁单链表\n1.1.2 双向链表的操作 ForwardListNode* initForwardListNode(KEY key, VAL val)\n功能说明：构造双向链表的结点。\nvoid insertToHead(ForwardListNode* head, ForwardListNode* node)\n功能说明：向双向链表的头部插入一个结点。\nvoid removeFromTail(ForwardListNode* head)\n功能说明：从双向链表的尾部删除一个结点\nvoid updateForwardList(ForwardListNode* head, ForwardListNode* node)\n功能说明：更新双向链表中的结点，即将指定结点移动到双向链表的头部。\nvoid destroyForwardListNode(ForwardListNode* head)\n功能说明：销毁双向链表\n温馨提示：\n双向链表的遍历操作和单向链表不同,通过判断cur == head作为判断循环终止的条件。\n1.1.3 哈希表的操作 HashNode* initHashNode(ForwardListNode* node)\n功能说明：初始化哈希表的结点\nint hashFunc(HashTable* tb, KEY key)\n功能说明：哈希函数\nHashNode* findHashNode(HashTable* tb, KEY key)\n功能说明：根据key查找哈希结点\nint insertHashNode(HashTable* tb, HashNode* node)\n功能说明： 插入一个哈希结点\nint removeHashNode(HashTable* tb, KEY key)\n功能说明： 删除一个哈希结点\nHashTable* initHashTableMem(void)\n功能说明： 初始化哈希表\nint destroyHashTable(struct HashTable* tb)\n功能说明： 销毁哈希表\nint initializeHashTable(struct HashTable* tb, int num)\n功能说明： 初始化哈希表中的成员\n1.1.4 LRU相关的操作 LRUCache* lRUCacheCreate(int capacity)\n功能说明：创建LRU\nint lRUCacheGet(LRUCache* obj, int key)\n功能说明：查询lru中是否存在key\nvoid lRUCachePut(LRUCache* obj, int key, int value)\n功能说明：向LRU中插入指定的key-value\nvoid lRUCacheFree(LRUCache* obj)\n功能说明： 销毁LRU\n1.1.4 LRU程序的测试代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 void printHashTable(HashTable* tb); void printLruCache(LRUCache* lru); int main(void) { LRUCache* lru = lRUCacheCreate(2); printf(\u0026#34;Put (1,1) \u0026#34;); lRUCachePut(lru, 1, 1); printLruCache(lru); printf(\u0026#34;Put (2,2) \u0026#34;); lRUCachePut(lru, 2, 2); printLruCache(lru); printf(\u0026#34;Get 1 \u0026#34;); int ret = lRUCacheGet(lru, 1); printf(\u0026#34;get(1) ret:%d.\\n\u0026#34;, ret); printLruCache(lru); printf(\u0026#34;Put (3,3) \u0026#34;); lRUCachePut(lru, 3, 3); printLruCache(lru); printf(\u0026#34;Get 2 2 \u0026#34;); ret = lRUCacheGet(lru, 2); printf(\u0026#34;get(2) ret:%d.\\n\u0026#34;, ret); printLruCache(lru); printf(\u0026#34;Put (4,4) \u0026#34;); lRUCachePut(lru, 4, 4); printLruCache(lru); printf(\u0026#34;Get 1 \u0026#34;); ret = lRUCacheGet(lru, 1); printf(\u0026#34;get(1) ret:%d.\\n\u0026#34;, ret); printLruCache(lru); printf(\u0026#34;Put (3,3) \u0026#34;); lRUCachePut(lru, 3, 3); printLruCache(lru); lRUCacheFree(lru); return 0; } void printLruCache(LRUCache* lru) { DouListNode* cur = lru-\u0026gt;head-\u0026gt;next; printf(\u0026#34;LRUCache num: %d.\\n\u0026#34;, lru-\u0026gt;size); while (cur != lru-\u0026gt;head) { printf(\u0026#34;[%d|%d|-]-\u0026gt;\u0026#34;, cur-\u0026gt;key, cur-\u0026gt;val); cur = cur-\u0026gt;next; } printf(\u0026#34;\\n\\n\u0026#34;); return; } void printListNode(HashNode* head) { if (head == NULL) { return; } while (head) { printf(\u0026#34;[%d|%d|-]-\u0026gt;\u0026#34;, head-\u0026gt;dNode-\u0026gt;key, head-\u0026gt;dNode-\u0026gt;val); head = head-\u0026gt;next; } printf(\u0026#34;\\n\u0026#34;); } void printHashTable(HashTable* tb) { for (int i = 0; i \u0026lt; tb-\u0026gt;bucket_num; ++i) { HashNode* head = tb-\u0026gt;bucket[i]; if (head == NULL) { continue; } printf(\u0026#34;index：%d, \u0026#34;, i); printListNode(head); } } 2 LRU的c++代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 struct DNode { DNode() : key(-1), value(-1), prev(nullptr), next(nullptr) {} DNode(int k, int v) : key(k), value(v), prev(nullptr), next(nullptr) {} int key; int value; DNode* prev; DNode* next; }; class LRUCache { public: LRUCache(int capacity) { cap = capacity; size = 0; head = new DNode(); tail = new DNode(); head-\u0026gt;next = tail; head-\u0026gt;prev = tail; tail-\u0026gt;prev = head; tail-\u0026gt;next = head; } int get(int key) { auto item = hashTable.find(key); if (item != hashTable.end()) { DNode* node = item-\u0026gt;second; removeNode(node); insertNodeToHead(node); return node-\u0026gt;value; } return -1; } void put(int key, int value) { auto item = hashTable.find(key); if (item != hashTable.end()) { DNode* node = item-\u0026gt;second; if (node-\u0026gt;value != value) { node-\u0026gt;value = value; } removeNode(node); insertNodeToHead(node); } else { DNode* node = new DNode(key, value); hashTable[key] = node; insertNodeToHead(node); ++size; if (size \u0026gt; cap) { --size; DNode* lastNode = tail-\u0026gt;prev; hashTable.erase(lastNode-\u0026gt;key); removeNode(lastNode); delete lastNode; } } } private: unordered_map\u0026lt;int, DNode*\u0026gt; hashTable; DNode* head; DNode* tail; int cap; int size; void removeNode(DNode* node) { node-\u0026gt;prev-\u0026gt;next = node-\u0026gt;next; node-\u0026gt;next-\u0026gt;prev = node-\u0026gt;prev; } void insertNodeToHead(DNode* node) { node-\u0026gt;next = head-\u0026gt;next; node-\u0026gt;prev = head; head-\u0026gt;next-\u0026gt;prev = node; head-\u0026gt;next = node; } }; ","date":"2024-11-18T17:06:55+08:00","permalink":"https://alvincat.top/post/data_structure/hash_table/lru/","tags":["哈希表","单向链表","双向链表"],"title":"LRU的C代码实现"},{"categories":["Linux"],"contents":"本文主要记录c语言编码过程中的一些注意事项。\n1 C语言编码注意事项 1.1 申请的动态内存一定要做初始化工作 例如：如下所示的代码，若未对table-\u0026gt;bucket指针数组赋初值，该数组中就有可能存在非法值，导致代码访问到非法内存。\n1 2 3 4 5 6 7 8 9 10 11 12 int initHashTable(HashTable* table, int bucket_num) { table-\u0026gt;bucket_num = bucket_num; table-\u0026gt;bucket = (HashNode**)malloc(sizeof(HashNode*) * bucket_num); if (table-\u0026gt;bucket == NULL) { printf(\u0026#34;Alloc memory failed.\\n\u0026#34;); return -1; } // 此处一定要做初始化工作，否则可能存在非法内存访问的情况 memset(table-\u0026gt;bucket, 0, sizeof(HashNode*) * bucket_num); return 0; } 1.2 对结构体变量初始化时，需要初始化所有的变量 实例如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 struct ListNode { int val; struct ListNode *next; }; ListNode* initNode(int val) { ListNode* node = (ListNode*)malloc(sizeof(ListNode)); if (node == NULL) { return NULL; } node-\u0026gt;val = val; // 注意此处一定要初始化，否则有可能访问到非法内存 node-\u0026gt;next = NULL; } 1.3 c语言初始化数组的方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 //Unless that value is 0 (in which case you can omit some part of the initializer and //the corresponding elements will be initialized to 0), there\u0026#39;s no easy way. //Don\u0026#39;t overlook the obvious solution, though: int myArray[10] = { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 }; //Elements with missing values will be initialized to 0: // initialize to 1,2,0,0,0... int myArray[10] = { 1, 2 }; //So this will initialize all elements to 0: int myArray[10] = { 0 }; // all elements 0 //In C++, an empty initialization list will also initialize every element to 0. This is not allowed with C: int myArray[10] = {}; // all elements 0 in C++ //Remember that objects with static storage duration will initialize to 0 if no initializer is specified: static int myArray[10]; // all elements 0 1.4 字符数组初始化的方法 1 2 3 4 5 6 7 8 9 //If you don\u0026#39;t want to change the strings, then you could simply do const char *a[2]; a[0] = \u0026#34;blah\u0026#34;; a[1] = \u0026#34;hmm\u0026#34;; //If you do want to be able to change the actual string content, the you have to do something like char a[2][14]; strcpy(a[0], \u0026#34;blah\u0026#34;); strcpy(a[1], \u0026#34;hmm\u0026#34;); 1.5 16进制字符串转换为整数字符串 1 2 3 4 5 char str[] = \u0026#34;0x1800785\u0026#34;; int num; sscanf(str, \u0026#34;%x\u0026#34;, \u0026amp;num); printf(\u0026#34;0x%x %i\\n\u0026#34;, num, num); 1.6 typedef用法 1 2 3 4 5 6 7 // typedef existing_name alias_name; typedef unsigned int UINT; typedef struct Node { int val; struct Node* next; } Node; 2 C语言中和指针相关知识 2.1 与指针有关的函数声明 1 2 3 4 5 6 7 8 //声明返回指针数组的函数 int (*func(int i))[10]; //声明一个指向函数的指针(pf) bool (*pf)(const string \u0026amp;, const string \u0026amp;); //声明一个名字为pf的函数，该函数返回bool* bool *pf(cosnt string\u0026amp;, const string \u0026amp;); //声明一个返回函数指针的函数 int (*f1(int))(int *, int); 2.2 与指针有关的数组声明 指针数组：array of pointers，即用于存储指针的数组,也就是数组元素都是指针\n数组指针：a pointer to an array，即指向数组的指针\n例如： int* a[4] 指针数组\n表示：数组a中的元素都为int型指针\n元素表示： *a[i]和*(a[i])是一样的，因为[]优先级高于*\nint (*a)[4] 数组指针 表示：指向数组a的指针 元素表示：(*a)[i] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 int main(){ int c[4]={1,2,3,4}; int *a[4]; //指针数组 int (*b)[4]; //数组指针 b=\u0026amp;c; //将数组c中元素赋给数组a for(int i=0;i\u0026lt;4;i++){ a[i]=\u0026amp;c[i]; } //输出看下结果 cout\u0026lt;\u0026lt;*a[1]\u0026lt;\u0026lt;endl; //输出2就对 cout\u0026lt;\u0026lt;(*b)[2]\u0026lt;\u0026lt;endl; //输出3就对 return 0; } 2.3 数组名和指针的区别 2.3.1 数组名不是指针 验证程序：\n1 2 3 int data[10]; cout \u0026lt;\u0026lt; sizeof(data) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; data \u0026lt;\u0026lt; \u0026amp;data \u0026lt;\u0026lt; endl; 说明：第一行的输出结果为40，说明data不是一个指针，编译器将data当作一个数组来处理。此处data为包含10个整型元素的数组。\n2.3.2 数组名作为常量指针 数组名可以转换为指向其指代实体的指针，而且是一个指针常量。该指针指向数组的第一个元素。\n验证程序：\n1 2 3 4 5 6 char str1[10] = \u0026#34;I Love U\u0026#34;; str1++;\t//该语句编译时会出错，因为str1是常量 strcpy(str2, str1);\t//标记2 cout \u0026lt;\u0026lt; \u0026#34;string array 1: \u0026#34; \u0026lt;\u0026lt; str1 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;string array 2: \u0026#34; \u0026lt;\u0026lt; str2 \u0026lt;\u0026lt; endl; 说明：标准C库函数strcpy的函数原形中能接纳的两个参数都为char型指针，而我们在调用中传给它的却是两个数组名。\n2.3.3 指向数组的指针 指向数组的指针则是另外一种变量类型(在32平台下，长度为4），仅仅意味着数组的存放地址。\n验证程序：\n1 2 3 char str1[10] = \u0026#34;I Love U\u0026#34;; char *pStr = str; //标记1 cout \u0026lt;\u0026lt; sizeof(pStr) \u0026lt;\u0026lt; endl; 2.3.4 数组名当作函数实参 数组名在当作实参传入函数内部时，失去数组名的特性，成为普通的指针。\n1 2 3 4 5 6 7 8 9 10 #include \u0026lt;iostream\u0026gt; void arrayTest(char str[]){ cout \u0026lt;\u0026lt; sizeof(str) \u0026lt;\u0026lt; endl; } int main() { char str1[10] = \u0026#34;I Love U\u0026#34;; arrayTest(str1); return 0; } 说明：程序的输出结果为4。\n(1) 数组名作为函数形参时，在函数体内，其失去了本身的内涵，仅仅只是一个指针；\n(2) 很遗憾，在失去其内涵的同时，它还失去了其常量特性，可以作自增、自减等操作，可以被修改。\n3 glibc源码阅读 3.1 实用gdb阅读glibc接口的方法 将glibc源码下载到本地，并解压。 在gdb中添加glibc源码路径； 方法1：在.gdbinit文件中添加命令directory glibc_src_path 方法2：gdb调试二进制时，增加-d参数:-d directory 3.2 理解glibc的简单方法：使用musl libc库 musl libc库实现了和glibc一样的功能，但是代码更简洁易懂。\n可以通过阅读这个代码理解glibc中接口是如何实现的。\nmusl libc库网址\n","date":"2024-11-17T21:39:06+08:00","permalink":"https://alvincat.top/post/linux/c_language_usful_tips/","tags":["c语言"],"title":"c语言基础和编码注意事项"},{"categories":["数据结构"],"contents":"本文介绍哈希表的基本特性和具体实现。\n1 哈希表的基本特性 哈希表产生的背景：因为数组的数组的查找复杂度为$O(n)$, 为了\n2 哈希表(拉链法)的c语言实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;assert.h\u0026gt; #define FREE(ptr) \\ free(ptr); \\ ptr = NULL; typedef int KEY; typedef int VALUE; // hashTable的结点定义 struct HashNode { KEY key; VALUE value; struct HashNode* next; }; typedef struct HashNode HashNode; // hashTable的定义 struct HashTable { int (*initHashTable)(struct HashTable* table, int bucket_num); // init function void (*destroyHashTable)(struct HashTable* table); // destroy function int (*hashFunc)(struct HashTable* table, KEY key); // hash function HashNode* (*find)(struct HashTable* table, KEY key); // find function void (*insertHashNode)(struct HashTable* table, HashNode* node); // insert function HashNode** bucket; // bucket array int bucket_num; // bucket num }; typedef struct HashTable HashTable; int initHashTable(HashTable* table, int bucket_num) { table-\u0026gt;bucket_num = bucket_num; table-\u0026gt;bucket = (HashNode**)malloc(sizeof(HashNode*) * bucket_num); if (table-\u0026gt;bucket == NULL) { printf(\u0026#34;Alloc memory failed.\\n\u0026#34;); return -1; } memset(table-\u0026gt;bucket, 0, sizeof(HashNode*) * bucket_num); return 0; } HashNode* findLinkListNode(HashNode* head, KEY key) { if (head == NULL) { return NULL; } while (head) { if (head-\u0026gt;key == key) { return head; } head = head-\u0026gt;next; } return NULL; } void destroyLinkList(HashNode* head) { if (head == NULL) { return; } HashNode* cur = head-\u0026gt;next; while (cur) { HashNode* prev = cur-\u0026gt;next; head-\u0026gt;next = prev; FREE(cur); cur = head-\u0026gt;next; } } void destroyHashTable(HashTable* table) { int num = table-\u0026gt;bucket_num; HashNode** arr = table-\u0026gt;bucket; for (int i = 0; i \u0026lt; num; ++i) { if (arr[i]) { destroyLinkList(arr[i]); } } FREE(arr); FREE(table); } int hashFunc(HashTable* table, KEY key) { return key % table-\u0026gt;bucket_num; } HashNode* findHashNode(HashTable* table, KEY key) { int index = table-\u0026gt;hashFunc(table, key); assert(index \u0026gt;= 0 \u0026amp;\u0026amp; index \u0026lt; table-\u0026gt;bucket_num); return findLinkListNode(table-\u0026gt;bucket[index], key); } void insertHashNode(HashTable* table, HashNode* node) { if (node == NULL) { return; } int index = table-\u0026gt;hashFunc(table, node-\u0026gt;key); assert(index \u0026gt;= 0 \u0026amp;\u0026amp; index \u0026lt; table-\u0026gt;bucket_num); HashNode* head = table-\u0026gt;bucket[index]; if (head) { HashNode* prev = head-\u0026gt;next; node-\u0026gt;next = prev; head-\u0026gt;next = node; } else { table-\u0026gt;bucket[index] = node; } } HashTable* InitializeHashTable(void) { HashTable* table = (HashTable*)malloc(sizeof(HashTable)); if (table == NULL) { printf(\u0026#34;Melloc memory failed.\\n\u0026#34;); return NULL; } memset(table, 0, sizeof(HashTable)); table-\u0026gt;initHashTable = initHashTable; table-\u0026gt;destroyHashTable = destroyHashTable; table-\u0026gt;hashFunc = hashFunc; table-\u0026gt;findHashNode = findHashNode; table-\u0026gt;insertHashNode = insertHashNode; return table; } HashNode* initHashNode(KEY key, VALUE value) { HashNode* node = (HashNode*)malloc(sizeof(HashNode)); if (node == NULL) { printf(\u0026#34;Melloc memory failed.\\n\u0026#34;); return NULL; } node-\u0026gt;key = key; node-\u0026gt;value = value; node-\u0026gt;next = NULL; return node; } 3 哈希函数 针对key为整数的情况，直接使用对桶大小取余的方式就可以。但是针对复杂的key，例如key为一个链表结点的地址，就需要更加复杂的哈希函数。以下是针对复杂的key的哈希算法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 size_t _Hash_bytes(const void* ptr, size_t len, size_t seed) { size_t hash = seed; const uint8_t* cptr = (const uint8_t*)(ptr); for (; len; --len) { hash = (hash * 131) + *cptr++; } return hash; } int hashFunc(HashTable* table, KEY key) { const void* ptr = (const void*)(key); size_t hash = _Hash_bytes(ptr, 2, rand()); return abs(hash) % table-\u0026gt;bucket_num; } ","date":"2024-11-16T22:09:29+08:00","permalink":"https://alvincat.top/post/data_structure/hash_table/hash_table/","tags":["哈希表"],"title":"哈希表"},{"categories":["数据结构"],"contents":"本文主要介绍单链表常见的功能函数。\n1 单链表常见功能函数 链表相关的功能有：反转链表，获取链表的长度，获取链表的中间结点，判断两条链表是否相加，判断链表是否有环，合并两个有序链表等。\n1.1 翻转单链表 1.1.1 迭代方式翻转单链表 迭代方式翻转链表也称为链表头插法。\n方法1：新增一个临时头结点 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // 新增额外头结点的 struct ListNode* reverseList(struct ListNode* head) { if (head == NULL || head-\u0026gt;next == NULL) { return head; } struct ListNode* headp = (struct ListNode*)malloc(sizeof(struct ListNode)); headp-\u0026gt;val = 0; headp-\u0026gt;next = NULL; struct ListNode* tail = NULL; struct ListNode* cur = head; while (cur) { struct ListNode* pre = cur-\u0026gt;next; tail = headp-\u0026gt;next; headp-\u0026gt;next = cur; cur-\u0026gt;next = tail; cur = pre; } cur = headp-\u0026gt;next; free(headp); headp = NULL; return cur; } 方法2：不新增头结点，进行翻转 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 struct ListNode* reverseList(struct ListNode* head) { if (head == NULL || head-\u0026gt;next == NULL) { return head; } struct ListNode* cur = head-\u0026gt;next; head-\u0026gt;next = NULL; while (cur) { struct ListNode* pre = cur-\u0026gt;next; cur-\u0026gt;next = head; head = cur; cur = pre; } return head; } 1.1.2 递归方式翻转单链表 递归方式代码比较简单，但是要不太容易理解。递归的关键是抽象出一个通用的模型以及边界条件的处理。\n1 2 3 4 5 6 7 8 9 10 11 12 struct ListNode* reverseList(struct ListNode* head) { if (head == NULL || head-\u0026gt;next == NULL) { return head; } struct ListNode* prev = reverseList(head-\u0026gt;next); head-\u0026gt;next-\u0026gt;next = head; head-\u0026gt;next = NULL; return prev; } 1.2 获取单链表长度 1 2 3 4 5 6 7 8 9 10 11 12 13 14 int GetListNum(struct ListNode* head) { if (head == NULL) { return 0; } int cnt = 0; struct ListNode* tmp = head; while (tmp) { ++cnt; tmp = tmp-\u0026gt;next; } return cnt; } 1.3 获取单链表中间结点 功能说明：\n该函数返回链表中心点的前一个结点，即轴对称的尾结点。 例如，若链表有3个结点，则返回的是第1个结点的地址。若链表有4个结点，则返回的是第二个结点的地址。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 struct ListNode* GetMidNode(struct ListNode* head) { int cnt = GetListNum(head); int i = 0; tmp = head; struct ListNode* cur = NULL; while (i \u0026lt; cnt/2 \u0026amp;\u0026amp; tmp) { cur = tmp; tmp = tmp-\u0026gt;next; ++i; } return cur; } 1.4 判断单链表是否存在环 方法说明：\n方法1：使用hashtable。 方法2：使用快慢指针。具体方法是慢指针每次前进一步，快指针每次前进两步。若链表存在环，则经过若干步后，快指针肯定会追上慢指针，即两个指针指向同一个结点。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 bool hasCycle(struct ListNode *head) { if (head == NULL || head-\u0026gt;next == NULL) { return false; } struct ListNode* slow = head; struct ListNode* fast = head-\u0026gt;next; while (slow != fast) { if (fast == NULL || fast-\u0026gt;next == NULL) { return false; } slow = slow-\u0026gt;next; fast = fast-\u0026gt;next-\u0026gt;next; } return true; } 1.4.1 进阶：获取单链表环的入口结点 方法1：使用hashtable。 方法2：使用快慢指针。 2 链表高级特性 3 C++中的链表","date":"2024-11-16T21:29:14+08:00","permalink":"https://alvincat.top/post/data_structure/linklist/link_list_function/","tags":["链表"],"title":"单链表常见功能函数"},{"categories":[],"contents":"","date":"2024-11-16T15:35:21+08:00","permalink":"https://alvincat.top/search/","tags":[],"title":"站内搜索结果"},{"categories":["Linux"],"contents":"这篇文章介绍C语言结构体字节对齐的问题。\n1 结构体字节对齐的规则 结构体变量的首地址能够被其最宽基本类型成员的大小所整除；???\n数据类型自身的对齐：例如，在x86_64系统，char型数据自身对齐值为1字节，short型数据为2字节，int/float型为4字节，long/double/void*型为8字节。\n结构体或者类的自身的对齐：其成员中自身对齐值中的最大值。\n指定对齐值的情况下的对齐规则：#pragma pack (value)时的指定对齐值value。指定规则后以指定规则进行对齐。\n使用伪指令#pragma pack(n)：C编译器将按照n个字节对齐； 使用伪指令#pragma pack()： 取消自定义字节对齐方式。 数据成员、结构体和类的有效对齐值：若存在指定对齐值，需要自身对齐值和指定对齐值中较小者，即有效对齐值=min{自身对齐值，当前指定的pack值}。\n2 x86环境各种基本数据类型的字节数 数据类型 x86 x86_64 char 1 1 short 2 2 int 4 4 long 4 8 float 4 4 double 8 8 void* 4 8 3 示例程序 当前的实例程序假定结构体首地址为0。环境关键信息如下：\nArchithecture: x86_64\nGCC version: 4.4.7\n3.1 指定1字节对齐的示例分析 1 2 3 4 5 6 7 8 #pragma pack(1) struct test { char a; // not padding int b; // not pading short c; }; #pragma pack() sizeof(struct test); // 7 字节 说明：\n变量a，char自身对齐值为1, 指定值为1; 两者取小的值为1。首地址为0，变量a是对齐的，因此变量a占用1个字节。此时偏移1字节。\n变量b, int类型自身对齐值为4, 指定值为1，两者取小的偏移值为1。当前偏移1字节，因此变量b前不需要填充，b占用4字节。此时偏移5字节。\n变量c, short类型自身对齐值为2，指定值为1，两者取小的偏移单位为1。当前偏移5字节，因此变量c前也不需要填充，c占用2字节。此时偏移7字节。\n结构体自身的对齐值取最大变量的长度(int)，即4字节。但是指定的长度为1字节，两者取小即可得到整个结构体的对齐单位为1字节。因此，整个结构体占用7字节。\n3.2 指定2字节对齐的示例分析 1 2 3 4 5 6 7 8 #pragma pack(2) struct test { char a; // pading 1Byte int b; // not padding short c; }; #pragma pack() sizeof(struct test); // 8 字节 说明：\n变量a，char自身对齐值为1, 指定值为2; 两者取小的值为1。首地址为0，变量a是对齐的，因此变量a占用1个字节。此时偏移1字节。\n变量b, int类型自身对齐值为4, 指定值为2，两者取小的偏移值为2。当前偏移1字节，因此变量b前需要填充1字节，b占用4字节。此时偏移6字节。\n变量c, short类型自身对齐值为2，指定值为2，两者取小的偏移单位为2。当前偏移6字节，因此变量c前不需要填充，c占用2字节。此时偏移8字节。\n结构体自身的对齐值取最大变量的长度(int)，即4字节。但是指定的长度为2字节，两者取小即可得到整个结构体的对齐单位为2字节。当前偏移长度为8字节，已经是对齐单位整数倍，所以无需填充。因此，整个结构体占用8字节。\n3.3 指定4字节对齐的示例分析 1 2 3 4 5 6 7 8 #pragma pack(4) struct test { char a; int b; short c; }; #pragma pack() sizeof(struct test); // 12字节 说明： 变量a，char自身对齐值为1, 指定值为4; 两者取小的值为1。首地址为0，变量a默认是对齐的，因此变量a占用1个字节，无需填充。当前偏移1字节。\n变量b, int类型自身对齐值为4, 指定值为4，两者取小的偏移值为4。当前偏移1字节，因此变量b前需要填充3字节，b占用4字节。当前偏移8字节。\n变量c, short类型自身对齐值为2，指定值为4，两者取小的偏移单位为2。当前偏移8字节，因此变量c前不需要填充，c占用2字节。当前偏移10字节。\n结构体自身的对齐值取最大变量的长度(int)，即4字节。指定的长度为4字节，两者取小即可得到整个结构体的对齐单位为4字节。当前偏移长度为10字节，不是对齐单位整数倍，所以需要填充2字节。因此，整个结构体占用12字节。\n3.3 指定8字节对齐的示例分析 1 2 3 4 5 6 7 8 #pragma pack(8) struct test { char a; int b; short c; }; #pragma pack() sizeof(struct test); // 12字节 说明： 变量a，char自身对齐值为1, 指定值为8; 两者取小的值为1。首地址为0，变量a默认是对齐的，因此变量a占用1个字节，无需填充。当前偏移1字节。\n变量b, int类型自身对齐值为4, 指定值为8，两者取小的偏移值为4。当前偏移1字节，因此变量b前需要填充3字节，b占用4字节。当前偏移8字节。\n变量c, short类型自身对齐值为2，指定值为8，两者取小的偏移单位为2。当前偏移8字节，因此变量c前不需要填充，c占用2字节。当前偏移10字节。\n结构体自身的对齐值取最大变量的长度(int)，即4字节。指定的长度为8字节，两者取小即可得到整个结构体的对齐单位为4字节。当前偏移长度为10字节，不是对齐单位整数倍，所以需要填充2字节。因此，整个结构体占用12字节。\n3.4 不指定字节，按照默认对齐的示例分析 1 2 3 4 5 6 7 struct test { char a; int b; short c; long d; }; sizeof(struct test); // 24字节 说明： 变量a，char自身对齐值为1; 首地址为0，变量a默认是对齐的，因此变量a占用1个字节，无需填充。当前偏移1字节。\n变量b, int类型自身对齐值为4。当前偏移1字节，因此变量b前需要填充3字节，b占用4字节。当前偏移8字节。\n变量c, short类型自身对齐值为2。当前偏移8字节，因此变量c前不需要填充，c占用2字节。当前偏移10字节。\n变量d, long类型自身对齐值为8。当前偏移10字节，因此变量d前需要填充6个字节，c占用8字节。当前偏移24字节。\n结构体自身的对齐值取最大变量的长度(long)，即8字节。无指定的对齐长度，因此整个结构体的对齐单位为8字节。当前偏移长度为24字节，是对齐单位整数倍，所以不需要填充。因此，整个结构体占用24字节。\n","date":"2024-11-15T22:52:34+08:00","permalink":"https://alvincat.top/post/linux/struct_alignment/","tags":["结构体字节对齐"],"title":"C语言结构体字节对齐问题"},{"categories":["数据结构"],"contents":"本文介绍链表的基本特性以及链表常用的操作。\n1 链表的特性 链表是一种链式存储数据的结构。相邻的两个结点之间在物理地址上并不是连续存放的。因此就决定了链表无法进行随机访问，只能按照链接关系进行顺序访问。 只能单向变量的链表称为单链表，可以双向访问的链表称为双向链表。\n2 链表的基本操作 链表的常用操作有：创建链表，链表结点的插入、删除，销毁链表等。\n2.1 链表结点的定义 链表结点的定义是一种递归形式的定义，链表中的指针是链表结点类型的指针。\n1 2 3 4 struct ListNode { int val; struct ListNode *next; }; 2.1 链表的创建 2.2 链表的销毁","date":"2024-11-15T17:52:42+08:00","permalink":"https://alvincat.top/post/data_structure/linklist/link_list_introduction/","tags":["链表"],"title":"链表基本特性及其相关操作"},{"categories":["Linux"],"contents":"本文记录Linux常用命令的用法。\n1 linux命令的综合使用 1 2 # 删除出指定文件之外的文件 ls | grep -xvF file.txt | xargs rm -rf -- ","date":"2024-11-15T17:13:30+08:00","permalink":"https://alvincat.top/post/linux/linux_common_tools/","tags":["Linux常用命令"],"title":"Linux常用命令的用法"},{"categories":["算法"],"contents":"本文记录字符串匹配算法的演进已经具体实现。\n字符串匹配算法(String Search Algorigthm) 一点说明：\n原串：即子串匹配过程中， 待查找的字符串；\n搜索串：即用来匹配的特定的一个子串。\n1 KMP算法 (The Knuth-Morris-Pratt Algorithm) 优点：在暴力解法的基础上，减少匹配过程中查找字符串比较次数。\n缺点：当待查找的字符串没有重复搜索串时，算法退化为暴力解法。\n算法中的概念：\n局部匹配表(partial match table):查找过程中的子串中真前缀和真后缀的最大公共长度。\n字符串的真前缀(proper prefix)：例如 “S”, “Sn”, “Sna”, 和 “Snap” 都是 “Snape”的proper prefix。\n字符串的真后缀(proper suffix)：例如“d”,“agrid”, “grid”, “rid”, “id”和 都是“Hagrid”的proper suffix。\n计算局部匹配表(partial math table) 局部匹配表有时也称为next数组。该表是由子串的内容决定的。计算过程如下(以下过程以字符串\u0026quot;abababca\u0026quot;为例)：\n字符串长度为1时，字符串为\u0026quot;a\u0026quot;。因此对应表项为0。\n字符串长度为2时，字符串为“ab”，proper prefix包含“a”；proper suffix包含“b”，因此对应表项为0。\n字符串长度为3时，字符串为“aba”，proper prefix包含“a”, “ab”； proper suffix包含“a”,“ba”，因此对应表项为1。\n字符串长度为4时，字符串为“abab”，proper prefix包含“a”, “ab”,“aba”；proper suffix包含“b”，“ab”，“bab”，因此对应表项为2。\n字符串长度为5时，字符串为“ababa”，proper prefix包含“a”, “ab”,“aba”,“abab”；proper suffix包含“a”，“ba”，“aba”，“baba”，因此对应表项为3。\n字符串长度为6时，字符串为“ababab”，proper prefix包含“a”, “ab”,“aba”,“abab”,“ababa”；proper suffix包含“b”，“ab”，“bab”，“abab”,，因此对应表项为3。\n使用局部匹配表进行字符串匹配 设局部匹配表为table。如果存在部分匹配值partial_match_length，而且table[partial_match_length] \u0026gt; 1，则子串可以跳过的长度为：partial_match_length - table[partial_match_length - 1] 。例如：\n第一次匹配情况，如下图所示：\n该匹配中部分匹配长度(partial_match_length)为1。而对应的值table[partial_match_length - 1]即table[0]等于0。因此我们不需要跳过任何字母。 接下来的匹配情况如下图所示：\n该匹配中部分匹配长度为(partial_match_length)为5。这个值对应的table[partial_match_length - 1](即table[4])值为3。这意味着partial_match_length - table[partial_match_length - 1](即5 - talbe[4]，即5-3，即2)。即子串向右移动2个字符。如图所示：\n移动后的匹配情况如上图所示，匹配成功长度(partial_match_length)为3。对应的table[partial_match_length - 1](即table[2])值为1。意味着我们向后移动长度为：partial_match_length - table[partial_match_length - 1](即3 - table[2] = 3 - 1 = 2)。移动后的结果如图所示：\n因子串尾部以超过原串长度，因此结束匹配。\n2 BM算法 (Boyer-Moore Algorithm) 1977年，德克萨斯大学的Robert S. Boyer教授和J Strother Moore教授发明了这种算法。因此取这两个人的名字而得。word中的查找功能就是使用该算法。\n算法中的概念：\n坏字符(bad character)：字符串匹配过程中，与搜索串不匹配的字符。 好后缀(good suffix): 即搜索串与原串尾部能够匹配的字符串。 坏字符实例，如下图: 好后缀实例，如下图：\n比较规则：首先，将搜索串与原串对齐，从搜索串尾部从后往前比较。\n坏字符移动规则: 后移位数 = 坏字符的位置 - 搜索词中的上一次出现位置。说明，若搜索串中不包含坏字符，则搜索串上一次出现位置为-1。若包含该字符，则为离坏字符位置最近的那个位置。\n好后缀规则 :后移位数 = 好后缀的位置 - 搜索词中的上一次出现位置。好后缀位置以后缀最后一个位置为准。说明，若搜索串中不包含坏字符，则搜索串上一次出现位置为-1。例如：\n如果字符串\u0026quot;ABCDAB\u0026quot;的后一个\u0026quot;AB\u0026quot;是\u0026quot;好后缀\u0026quot;。那么它的位置是5（从0开始计算，取最后的\u0026quot;B\u0026quot;的值），在\u0026quot;搜索词中的上一次出现位置\u0026quot;是1（第一个\u0026quot;B\u0026quot;的位置），所以后移 5 - 1 = 4位，前一个\u0026quot;AB\u0026quot;移到后一个\u0026quot;AB\u0026quot;的位置。 如果字符串\u0026quot;ABCDEF\u0026quot;的\u0026quot;EF\u0026quot;是好后缀，则\u0026quot;EF\u0026quot;的位置是5 ，上一次出现的位置是 -1（即未出现），所以后移 5 - (-1) = 6位，即整个字符串移到\u0026quot;F\u0026quot;的后一位。 注意：\n以上两个规则的中的位置指的是搜索串中的位置。 当通过坏字符规则和好后缀移动规则得到的值不同时，取较大的值作为移动量。 下面以字符串为\u0026quot;HERE IS A SIMPLE EXAMPLE\u0026quot;，搜索词为\u0026quot;EXAMPLE\u0026quot;为例，进行说明：\nstep1：\n首先遇到坏字符，计算移动位置：6 - (-1) = 7. step2:\n遇到坏字符，计算移动位置：6 - 4 = 2.\nstep3:\n遇到好后缀，计算移动位置：6 - 0 = 6。\nstep4:\n坏字符和好后缀的选择问题：\n坏字符的结果：\n后后缀的结果：\nstep5:\n3 Sunday算法(Sunday Algorigthm) sunday算法是对BM算法的改进。改进之处：当匹配失败时，判断搜索串下次匹配位置的第一个字符是否与搜索串第一个字符是否相同。进而减少匹配次数。\n","date":"2024-11-15T16:01:16+08:00","permalink":"https://alvincat.top/post/algorithm/string_match_algorightm/","tags":["字符串匹配"],"title":"字符串匹配算法"},{"categories":["环境搭建"],"contents":"Hugo中一些实用的配置。\n1 设置网站的页面宽度 在文件themes\\even\\assets\\sass\\_variables.scss中找到配置项$global-body-width，默认值为800。\n调整这个值就可以改变网站中页面的宽度。\n2 Hugo中使用图片的方法 在根目录static目录下创建目录放置图片即可。在markdown文件中按照形如/image/logo.png的方式进行引用即可。\n3 修改Hugo even主题主页的字体 将文件themes\\even\\assets\\sass\\_partial\\_header\\_logo.scss 中.logo的font-family属性按照如下形式修改即可：\n1 2 3 4 .logo { font-size: $logo-font-size; font-family: $global-serif-font-family; } 4 修改网站的语言 修改方法：修改网站工程根目录的config.toml文件，将defaultContentLanguage属性改为zh-cn 即可。切换后会使用theme主题i18n目录下对应的yaml文件。\n5 添加站内搜索功能 我自己的修改：\n源码仓：git@github.com:alvincat/MyGithubWebsite.git/master: 5f7a66cfe4e0a6cb94f33518297828c894e431b4\n模板仓：git@github.com:alvincat/HugoThemeEven.git/master: 088afb3d0cc34329a64b4e596a54e3e2af0c634b\n主要参考文档：\n给Hugo中的Even主题添加搜索功能 - 飞狐的部落格\n其他参考文档：\n给hugo添加搜索功能 | 搜百谷\nSuper fast, keyboard-optimized, client side Hugo search\n6 将页面置顶 若需要在主页将某个页面置顶，只需要在页面对应的md文件的文件头中添加weight: 1即可。 weight:1表示将该页面放在第1的位置，若需要将某个页面放在第二个位置，在源文件的头部添加weight:2即可。\n","date":"2024-11-14T23:34:32+08:00","permalink":"https://alvincat.top/post/hugo/hugo_some_usful_setting/","tags":["Hugo"],"title":"Hugo中一些实用的配置"},{"categories":["Tools"],"contents":"本文记录Git常用命令。\n1 Git常用命令 1.1 查询命令 1 2 3 git status # 查看当前git状态 git log # 查询修改记录 git tag -l # 查询tag 1.2 代码下载上传 1 2 3 4 5 6 7 # down load source code git clone -b main git@github.com:alvincat/MyGithubWebsite.git MyWebsite git submodule update --recursive # update submodule git push git pull git push --set-upstream origin gh_pages # upload new branch 1.3 分支相关操作 1 2 3 4 5 6 git branch # 查看本地所有分支 git branch | grep \u0026#34;*\u0026#34; #查看当前分支 git checkout branch_name # 切换分支 git checkout -b gh_pages # create branch git branch -D gh_pages # 删除本地分支 git push origin --delete main # 删除远端分支 1.4 修改相关操作 1 2 3 4 5 6 7 8 9 10 11 git commit -m \u0026#34;\u0026#34; # add commit git add file1 file2 # add to local cache git stash # 暂存当前修改 git stash pop # 恢复暂存内容 git reset --hard origin/master # 强制更新当前分支代码为master分支 git reset --mixed commit_id # 将制定commit_id以后的提交回退至未提交 git rebase -i head~2 git cherry-pick commit_id 1.5 远程仓库操作 1 2 3 4 5 6 7 8 9 10 11 12 # 查询本地关联的代码仓 git remote -v # 添加远程分支, 其中origin为远程代码仓在本地的name, 本地代码可以关联多个远程代码仓 git remote origin https://github.com/olOwOlo/hugo-theme-even git remote add myEvenBackup git@github.com:alvincat/HugoThemeEven.git # 提交代码时可以指定代码仓进行 # 提交代码至https://github.com/olOwOlo/hugo-theme-even的master分支 git push -u origin master # 提交代码至git@github.com:alvincat/HugoThemeEven.git的master分支 git push -u myEvenBackup master 2 Git相关配置 2.1 Git添加ssh公钥 设置用户名和邮箱 1 2 3 4 5 6 7 8 9 10 11 12 # 设置用户名 git config --global user.name \u0026#34;username\u0026#34; # 设置邮箱 git config --global user.email your_email@example.com # 查看用户名和密码 git config user.name git config user.email # 查看其他配置信息(git设置列表) git config --list 执行命令生成ssh公钥和私钥 windows环境 1 2 # 使用Ed25519加密算法生成公钥和私钥 ssh-keygen -t ed25519 -C \u0026#34;your_email@example.com\u0026#34; Linux或者MacOS环境 1 2 # 使用Ed25519加密算法生成公钥和私钥 ssh-keygen -t ed25519-sk -C \u0026#34;your_email@example.com\u0026#34; 将生成的公钥文件id_ed25519.pub中的内容添加至github即可使用ssh上传下载代码。 温馨提示：\n若添加公钥后，提交代码提示错误：push declined due to email privacy restrictions\n原因：将github关联的email设置为私密，对外不可见。\n解决方法：\n方法1：进入https://github.com/settings/emails页面，将【Block command line pushes that expose my email】勾选去掉。 方法2：使用github提供的转换邮件地址。(在标签【Keep my email addresses private】的内容中提供，形如：12345678+username@users.noreply.github.com)。使用这个邮件地址更新密钥即可。 2.2 gitignore的用法 git在提交代码时，存在部分本地生成的和代码无关的文件，不需要提交。这种文件或者目录就需要使用gitignore的机制进行过滤。使用方法如下：\n在代码根目录创建文件.gitignore 在文件中添加需要过滤的文件和目录，注意若要过滤整个目录，需要在目录后跟/ 常见情况解决方法：\n添加到.gitignore文件中的目录，再次提交后并未生效。解决方法，执行代码：git rm -r --cached \u0026lt;folder\u0026gt; ","date":"2024-11-14T17:13:30+08:00","permalink":"https://alvincat.top/post/tools/git_commond/","tags":["Git"],"title":"Git常用命令"},{"categories":["环境搭建"],"contents":"本文记录Hugo配置github静态页面的关键步骤。\n1 Hugo简介 Hugo是由Go语言实现的静态网站生成器。简单、易用、高效、易扩展、快速部署。\nHugo官网：Hugo官网\nHugo的官方文档：Hugo中文文档\n2 使用Hugo发布静态网站的准备工作 2.1 下载安装部署网站工具 2.1.1 下载安装git Git下载地址：Download Git\nWindows下安装方法：运行二进制程序，然后按照提示操作即可。\n2.1.2 下载安装go 官方下载地址：Download and install - The Go Programming Language\nGo语言中文网下载地址：Go语言中文网下载地址\n我下载的go版本是：go1.17.3\n安装配置完成后，使用命令go version 查看版本号。\n温馨提示：若下载的是免安装版本，需要手动配置环境变量，否则无法使用。\n2.1.3 下载安装hugo-extend Hugo v0.138.0下载地址： Hugo v0.138.0下载地址\n我下载的是：hugo_extended_withdeploy_0.138.0_windows-amd64.zip\n安装配置完成后，使用命令hugo version 查看版本号。\n温馨提示：若下载的是免安装版本，需要手动配置环境变量，否则无法使用。\n2.2 创建代码仓 在github创建私有库MyGithubWebsite: 用于存放网站工程源码 在github创建公共代码username.github.io: 用于保存网站内容。\ngithub规定必须将网站内容放在形如username.github.io的代码仓中，此处的username为你的github的用户名。 2.3 下载代码 1 git clone git@github.com:alvincat/MyGithubWebsite.git MyWebsite 2.4 初始化网站 1 2 # 在网站根目录的上层目录执行命令，MyWebsite为网站工程根目录名 hugo new site MyWebsite --force 2.5 Hugo使用even模板 2.5.1 下载even模板 1 2 # 进入根目录，执行命令下载网站模板 git clone https://github.com/olOwOlo/hugo-theme-even themes/even 2.5.2 even模板配置 在even主题的 exampleSite 目录下有一个 config.toml 文件，将这个 config.toml 文件复制到你的站点根目录下，根据自己的需求更改即可。\n为了定制 favicon，你需要在站点根目录的 static 文件夹下放置下述所有文件，这将覆盖 themes/even/static/ 文件夹下的那些文件。\nandroid-chrome-192x192.png android-chrome-512x512.png apple-touch-icon.png browserconfig.xml favicon.ico favicon-16x16.png favicon-32x32.png manifest.json mstile-150x150.png safari-pinned-tab.svg 2.5.3 even文章模板配置 你可以通过 front-matter 针对每一篇文章单独进行设置。themes/even/archetypes/default.md 文件陈列了所有可用的参数。\n将该文件复制到站点根目录的 archetypes 文件夹下将会有所帮助。\n3 使用Hugo撰写博客 3.1 使用hugo创建文件 1 hugo new post/hello.md 注意:\n对于even这个主题，你应该使用 post 而不是 posts，即 hugo new post/some-content.md 建议使用hugo new命令来新建文件，而不要直接在post目录下创建文件。 3.2 hugo本地调试博客文章 1 hugo server -D 登陆浏览器查看结果：localhost\n3.3 发布网站 在站点根目录执行 以下Hugo 命令生成最终页面：\n1 hugo -D --baseURL=\u0026#34;https://alvincat.github.io/\u0026#34; 执行这条命令，就会在public目录下生成最终网站内容。\n将public的内容推送到username.github.io仓库，就可以访问网站了\n3.4 创建.gitignore文件，忽略部分文件 3.5 本地调试完成后，提交代码至github 1 2 3 git add file git commit -m \u0026#34;add file\u0026#34; git push 温馨提示：\n在本地调试完成提交前，建议先将public目录下的内容清空，重新编译后再提交，以免public目录存在修改的残留文件。\n4 使用github actions功能自动发布网站的方法 4.1 创建personal access token 按照setting -\u0026gt; Developer Settings -\u0026gt; Personal access tokens的顺序打开创建token界面。如下图所示。 按照Tokens(classic) -\u0026gt; Generate new token -\u0026gt; Generate new token(classic)的顺序创建token。如下图所示： 在创建token的界面勾选【workflow]按钮。如下图所示： 点击创建后，就会生成一串token编码。此时需要复制这串编码，后面添加的时候需要使用。 4.2 添加secrets 进入网站工程的setting界面，如下图所示： 进入添加secret界面，填写secretname和步骤5.1生成的token。(注意： 此处的secret name后续在配置文件中会用到。）如下图所示： 添加完成后就会提示添加成功。如下图所示：\n4.3 添加active自动化配置文件 在网站工程根目录创建目录.github/workflows/，然后再该目录下创建一个yml文件，文件名自定。此处文件名为hugo.yml。文件内容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 name: GitHub Pages on: push: branches: - master # 博客工程根目录的默认分支，我的是master，请以实际为准 jobs: deploy: runs-on: ubuntu-latest concurrency: group: ${{ github.workflow }}-${{ github.ref }} steps: - uses: actions/checkout@v2 with: submodules: false fetch-depth: 0 - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#39;latest\u0026#39; extended: true # 如果你使用的不是extended版本的hugo，将true改为false - name: Build run: hugo --minify - name: Deploy uses: peaceiris/actions-gh-pages@v3 if: ${{ github.ref == \u0026#39;refs/heads/master\u0026#39; }} # 博客工程根目录的默认分支，我的是master，请以实际为准 with: personal_token: ${{ secrets.YOUR_SECRET}} # 如果secret取了其他名称，将YOUR_SECRET替换掉 external_repository: alvincat/alvincat.github.io # 填写远程仓库，名字 publish_dir: ./public #cname: www.example.com # 填写你的自定义域名。如果没有用自定义域名，注释掉这行 该配置文件的作用就是当私有库MyGithubWebsite的master分支代码提交后，将public目录的内容推送到username.github.io的gh-pages分支。可以通过查看MyGithubWebsite的action页面确认，该配置是否生效。 如下图所示： 其实该功能也可以手动完成，当本地调试完成后，将public的内容推送到username.github.io的gh-pages分支。\n1 2 3 4 5 6 cd public git init git remote add origin git@github.com:alvincat/alvincat.github.io.git git add . git commit -m \u0026#39;add blog\u0026#39; git push origin gh-pages 4.4 修改username.github.io代码仓的page页面关联分支 当步骤5.4更新成功后，就会将生成的网站内容推送到username.github.io代码仓的gh-pages分支。因此需要将username.github.io代码仓的page关联分支切换为gh-pages。\n修改方法如下：\n5 参考文献 将Hugo静态网站部署到Github Pages\nHugo + even + GitHub Pages+ Utterances搭建个人博客\n利用GitHub Action实现Hugo博客在GitHub Pages自动部署\nHugo + GitHub Action，搭建你的博客自动发布系统\n","date":"2024-11-14T16:51:30+08:00","permalink":"https://alvincat.top/post/hugo/hugo_build_static_page/","tags":["Hugo"],"title":"Hugo配置github静态页面的方法"},{"categories":[],"contents":"关于我的详细信息。\n个人信息 Name : alvincat 个人爱好 联系我 \u0026#x1f4e7; : alvincat@126.com Github: https://github.com/alvincat 友情链接","date":"2024-11-14T11:16:25+08:00","permalink":"https://alvincat.top/about/","tags":[],"title":"关于我"},{"categories":[""],"contents":"该页面为C++的导航页。\n工具 C++易混淆知识点\nC++中部分关键字的用法\nC++面向对象基础知识\nC++常用功能汇总\nC++常用库函数的用法\nC++ sring的用法\nC++ STL的用法\nC++ vector的内部实现和用法\n","date":"2024-11-13T18:26:40+08:00","permalink":"https://alvincat.top/index/content_cpp/","tags":[""],"title":"C++导航页"},{"categories":[""],"contents":"该页面为工具使用的导航页。\n工具 程序员入门必读\nGit常用命令\nVim常用设置以及常用命令\nGDB常用命令\nGDB打印STL中各种容器的内容的方法\nGCC常用编译命令和库函数\nMarkdown使用技巧\nQT入门文档\n","date":"2024-11-13T18:25:40+08:00","permalink":"https://alvincat.top/index/content_tools/","tags":[""],"title":"工具使用导航页"},{"categories":[""],"contents":"该页为的操作系统导航页。\n操作系统 环境配置 Ubuntu环境配置\n内核相关 Kernel_boot_process\n","date":"2024-11-13T17:57:26+08:00","permalink":"https://alvincat.top/index/content_os/","tags":[""],"title":"操作系统导航页"},{"categories":[""],"contents":"该页为的环境搭建导航页。\n环境搭建 Hugo配置github静态页面的方法\nHugo中一些实用的配置\n","date":"2024-11-13T16:58:15+08:00","permalink":"https://alvincat.top/index/content_environment_deploy/","tags":[""],"title":"环境搭建导航页"},{"categories":[""],"contents":"该页为的Linux相关内容的导航页。\nLinux C语言结构体字节对齐问题\nc语言编码注意事项\nLinux常用命令的用法\nLinux系统常用的系统配置\n并发编程中常见的问题\nLinux系统中进程打印堆栈的原理\nLinux系统中钩子的使用方法\nAPUE UNIX标准\n进程环境\n信号\n线程同步的方法\n进程同步的方法\n内存映射\n进程间通信的方法\n","date":"2024-11-13T16:57:51+08:00","permalink":"https://alvincat.top/index/content_linux/","tags":[""],"title":"Linux相关内容的导航页"},{"categories":[""],"contents":"该页为数据结构的导航页。\n1 数据结构 1.1 线性结构 1.1.1 数组 1.1.1.1 数组 1.1.1.2 字符串 1.1.1.4 矩阵 1.1.2 链表 1.1.2.1 单向链表 单链表常见功能函数\n链表基本特性及其相关操作\n1.1.2.2 双向链表 1.1.3 栈 1.1.3.1 栈的原理和实现 1.1.3.1.1 栈的原理 1.1.3.1.2 栈的具体实现 C语言实现栈的方法\n1.1.3.2 单调栈 1.1.4 队列 1.1.4.1 队列的原理和实现 1.1.4.1.1 队列的原理 1.1.4.1.2 队列的实现 C语言实现一个队列的方法\n1.1.4.3 单调队列 1.1.4.3 优先级队列(堆) 1.2 哈希表 1.2.1 哈希表 哈希表的原理和实现\n1.2.2 LRU LRU的原理和实现\n1.2.3 LFU 1.3 树 1.3.1 树 1.3.2 二叉树 创建二叉树的方法\n二叉树的遍历方法\n1.3.3 二叉搜索树 1.3.3.1 BST 1.3.3.2 红黑树 1.3.4 字典树 1.3.5 线段树 1.3.6 树状数组 1.4 图 1.4.01 图论基础 1.4.02 最短路径 1.4.03 并查集 1.4.04 拓扑排序 拓扑排序的原理和代码实现\n1.4.05 最小生成树 1.4.06 强连通分量 1.4.07 双连通分量 1.4.08 欧拉回路 1.5 有序集合","date":"2024-11-13T16:56:59+08:00","permalink":"https://alvincat.top/index/content_data_structure/","tags":[""],"title":"数据结构导航页"},{"categories":[""],"contents":"该页为算法的导航页。\n1 排序 1.1 交换类排序 1.1.1 冒泡排序 1.1.2 快速排序 1.2 选择类排序 1.2.1 选择排序 1.2.2 堆排序 堆排序的原理和实现\n1.3 插入类排序 1.3.1 插入排序 1.3.2 希尔排序 1.4 归并排序 1.5 计数排序 1.6 基数排序 1.7 桶排序 1.8 排序总结 排序总结\n2 查找 2.1 二分查找 3 回溯 回溯算法总结\n4 递归 5 分治 6 贪心 贪心算法\n7 动态规划 动态规划的原理和引用\n7.1 最长公共子序列(LCS) 8 搜索 8.1 深度优先搜索(DFS) 遍历-DFS\n8.2 广度优先搜索(BFS) 遍历-BFS\n9 记忆化搜索 10 字符串匹配 字符串匹配算法\n11 模拟 12 枚举","date":"2024-11-13T16:56:45+08:00","permalink":"https://alvincat.top/index/content_algorithm/","tags":[""],"title":"算法导航页"}]