[{"categories":[""],"contents":"该页面为网站的导航页面。\n算法导航页 数据结构导航页 操作系统导航页 Linux相关内容导航页 环境搭建导航页 ","date":"2024-11-13T16:30:08+08:00","permalink":"https://alvincat.github.io/post/index/content/","tags":[""],"title":"网站导航页"},{"categories":[""],"contents":"本文介绍markdown的语法和一些实用技巧。\n1 Markdown语法 Markdown语法在线文档\n2 Markdown使用说明 2.1 使用emoji表情符的方法 若markdown支持emoji表情符，直接将对应的表情符添加在文本中即可显示。例如：\n今天天气很好!:sunny:\n显示的结果为：今天天气很好! \u0026#x2600;\u0026#xfe0f;\nemoji表情符在线查询: https://github.com/ikatyang/emoji-cheat-sheet/blob/master/README.md\n2.2 Markdown表格单元格中输入多行内容的方法 方法1：在需要换行的地方添加\u0026lt;br\u0026gt;即可。示例： 动物 猫\n狗\n兔 方法2：在markdown中使用html的表格,转换为html后即可支持显示表格。\nPerson 1\rPerson 2\rPerson 3\rEmil\rTobias\rLinus\r16\n17\n18\r14\r10\r2.3 markdown中设置图片大小的方法 直接使用html中设置图片大小的方法即可，这样转换为html就可以符合预期了。\n1 \u0026lt;img src=\u0026#34;/web_image/about/badminton.svg\u0026#34; width=\u0026#34;30\u0026#34;\u0026gt; ","date":"2024-11-30T10:48:47+08:00","permalink":"https://alvincat.github.io/post/linux/tools/markdown_usful_tips/","tags":[""],"title":"Markdown使用技巧"},{"categories":["Linux"],"contents":"本文介绍gdb一些常用命令。\n1 GDB的一些实用的文档 gdb cheat sheet 100-gdb-tips GDB User Manual GDB online 2 gdbinit文件的简单配置方法 在当前用户目录下创建文件：touch ~/.gdbinit\n在~/.gdbinit文件中添加常用的gdb命令即可。常用的配置如下：\n1 2 3 4 directory /usr/src/glibc/glibc-2.27/ # 指定源码所在目录 layout src # 显示源码模式 set pagination off # 输出信息较多时不会暂停输出 set confirm off # gdb退出时不显示提示信息 3 GDB常用命令 3.1 界面配置 命令 功能 layout src 显示源代码 layout asm 显示汇编代码 layout regs 显示寄存器内容 layout split 显示源代码和汇编窗口 layout next 显示下一个layout layout prev 显示上一个layout 3.2 单步执行 命令 功能 next/n 单步执行，不进入函数内部 step/s 单步执行，是函数则进入函数内部 until line-number 执行到指定行号 where 显示当前行号和当前所在的函数 3.3 断点调试 命令 功能 break/b \u0026lt;where\u0026gt; 在函数入口设置断点 enable \u0026lt;breakpoint\u0026gt; 打开断点 disable \u0026lt;breakpoint\u0026gt; 关闭断点 delete \u0026lt;breakpoint\u0026gt; 删除断点 clear 删除所有断点 info breakpoints [n] 查看断点 break \u0026lt;where\u0026gt; if \u0026lt;condition\u0026gt; 设置条件断点 示例:\n1 2 # 条件断点：第10行中，若变量i等于101则停止。 b 10 if i==101 3.4 观察点 命令 功能 watch \u0026lt;where\u0026gt;/variable 设置观察点 enable \u0026lt;breakpoint\u0026gt; 打开断点 disable \u0026lt;breakpoint\u0026gt; 关闭断点 delete \u0026lt;breakpoint\u0026gt; 删除断点 info watchpoints [n] 查看观察点 watch \u0026lt;where\u0026gt; if \u0026lt;condition\u0026gt; 设置条件观察点 rwatch/rw variable 设置读观察点 awatch/aw variable 设置读写观察点 watch expr thread threadnum 设置指定线程上的观察点 3.5 断点/观察点位置 命令 功能 function_name 函数名 line_num 行号 filenaem:line_num 文件+行号 addr 地址 3.6 打印信息 命令 功能 print \u0026lt;what\u0026gt; 打印指定内容 info proc mappings 打印内存映射信息 x/nfu 0xaddr Examine the contents of memory and specify formatting.\nn: number of display items to print\nf: specify the format for the output\nu: specify the size of the data unit (eg. byte, word, \u0026hellip;)\nExample: x/4dw var n：输出单元的个数。\nf：是输出格式。比如 x 是以16进制形式输出， o 是以8进制形式输出,等等。\nu：标明一个单元的长度。\nb 是一个 byte\nh 是两个 byte （halfword）\nw 是四个 byte （word）\ng 是八个 byte （giant word）。\n3.7 查看栈帧 命令 功能 backtrace/bt 打印栈帧 frame/f \u0026lt;frame#\u0026gt; 显示指定栈帧 info frame 显示当前栈帧的信息 info locals 显示当前帧的局部变量信息 3.8 调试线程 命令 功能 set scheduler-locking on 只允许一个线程运行 set follow-fork-mode child 调试子进程 set detach-on-fork off 调试父子进程 info threads 查看线程信息 thread \u0026lt;thread#\u0026gt; 切换调试线程 3.9 修改程序中的值 命令 功能 set var \u0026lt;variable_name\u0026gt;=\u0026lt;value\u0026gt; 修改变量的值 return \u0026lt;expression\u0026gt; 强制将当前函数按照指定值返回 3.10 汇编运行 命令 功能 info line number 显示指定位置的汇编代码 stepi/si 单步运行汇编指令 nexti/ni 单步运行汇编指令 disassemble 0xstart 0xend 反汇编指定地址的代码 ","date":"2024-11-29T16:31:59+08:00","permalink":"https://alvincat.github.io/post/linux/tools/gdb_usful_tips/","tags":["GDB"],"title":"GDB常用命令和一些实用方法"},{"categories":["数据结构"],"contents":"本文介绍二叉树的构造方式。\n1 二叉树的构造方法 1.1 通过前序遍历和中序遍历序列构造二叉树 前提条件：\npreorder 和 inorder 均 无重复 元素 inorder 均出现在 preorder preorder 保证 为二叉树的前序遍历序列 inorder 保证 为二叉树的中序遍历序列 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Solution { public: TreeNode* buildTree(vector\u0026lt;int\u0026gt;\u0026amp; preorder, vector\u0026lt;int\u0026gt;\u0026amp; inorder) { init_map(inorder); int left = 0; int right = inorder.size() - 1; int mid = node_idx[preorder[0]]; int left_len = mid - left; int right_len = right - mid; TreeNode* root = new TreeNode(preorder[0]); root-\u0026gt;left = innerBuildTree(preorder, inorder, left, mid - 1, left + 1, left + left_len); root-\u0026gt;right = innerBuildTree(preorder, inorder, mid + 1, right, left + left_len + 1, right); return root; } private: unordered_map\u0026lt;int, int\u0026gt; node_idx; void init_map(vector\u0026lt;int\u0026gt;\u0026amp; inorder) { for (int i = 0; i \u0026lt; inorder.size(); ++i) { node_idx[inorder[i]] = i; } } TreeNode* innerBuildTree(vector\u0026lt;int\u0026gt;\u0026amp; preorder, vector\u0026lt;int\u0026gt;\u0026amp; inorder, int left, int right, int pre_left, int pre_right) { if (left \u0026gt; right || pre_left \u0026gt; pre_right) { return nullptr; } int mid = node_idx[preorder[pre_left]]; int left_len = mid - left; int right_len = right - mid; TreeNode* node = new TreeNode(inorder[mid]); node-\u0026gt;left = innerBuildTree(preorder, inorder, left, mid - 1, pre_left + 1, pre_left + left_len); node-\u0026gt;right = innerBuildTree(preorder, inorder, mid + 1, right, pre_left + left_len + 1, pre_right); return node; } }; ","date":"2024-11-28T10:30:58+08:00","permalink":"https://alvincat.github.io/post/data_structure/binary_tree/binary_tree_create/","tags":["二叉树"],"title":"创建二叉树的方法"},{"categories":["数据结构"],"contents":"本文介绍二叉树的遍历方法和具体代码实现。\n1 二叉树的遍历方法 二叉树的遍历方法根据访问根结点的先后顺序分为先序、中序、后序遍历。\n下面1.1，1.2，1.3节将分别介绍各种遍历方式的递归实现和非递归实现方法。\n1.1 二叉树的先序遍历 二叉树先序遍历的过程为：遍历根结点，先序遍历左子树，先序遍历右子树。\n1.1.1 二叉树先序遍历的递归实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public: vector\u0026lt;int\u0026gt; preorderTraversal(TreeNode* root) { preorder(root); return res; } void preorder(TreeNode* root) { if (root == NULL) { return; } res.push_back(root-\u0026gt;val); preorder(root-\u0026gt;left); preorder(root-\u0026gt;right); } private: vector\u0026lt;int\u0026gt; res; }; 1.1.2 二叉树先序遍历的非递归实现 先序遍历的非递归实现方式采用DFS的遍历算法，使用栈来保存中间结果。\n方法1：传统方式，首先将根结点添加至栈中，然后循环添加根结点的左孩子结点。\n当左孩子为空时，弹出栈顶结点，并将栈顶的右孩子结点作为根结点重复进行该过程。\n因为是先序遍历，因此所有结点在进栈前进行访问。具体代码如下所示： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public: vector\u0026lt;int\u0026gt; preorderTraversal(TreeNode* root) { vector\u0026lt;int\u0026gt; res; if (root == NULL) { return res; } stack\u0026lt;TreeNode*\u0026gt; stk; TreeNode* top = root; while (!stk.empty() || top) { while (top) { res.push_back(top-\u0026gt;val); stk.push(top); top = top-\u0026gt;left; } top = stk.top(); stk.pop(); top = top-\u0026gt;right; } return res; } }; 方法2：因为栈的特性是后进先出。入栈和出栈的顺序相反，因此可以利用这一特性简化代码流程：\n具体方法为：在根结点出栈前进行访问，然后分别将其右孩子和左孩子进栈。循环进行，直到栈为空为止。\n这样就会在访问的时候先访问左孩子再访问右孩子。具体实现方式如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public: vector\u0026lt;int\u0026gt; preorderTraversal(TreeNode* root) { vector\u0026lt;int\u0026gt; res; if (root == NULL) { return res; } stack\u0026lt;TreeNode*\u0026gt; stk; stk.push(root); while (!stk.empty()) { TreeNode* top = stk.top(); res.push_back(top-\u0026gt;val); stk.pop(); if (top-\u0026gt;right) { stk.push(top-\u0026gt;right); } if (top-\u0026gt;left) { stk.push(top-\u0026gt;left); } } return res; } }; 1.2 二叉树的中序遍历 二叉树先序遍历的过程为：中序序遍历左子树，遍历根结点，中序遍历右子树。\n1.2.1 二叉树的中序遍历的递归实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public: vector\u0026lt;int\u0026gt; inorderTraversal(TreeNode* root) { vector\u0026lt;int\u0026gt; res; inorder(root, res); return res; } void inorder(TreeNode* root, vector\u0026lt;int\u0026gt;\u0026amp; res) { if (root == nullptr) { return; } if (root-\u0026gt;left != nullptr) { inorder(root-\u0026gt;left, res); } res.emplace_back(root-\u0026gt;val); if (root-\u0026gt;right != nullptr) { inorder(root-\u0026gt;right, res); } } }; 1.2.2 二叉树的中序遍历的非递归实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public: vector\u0026lt;int\u0026gt; inorderTraversal(TreeNode* root) { vector\u0026lt;int\u0026gt; res; if (root == NULL) { return res; } stack\u0026lt;TreeNode*\u0026gt; stk; TreeNode* top = root; while (!stk.empty() || top) { while (top) { stk.push(top); top = top-\u0026gt;left; } top = stk.top(); res.push_back(top-\u0026gt;val); stk.pop(); top = top-\u0026gt;right; } return res; } }; 1.3 二叉树的后序遍历 二叉树先序遍历的过程为：中序序遍历左子树，遍历根结点，中序遍历右子树。\n1.3.1 二叉树的后序遍历的递归实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public: vector\u0026lt;int\u0026gt; postorderTraversal(TreeNode* root) { vector\u0026lt;int\u0026gt; res; postorder(root, res); return res; } void postorder(TreeNode* root, vector\u0026lt;int\u0026gt;\u0026amp; vec) { if (root == nullptr) { return; } postorder(root-\u0026gt;left, vec); postorder(root-\u0026gt;right, vec); vec.push_back(root-\u0026gt;val); } }; 1.3.2 二叉树的后序遍历的非递归实现 方法1：传统方法+访问标记 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public: vector\u0026lt;int\u0026gt; postorderTraversal(TreeNode* root) { vector\u0026lt;int\u0026gt; res; if (root == nullptr) { return res; } stack\u0026lt;pair\u0026lt;TreeNode*, bool\u0026gt;\u0026gt; stk; TreeNode* top = root; while (!stk.empty() || top) { while (top) { auto new_node = std::make_pair(top, false); stk.push(new_node); top = top-\u0026gt;left; } pair\u0026lt;TreeNode*, bool\u0026gt; head = stk.top(); stk.pop(); TreeNode* node = head.first; int sign = head.second; if (sign == false) { head.second = true; stk.push(head); top = node-\u0026gt;right; } else { res.push_back(node-\u0026gt;val); top = nullptr; } } return res; } }; 方法2：使用两个栈\n该方法类似于先序遍历的非递归方式中的方法2。\n只是为了得到中-右-左的序列，因此是先让左孩子入栈，再让右孩子入栈。\n最终的得到的序列和目标序列顺序相反，在使用一个栈将顺序调整过来即可。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public: vector\u0026lt;int\u0026gt; postorderTraversal(TreeNode* root) { vector\u0026lt;int\u0026gt; res; if (root == nullptr) { return res; } stack\u0026lt;TreeNode*\u0026gt; stk; stack\u0026lt;TreeNode*\u0026gt; stk_sec; stk.push(root); while (!stk.empty()) { TreeNode* top = stk.top(); stk.pop(); stk_sec.push(top); if (top-\u0026gt;left) { stk.push(top-\u0026gt;left); } if (top-\u0026gt;right) { stk.push(top-\u0026gt;right); } } while (!stk_sec.empty()) { TreeNode* top = stk_sec.top(); res.push_back(top-\u0026gt;val); stk_sec.pop(); } return res; } }; 方法3：使用一个栈\n原理同方法2：但是是通过特殊的先序遍历(遍历的方式为中-右-左的方式)的方式得到中-右-左的序列。 然后将得到的序列翻转一下即可。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public: vector\u0026lt;int\u0026gt; postorderTraversal(TreeNode* root) { vector\u0026lt;int\u0026gt; res; if (root == nullptr) { return res; } stack\u0026lt;TreeNode*\u0026gt; stk; TreeNode* top = root; while (!stk.empty() || top) { while (top) { res.push_back(top-\u0026gt;val); stk.push(top); top = top-\u0026gt;right; } top = stk.top(); stk.pop(); top = top-\u0026gt;left; } reverse(res.begin(), res.end()); return res; } }; 1.4 二叉树的层次遍历 二叉树的层次遍历实际上是对二叉树的广度优先遍历。\n原理参考BFS原理的讲解。具体代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; levelOrder(TreeNode* root) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res; if (root == NULL) { return res; } queue\u0026lt;TreeNode*\u0026gt; que_level; que_level.push(root); while (!que_level.empty()) { int que_size = que_level.size(); vector\u0026lt;int\u0026gt; level_vec; for (int i = 0; i \u0026lt; que_size; ++i) { TreeNode* head = que_level.front(); if (head-\u0026gt;left) { que_level.push(head-\u0026gt;left); } if (head-\u0026gt;right) { que_level.push(head-\u0026gt;right); } level_vec.push_back(head-\u0026gt;val); que_level.pop(); } res.push_back(level_vec); level_vec.clear(); } return res; } }; 2 二叉树的遍历方法总结 二叉树的前序中序、后序遍历都属于深度优先遍历(DFS)，而层次遍历属于广度优先遍历(BFS)。\n深度优先遍历需要使用栈作为存储中间过程的数据结构，而广度优先遍历需要使用队列作为中间过程的数据结构。 通过1.1,1.2,1.3的递归实现和非递归实现，我们不难发现。\n三种递归遍历方式实现代码较为简洁，三种遍历的方式的差异在于访问根结点的时机。迭代是访问根结点的时机和对应的遍历方式对应。\n三种非递归方式的实现都有可以使用传统遍历框架，区别在于访问结点的差异：\n先序遍历：先访问结点，再放入栈； 中序遍历：先放入栈，出栈时再访问结点； 后序遍历：增加标记，结点进栈两次，第二次出栈时再访问结点； 先序遍历和后续遍历：可以通过栈后进先出的特性调整顺序，简化操作。\n","date":"2024-11-27T11:11:07+08:00","permalink":"https://alvincat.github.io/post/data_structure/binary_tree/binary_tree_traverse/","tags":["二叉树"],"title":"二叉树的遍历"},{"categories":["算法"],"contents":"本文讲解DFS算法的核心思想和代码基本框架。\n1 DFS算法的核心思想 DFS的英文全称为(Depth-first search),称为深度优先搜索算法。 该算法是用于在树形结构中按照某种规则搜索结点的算法。\n该算法的核心思想是从起始点出发，沿着某一条路径一直向前搜索，直到没有路径后结束。然后再回到起点继续遍历还未遍历的结点，直到遍历完所有结点。\n","date":"2024-11-26T16:31:22+08:00","permalink":"https://alvincat.github.io/post/algorithm/dfs/","tags":["DFS"],"title":"遍历-DFS"},{"categories":["算法"],"contents":"本文讲解BFS算法的核心思想和代码基本框架。\n1 BFS算法的核心思想 BFS的英文全称为(Breadth-first search),称为广度优先搜索算法。 该算法是用于在树形结构中按照某种规则搜索结点的算法。 该算法的核心思想是从起始点出发，依次遍历完起始点周围的结点，不断重复该过程直至扩散至所有结点。\n2 BFS算法的代码框架 基于BFS的特点：代码实现时，采用队列来保存每一轮迭代的结果。\n首次将起始点或初始状态的结点插入队列。 在出队列时，将和该结点关联的结点进队。 操作结束的条件：队列为空。 温馨提示：\n若需要区分每层遍历的结果，可以通过记录队列中元素的个数来实现。\n1 2 3 4 5 6 7 8 9 10 queue.push(root); while (!queue.empty()) { int size = 0; for (int idx = 0; idx \u0026lt; size; ++i) { head = queue.front(); xxx;// 执行和队列头部相关的操作 queue.push(head-\u0026gt;child); queue.pop(); } } ","date":"2024-11-26T16:29:32+08:00","permalink":"https://alvincat.github.io/post/algorithm/bfs/","tags":["BFS"],"title":"遍历-BFS"},{"categories":["操作系统"],"contents":"本文总结Linux系统启动的详细流程以及启动流程涉及的基础知识。\n1 Linux系统的传统启动流程 主机上电，运行BIOS MBR 进入引导程序(GRUB） 运行kernel init 2 BIOS和UEFI BIOS(Basic Input Output System) UEFI(Unified Extensible Firmware Interface)\n3 MBR和GPT MBR(Master Boot Record), GPT (GUID Partition Table),\n4 引导程序简介 5 常见linux发布版本启动的差异(CentOS/Ubuntu)","date":"2024-11-20T20:56:16+08:00","permalink":"https://alvincat.github.io/post/operating_system/linux_kernel/kernel_boot_process/","tags":["kernel_boot_process"],"title":"Kernel_boot_process"},{"categories":["Linux"],"contents":"本文记录Linux系统常用的系统设置的方法。\n1 Linux系统配置coredump的方法 1.1 临时配置方法 设置ulimit中core大小限制 执行命令：ulimit -c unlimited\n配置coredump的生成路径 执行命令：echo \u0026quot;/path/core-%e-%p-%s-%t\u0026quot; \u0026gt; /proc/sys/kernel/core_pattern\n该配置方法，当系统重启后就会失效。\n1.2 永久配置方法 配置当前用户的corefile size大小 在配置文件中增加一行配置项，如下所示： 1 2 #\u0026lt;domain\u0026gt; \u0026lt;type\u0026gt; \u0026lt;item\u0026gt; \u0026lt;value\u0026gt; root hard core 100000 其中，对于item为core的配置项，value的单位为KB.\n然后再/etc/profile文件中增加配置： 1 2 # No core files by default ulimit -S -c unlimited \u0026gt; /dev/null 2\u0026gt;\u0026amp;1 然后再进程的启动脚本中添加如下命令： 1 echo \u0026#34;/path/core-%e-%p-%s-%t\u0026#34; \u0026gt; /proc/sys/kernel/core_pattern 参考文档：\nHow to enable core file dumps when an application crashes or segmentation faults\n2 修改Hostname 1 hostnamectl set-hostname new_host_name ","date":"2024-11-19T15:48:31+08:00","permalink":"https://alvincat.github.io/post/linux/linux_common_setting/","tags":["linux系统设置"],"title":"Linux系统常用的系统配置"},{"categories":["Linux"],"contents":"本文记录vim常用参数的配置方法已经常用命令。\n1.1 vim常用设置 1.1 增加vim配置文件的方法 新建~/.vimrc文件。\n1.2 vim 常用设置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 \u0026#34; Turn syntax highlighting on. syntax on \u0026#34; Add numbers to each line on the left-hand side. set number \u0026#34; Highlight cursor line underneath the cursor horizontally. set cursorline \u0026#34; Highlight cursor line underneath the cursor vertically. \u0026#34;set cursorcolumn \u0026#34; Set shift width to 4 spaces. set shiftwidth=4 \u0026#34; Set tab width to 4 columns. set tabstop=4 \u0026#34; Use space characters instead of tabs. set expandtab \u0026#34; Do not save backup files. set nobackup \u0026#34; Do not let cursor scroll below or above N number of lines when scrolling. set scrolloff=10 \u0026#34; Do not wrap lines. Allow long lines to extend as far as the line goes. set nowrap \u0026#34; While searching though a file incrementally highlight matching characters as you type. set incsearch \u0026#34; Ignore capital letters during search. \u0026#34;set ignorecase \u0026#34; Override the ignorecase option if searching for capital letters. \u0026#34; This will allow you to search specifically for capital letters. set smartcase \u0026#34; Show partial command you type in the last line of the screen. set showcmd \u0026#34; Show the mode you are on the last line. set showmode \u0026#34; Show matching words during a search. set showmatch \u0026#34; Use highlighting when doing a search. set hlsearch \u0026#34; Set the commands to save in history default number is 20. set history=1000 \u0026#34; set autoindent \u0026#34; Set c language auto indent set cindent 参考文档:\nVimrc Configuration Guide - How to Customize Your Vim Code Editor with Mappings, Vimscript, Status Line, and More\n2 vim常用命令 2.1 vim替换字符串命令 替换当前行\n命令：:s/foo/bar/g\n替换第 n 行开始到最后一行中字符串\n命令： n,$s/foo/bar/\n替换文件中所有行的字符串\n命令：:%s/foo/bar/g\n2.2 vim直接输入tab的方法 因为在vim配置文件中配置tab键转换为4个空格，因此在编写makefile时直接按tab间无法达到输入tab的目的。\n在编辑模式或者命令模式下(界面最下方有冒号)，先按快捷键ctrl+v，然后按tab键即可。\n","date":"2024-11-19T15:17:40+08:00","permalink":"https://alvincat.github.io/post/linux/tools/vim_usful_setting/","tags":["vim"],"title":"Vim常用设置以及常用命令"},{"categories":["Linux"],"contents":"本文记录Ubutun操作系统常用的系统配置的设置方法和常用命令的用法。\n1 ubuntu系统配置apt源的方法 备份/etc/apt/sources.list文件 mv /etc/apt/sources.list /etc/apt/sourses.list.backup\n新建/etc/apt/sources.list文件并添加以下内容\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #163源 deb http://mirrors.163.com/ubuntu/ bionic main restricted universe multiverse deb http://mirrors.163.com/ubuntu/ bionic-security main restricted universe multiverse deb http://mirrors.163.com/ubuntu/ bionic-updates main restricted universe multiverse deb http://mirrors.163.com/ubuntu/ bionic-proposed main restricted universe multiverse deb http://mirrors.163.com/ubuntu/ bionic-backports main restricted universe multiverse deb-src http://mirrors.163.com/ubuntu/ bionic main restricted universe multiverse deb-src http://mirrors.163.com/ubuntu/ bionic-security main restricted universe multiverse deb-src http://mirrors.163.com/ubuntu/ bionic-updates main restricted universe multiverse deb-src http://mirrors.163.com/ubuntu/ bionic-proposed main restricted universe multiverse deb-src http://mirrors.163.com/ubuntu/ bionic-backports main restricted universe multiverse #中科大源 deb https://mirrors.ustc.edu.cn/ubuntu/ bionic main restricted universe multiverse deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-security main restricted universe multiverse deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic main restricted universe multiverse deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-security main restricted universe multiverse deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse #阿里云源 deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse #清华源 deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse 2 apt常用命令 1 2 3 4 5 6 7 8 apt-get update # 更新源 apt-get install package # 安装包 apt-get remove package # 删除包 apt-get upgrade # 更新已安装的包 apt-cache search package # 查询软件包 apt list --installed # 查询系统已安装的软件包 3 Ubuntu设置root登陆的方法 使用安装系统时的高级用户解锁root用户 1 sudo passwd root 设置root用户密码： 1 sudo passwd -u root 切换到root用户，执行命令：su\n解除root用户登陆限制： 打开文件/etc/ssh/sshd_config, 找如下内容：\n1 2 3 4 5 #LoginGraceTime 2m #PermitRootLogin prohibit-password #StrictModes yes #MaxAuthTries 6 #MaxSessions 10 然后将配置修改为：\n1 2 3 4 5 LoginGraceTime 2m PermitRootLogin yes StrictModes yes MaxAuthTries 3 MaxSessions 10 然后重启ssh服务：systemctl restart ssh.service ","date":"2024-11-19T15:17:20+08:00","permalink":"https://alvincat.github.io/post/linux/ubuntu_setting/","tags":["ubuntu"],"title":"Ubuntu系统常用设置和命令"},{"categories":["数据结构"],"contents":"本文介绍LRU的原理和具体c代码实现。\nLRU的英文全称为Least Recently Used，即最近最少使用。该算法为cache淘汰算法，将最近最少使用的元素淘汰掉。具体代码是由hashTable和一个双向链表实现的。\n使用双向链表存放key-value，使用哈希表存储双向链表的结点地址，保证访问结点的复杂度为 $O(1)$。通常来讲，对数据的读写都算做对数据的访问。\n1 LRU的C代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;assert.h\u0026gt; /* define struct start */ #define FREE(ptr) \\ free(ptr); \\ ptr = NULL; typedef int KEY; typedef int VAL; typedef struct ForwardListNode { KEY key; VAL val; struct ForwardListNode* prev; struct ForwardListNode* next; } ForwardListNode; typedef struct HashNode { ForwardListNode* dNode; struct HashNode* next; } HashNode; typedef struct HashTable { HashNode** bucket; int (*destroy)(struct HashTable* tb); int (*hash)(struct HashTable* tb, KEY key); int (*insert)(struct HashTable* tb, HashNode* node); int (*remove)(struct HashTable* tb, KEY key); HashNode* (*find)(struct HashTable* tb, KEY key); int bucket_num; } HashTable; typedef struct { ForwardListNode* head; HashTable* ht; int capacity; int size; } LRUCache; /* ------------------------ */ /* LinkList function start */ int insertListNode(HashNode** head, HashNode* node) { if (*head == NULL) { *head = node; return 0; } node-\u0026gt;next = *head; *head = node; return 0; } int removeListNode(HashNode** head, HashNode* node) { if (*head == node) { *head = (*head)-\u0026gt;next; FREE(node); return 0; } HashNode* prev = *head; HashNode* cur = (*head)-\u0026gt;next; while (cur) { if (cur == node) { prev-\u0026gt;next = cur-\u0026gt;next; FREE(node); return 0; } prev = prev-\u0026gt;next; cur = cur-\u0026gt;next; } return -1; } HashNode* findListNode(HashNode* head, KEY key) { if (head == NULL) { return NULL; } while (head) { if (head-\u0026gt;dNode-\u0026gt;key == key) { return head; } head = head-\u0026gt;next; } return NULL; } void ListNodeDestroy(HashNode* head) { if (head == NULL) { return; } HashNode* cur = head; while (cur) { HashNode* prev = cur-\u0026gt;next; FREE(cur); cur = prev; } } /* ------------------------ */ /* HashTable function */ HashNode* initHashNode(ForwardListNode* node) { HashNode* hNode = (HashNode*)malloc(sizeof(HashNode)); if (hNode == NULL) { return NULL; } hNode-\u0026gt;dNode = node; hNode-\u0026gt;next = NULL; return hNode; } int hashFunc(HashTable* tb, KEY key) { return key % tb-\u0026gt;bucket_num; } HashNode* findHashNode(HashTable* tb, KEY key) { int index = tb-\u0026gt;hash(tb, key); assert(index \u0026gt;= 0 \u0026amp;\u0026amp; index \u0026lt; tb-\u0026gt;bucket_num); return findListNode(tb-\u0026gt;bucket[index], key); } int insertHashNode(HashTable* tb, HashNode* node) { int index = tb-\u0026gt;hash(tb, node-\u0026gt;dNode-\u0026gt;key); assert(index \u0026gt;= 0 \u0026amp;\u0026amp; index \u0026lt; tb-\u0026gt;bucket_num); return insertListNode(\u0026amp;tb-\u0026gt;bucket[index], node); } int removeHashNode(HashTable* tb, KEY key) { int index = tb-\u0026gt;hash(tb, key); assert(index \u0026gt;= 0 \u0026amp;\u0026amp; index \u0026lt; tb-\u0026gt;bucket_num); if (tb-\u0026gt;bucket[index] == NULL) { return -1; } HashNode** head = \u0026amp;tb-\u0026gt;bucket[index]; HashNode* node = findListNode(*head, key); return removeListNode(head, node); } HashTable* initHashTableMem(void) { HashTable* ht = (HashTable*)malloc(sizeof(HashTable)); if (ht == NULL) { return NULL; } memset(ht, 0, sizeof(HashTable)); return ht; } int destroyHashTable(struct HashTable* tb) { for (int i = 0; i \u0026lt; tb-\u0026gt;bucket_num; ++i) { HashNode* head = tb-\u0026gt;bucket[i]; if (head == NULL) { continue; } ListNodeDestroy(head); } FREE(tb-\u0026gt;bucket); FREE(tb); return 0; } int initializeHashTable(struct HashTable* tb, int num) { tb-\u0026gt;hash = hashFunc; tb-\u0026gt;insert = insertHashNode; tb-\u0026gt;remove = removeHashNode; tb-\u0026gt;find = findHashNode; tb-\u0026gt;destroy = destroyHashTable; if (num == 0) { printf(\u0026#34;input bucket num must greater then 0.\\n\u0026#34;); return -1; } tb-\u0026gt;bucket_num = num; tb-\u0026gt;bucket = (HashNode**)malloc(sizeof(HashNode*) * num); if (tb-\u0026gt;bucket == NULL) { printf(\u0026#34;malloc failed.\\n\u0026#34;); return -1; } memset(tb-\u0026gt;bucket, 0, sizeof(HashNode*) * num); return 0; } /*------------------------------------------*/ /* forward_list function */ ForwardListNode* initForwardListNode(KEY key, VAL val) { ForwardListNode* DNode = (ForwardListNode*)malloc(sizeof(ForwardListNode)); if (DNode == NULL) { return NULL; } DNode-\u0026gt;key = key; DNode-\u0026gt;val = val; DNode-\u0026gt;prev = DNode; DNode-\u0026gt;next = DNode; return DNode; } void insertToHead(ForwardListNode* head, ForwardListNode* node) { if (head-\u0026gt;next != head) { node-\u0026gt;next = head-\u0026gt;next; head-\u0026gt;next-\u0026gt;prev = node; head-\u0026gt;next = node; node-\u0026gt;prev = head; } else { head-\u0026gt;next = node; head-\u0026gt;prev = node; node-\u0026gt;prev = head; node-\u0026gt;next = head; } } void removeFromTail(ForwardListNode* head) { if (head-\u0026gt;next != head) { ForwardListNode* tail = head-\u0026gt;prev; tail-\u0026gt;next-\u0026gt;prev = tail-\u0026gt;prev; tail-\u0026gt;prev-\u0026gt;next = tail-\u0026gt;next; FREE(tail); } } void updateForwardList(ForwardListNode* head, ForwardListNode* node) { if (head == NULL) { return; } node-\u0026gt;prev-\u0026gt;next = node-\u0026gt;next; node-\u0026gt;next-\u0026gt;prev = node-\u0026gt;prev; insertToHead(head, node); } void destroyForwardListNode(ForwardListNode* head) { if (head == NULL) { return; } ForwardListNode* cur = head-\u0026gt;next; while (cur \u0026amp;\u0026amp; cur != head) { ForwardListNode* next = cur-\u0026gt;next; FREE(cur); cur = next; } FREE(head); } /*------------------------------------------*/ /* LRUCache function */ LRUCache* lRUCacheCreate(int capacity) { LRUCache* lru = (LRUCache*)malloc(sizeof(LRUCache)); if (lru == NULL) { return NULL; } memset(lru, 0, sizeof(LRUCache)); lru-\u0026gt;head = initForwardListNode(-1, -1); if (lru-\u0026gt;head == NULL) { FREE(lru); } lru-\u0026gt;ht = initHashTableMem(); if (lru-\u0026gt;ht == NULL) { FREE(lru-\u0026gt;head); FREE(lru); return NULL; } int ret = initializeHashTable(lru-\u0026gt;ht, capacity); if (ret != 0) { FREE(lru-\u0026gt;ht); FREE(lru-\u0026gt;head); FREE(lru); return NULL; } lru-\u0026gt;size = 0; lru-\u0026gt;capacity = capacity; return lru; } int lRUCacheGet(LRUCache* obj, int key) { HashTable* ht = obj-\u0026gt;ht; ForwardListNode* DouList = obj-\u0026gt;head; HashNode* node = ht-\u0026gt;find(ht, key); if (node == NULL) { return -1; } updateForwardList(DouList, node-\u0026gt;dNode); return node-\u0026gt;dNode-\u0026gt;val; } void lRUCachePut(LRUCache* obj, int key, int value) { HashTable* ht = obj-\u0026gt;ht; ForwardListNode* DouListHead = obj-\u0026gt;head; int index = ht-\u0026gt;hash(ht, key); HashNode* hNode = findListNode(ht-\u0026gt;bucket[index], key); if (hNode == NULL) { ForwardListNode* dNode = initForwardListNode(key, value); if (dNode == NULL) { printf(\u0026#34;mem alloc failed.\\n\u0026#34;); return; } HashNode* new_node = initHashNode(dNode); if (new_node == NULL) { FREE(dNode); printf(\u0026#34;mem alloc failed.\\n\u0026#34;); return; } insertToHead(DouListHead, dNode); insertListNode(\u0026amp;ht-\u0026gt;bucket[index], new_node); ++obj-\u0026gt;size; // del node from tail if (obj-\u0026gt;size \u0026gt; obj-\u0026gt;capacity) { ForwardListNode* tail = DouListHead-\u0026gt;prev; ht-\u0026gt;remove(ht, tail-\u0026gt;key); removeFromTail(DouListHead); obj-\u0026gt;size--; } } else { if (hNode-\u0026gt;dNode-\u0026gt;val != value) { hNode-\u0026gt;dNode-\u0026gt;val = value; } updateForwardList(DouListHead, hNode-\u0026gt;dNode); } } void lRUCacheFree(LRUCache* obj) { destroyForwardListNode(obj-\u0026gt;head); obj-\u0026gt;ht-\u0026gt;destroy(obj-\u0026gt;ht); FREE(obj); } 1.1 关键函数功能简介 LRU的代码实现可以分为4部分。\n1.1.1 单向链表的操作 int insertListNode(HashNode** head, HashNode* node)\n功能说明：向单链表的头部插入一个结点\nint removeListNode(HashNode** head, HashNode* node)\n功能说明：从单链表中移出指定的结点\nHashNode* findListNode(HashNode* head, KEY key)\n功能说明： 在单链表中查找包含指定key的结点\nvoid ListNodeDestroy(HashNode* head)\n功能说明：销毁单链表\n1.1.2 双向链表的操作 ForwardListNode* initForwardListNode(KEY key, VAL val)\n功能说明：构造双向链表的结点。\nvoid insertToHead(ForwardListNode* head, ForwardListNode* node)\n功能说明：向双向链表的头部插入一个结点。\nvoid removeFromTail(ForwardListNode* head)\n功能说明：从双向链表的尾部删除一个结点\nvoid updateForwardList(ForwardListNode* head, ForwardListNode* node)\n功能说明：更新双向链表中的结点，即将指定结点移动到双向链表的头部。\nvoid destroyForwardListNode(ForwardListNode* head)\n功能说明：销毁双向链表\n温馨提示：\n双向链表的遍历操作和单向链表不同,通过判断cur == head作为判断循环终止的条件。\n1.1.3 哈希表的操作 HashNode* initHashNode(ForwardListNode* node)\n功能说明：初始化哈希表的结点\nint hashFunc(HashTable* tb, KEY key)\n功能说明：哈希函数\nHashNode* findHashNode(HashTable* tb, KEY key)\n功能说明：根据key查找哈希结点\nint insertHashNode(HashTable* tb, HashNode* node)\n功能说明： 插入一个哈希结点\nint removeHashNode(HashTable* tb, KEY key)\n功能说明： 删除一个哈希结点\nHashTable* initHashTableMem(void)\n功能说明： 初始化哈希表\nint destroyHashTable(struct HashTable* tb)\n功能说明： 销毁哈希表\nint initializeHashTable(struct HashTable* tb, int num)\n功能说明： 初始化哈希表中的成员\n1.1.4 LRU相关的操作 LRUCache* lRUCacheCreate(int capacity)\n功能说明：创建LRU\nint lRUCacheGet(LRUCache* obj, int key)\n功能说明：查询lru中是否存在key\nvoid lRUCachePut(LRUCache* obj, int key, int value)\n功能说明：向LRU中插入指定的key-value\nvoid lRUCacheFree(LRUCache* obj)\n功能说明： 销毁LRU\n2 LRU程序的测试代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 void printHashTable(HashTable* tb); void printLruCache(LRUCache* lru); int main(void) { LRUCache* lru = lRUCacheCreate(2); printf(\u0026#34;Put (1,1) \u0026#34;); lRUCachePut(lru, 1, 1); printLruCache(lru); printf(\u0026#34;Put (2,2) \u0026#34;); lRUCachePut(lru, 2, 2); printLruCache(lru); printf(\u0026#34;Get 1 \u0026#34;); int ret = lRUCacheGet(lru, 1); printf(\u0026#34;get(1) ret:%d.\\n\u0026#34;, ret); printLruCache(lru); printf(\u0026#34;Put (3,3) \u0026#34;); lRUCachePut(lru, 3, 3); printLruCache(lru); printf(\u0026#34;Get 2 2 \u0026#34;); ret = lRUCacheGet(lru, 2); printf(\u0026#34;get(2) ret:%d.\\n\u0026#34;, ret); printLruCache(lru); printf(\u0026#34;Put (4,4) \u0026#34;); lRUCachePut(lru, 4, 4); printLruCache(lru); printf(\u0026#34;Get 1 \u0026#34;); ret = lRUCacheGet(lru, 1); printf(\u0026#34;get(1) ret:%d.\\n\u0026#34;, ret); printLruCache(lru); printf(\u0026#34;Put (3,3) \u0026#34;); lRUCachePut(lru, 3, 3); printLruCache(lru); lRUCacheFree(lru); return 0; } void printLruCache(LRUCache* lru) { DouListNode* cur = lru-\u0026gt;head-\u0026gt;next; printf(\u0026#34;LRUCache num: %d.\\n\u0026#34;, lru-\u0026gt;size); while (cur != lru-\u0026gt;head) { printf(\u0026#34;[%d|%d|-]-\u0026gt;\u0026#34;, cur-\u0026gt;key, cur-\u0026gt;val); cur = cur-\u0026gt;next; } printf(\u0026#34;\\n\\n\u0026#34;); return; } void printListNode(HashNode* head) { if (head == NULL) { return; } while (head) { printf(\u0026#34;[%d|%d|-]-\u0026gt;\u0026#34;, head-\u0026gt;dNode-\u0026gt;key, head-\u0026gt;dNode-\u0026gt;val); head = head-\u0026gt;next; } printf(\u0026#34;\\n\u0026#34;); } void printHashTable(HashTable* tb) { for (int i = 0; i \u0026lt; tb-\u0026gt;bucket_num; ++i) { HashNode* head = tb-\u0026gt;bucket[i]; if (head == NULL) { continue; } printf(\u0026#34;index：%d, \u0026#34;, i); printListNode(head); } } ","date":"2024-11-18T17:06:55+08:00","permalink":"https://alvincat.github.io/post/data_structure/hash_table/lru/","tags":["哈希表","单向链表","双向链表"],"title":"LRU的C代码实现"},{"categories":["Linux"],"contents":"本文主要记录c语言编码过程中的一些注意事项。\n1 C语言编码注意事项 1.1 申请的动态内存一定要做初始化工作 例如：如下所示的代码，若未对table-\u0026gt;bucket指针数组赋初值，该数组中就有可能存在非法值，导致代码访问到非法内存。\n1 2 3 4 5 6 7 8 9 10 11 12 int initHashTable(HashTable* table, int bucket_num) { table-\u0026gt;bucket_num = bucket_num; table-\u0026gt;bucket = (HashNode**)malloc(sizeof(HashNode*) * bucket_num); if (table-\u0026gt;bucket == NULL) { printf(\u0026#34;Alloc memory failed.\\n\u0026#34;); return -1; } // 此处一定要做初始化工作，否则可能存在非法内存访问的情况 memset(table-\u0026gt;bucket, 0, sizeof(HashNode*) * bucket_num); return 0; } 1.2 对结构体变量初始化时，需要初始化所有的变量 实例如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 struct ListNode { int val; struct ListNode *next; }; ListNode* initNode(int val) { ListNode* node = (ListNode*)malloc(sizeof(ListNode)); if (node == NULL) { return NULL; } node-\u0026gt;val = val; // 注意此处一定要初始化，否则有可能访问到非法内存 node-\u0026gt;next = NULL; } 2 c语言编译相关 2.1 C语言使用asan的方法 C语言使用asan的方法:\n环境安装和gcc版本对应的libasan版本。 编译代码时添加-fsanitize=address参数。 例如：\n1 gcc -Wall -g -std=c99 -fsanitize=address lru.c -o lru 备注：ubuntu系统中不同asan版本和gcc的对应关系。\nlibasan0: gcc-4.8 libasan2: gcc-5 libasan3: gcc-6 libasan4: gcc-7 libasan5: gcc-8 3 glibc源码阅读 3.1 实用gdb阅读glibc接口的方法 将glibc源码下载到本地，并解压。 在gdb中添加glibc源码路径； 方法1：在.gdbinit文件中添加命令directory glibc_src_path 方法2：gdb调试二进制时，增加-d参数:-d directory 3.2 理解glibc的简单方法：使用musl libc库 musl libc库实现了和glibc一样的功能，但是代码更简洁易懂。\n可以通过阅读这个代码理解glibc中接口是如何实现的。\nmusl libc库网址\n","date":"2024-11-17T21:39:06+08:00","permalink":"https://alvincat.github.io/post/linux/c_language_usful_tips/","tags":["c语言"],"title":"c语言编码注意事项"},{"categories":["数据结构"],"contents":"本文介绍哈希表的基本特性和具体实现。\n1 哈希表的基本特性 哈希表产生的背景：因为数组的数组的查找复杂度为$O(n)$, 为了\n2 哈希表(拉链法)的c语言实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;assert.h\u0026gt; #define FREE(ptr) \\ free(ptr); \\ ptr = NULL; typedef int KEY; typedef int VALUE; // hashTable的结点定义 struct HashNode { KEY key; VALUE value; struct HashNode* next; }; typedef struct HashNode HashNode; // hashTable的定义 struct HashTable { int (*initHashTable)(struct HashTable* table, int bucket_num); // init function void (*destroyHashTable)(struct HashTable* table); // destroy function int (*hashFunc)(struct HashTable* table, KEY key); // hash function HashNode* (*find)(struct HashTable* table, KEY key); // find function void (*insertHashNode)(struct HashTable* table, HashNode* node); // insert function HashNode** bucket; // bucket array int bucket_num; // bucket num }; typedef struct HashTable HashTable; int initHashTable(HashTable* table, int bucket_num) { table-\u0026gt;bucket_num = bucket_num; table-\u0026gt;bucket = (HashNode**)malloc(sizeof(HashNode*) * bucket_num); if (table-\u0026gt;bucket == NULL) { printf(\u0026#34;Alloc memory failed.\\n\u0026#34;); return -1; } memset(table-\u0026gt;bucket, 0, sizeof(HashNode*) * bucket_num); return 0; } HashNode* findLinkListNode(HashNode* head, KEY key) { if (head == NULL) { return NULL; } while (head) { if (head-\u0026gt;key == key) { return head; } head = head-\u0026gt;next; } return NULL; } void destroyLinkList(HashNode* head) { if (head == NULL) { return; } HashNode* cur = head-\u0026gt;next; while (cur) { HashNode* prev = cur-\u0026gt;next; head-\u0026gt;next = prev; FREE(cur); cur = head-\u0026gt;next; } } void destroyHashTable(HashTable* table) { int num = table-\u0026gt;bucket_num; HashNode** arr = table-\u0026gt;bucket; for (int i = 0; i \u0026lt; num; ++i) { if (arr[i]) { destroyLinkList(arr[i]); } } FREE(arr); FREE(table); } int hashFunc(HashTable* table, KEY key) { return key % table-\u0026gt;bucket_num; } HashNode* findHashNode(HashTable* table, KEY key) { int index = table-\u0026gt;hashFunc(table, key); assert(index \u0026gt;= 0 \u0026amp;\u0026amp; index \u0026lt; table-\u0026gt;bucket_num); return findLinkListNode(table-\u0026gt;bucket[index], key); } void insertHashNode(HashTable* table, HashNode* node) { if (node == NULL) { return; } int index = table-\u0026gt;hashFunc(table, node-\u0026gt;key); assert(index \u0026gt;= 0 \u0026amp;\u0026amp; index \u0026lt; table-\u0026gt;bucket_num); HashNode* head = table-\u0026gt;bucket[index]; if (head) { HashNode* prev = head-\u0026gt;next; node-\u0026gt;next = prev; head-\u0026gt;next = node; } else { table-\u0026gt;bucket[index] = node; } } HashTable* InitializeHashTable(void) { HashTable* table = (HashTable*)malloc(sizeof(HashTable)); if (table == NULL) { printf(\u0026#34;Melloc memory failed.\\n\u0026#34;); return NULL; } memset(table, 0, sizeof(HashTable)); table-\u0026gt;initHashTable = initHashTable; table-\u0026gt;destroyHashTable = destroyHashTable; table-\u0026gt;hashFunc = hashFunc; table-\u0026gt;findHashNode = findHashNode; table-\u0026gt;insertHashNode = insertHashNode; return table; } HashNode* initHashNode(KEY key, VALUE value) { HashNode* node = (HashNode*)malloc(sizeof(HashNode)); if (node == NULL) { printf(\u0026#34;Melloc memory failed.\\n\u0026#34;); return NULL; } node-\u0026gt;key = key; node-\u0026gt;value = value; node-\u0026gt;next = NULL; return node; } 3 哈希函数 针对key为整数的情况，直接使用对桶大小取余的方式就可以。但是针对复杂的key，例如key为一个链表结点的地址，就需要更加复杂的哈希函数。以下是针对复杂的key的哈希算法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 size_t _Hash_bytes(const void* ptr, size_t len, size_t seed) { size_t hash = seed; const uint8_t* cptr = (const uint8_t*)(ptr); for (; len; --len) { hash = (hash * 131) + *cptr++; } return hash; } int hashFunc(HashTable* table, KEY key) { const void* ptr = (const void*)(key); size_t hash = _Hash_bytes(ptr, 2, rand()); return abs(hash) % table-\u0026gt;bucket_num; } ","date":"2024-11-16T22:09:29+08:00","permalink":"https://alvincat.github.io/post/data_structure/hash_table/hash_table/","tags":["哈希表"],"title":"哈希表"},{"categories":["数据结构"],"contents":"本文主要介绍单链表常见的功能函数。\n1 单链表常见功能函数 链表相关的功能有：反转链表，获取链表的长度，获取链表的中间结点，判断两条链表是否相加，判断链表是否有环，合并两个有序链表等。\n1.1 翻转单链表 1.1.1 迭代方式翻转单链表 迭代方式翻转链表也称为链表头插法。\n方法1：新增一个临时头结点 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // 新增额外头结点的 struct ListNode* reverseList(struct ListNode* head) { if (head == NULL || head-\u0026gt;next == NULL) { return head; } struct ListNode* headp = (struct ListNode*)malloc(sizeof(struct ListNode)); headp-\u0026gt;val = 0; headp-\u0026gt;next = NULL; struct ListNode* tail = NULL; struct ListNode* cur = head; while (cur) { struct ListNode* pre = cur-\u0026gt;next; tail = headp-\u0026gt;next; headp-\u0026gt;next = cur; cur-\u0026gt;next = tail; cur = pre; } cur = headp-\u0026gt;next; free(headp); headp = NULL; return cur; } 方法2：不新增头结点，进行翻转 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 struct ListNode* reverseList(struct ListNode* head) { if (head == NULL || head-\u0026gt;next == NULL) { return head; } struct ListNode* cur = head-\u0026gt;next; head-\u0026gt;next = NULL; while (cur) { struct ListNode* pre = cur-\u0026gt;next; cur-\u0026gt;next = head; head = cur; cur = pre; } return head; } 1.1.2 递归方式翻转单链表 递归方式代码比较简单，但是要不太容易理解。递归的关键是抽象出一个通用的模型以及边界条件的处理。\n1 2 3 4 5 6 7 8 9 10 11 12 struct ListNode* reverseList(struct ListNode* head) { if (head == NULL || head-\u0026gt;next == NULL) { return head; } struct ListNode* prev = reverseList(head-\u0026gt;next); head-\u0026gt;next-\u0026gt;next = head; head-\u0026gt;next = NULL; return prev; } 1.2 获取单链表长度 1 2 3 4 5 6 7 8 9 10 11 12 13 14 int GetListNum(struct ListNode* head) { if (head == NULL) { return 0; } int cnt = 0; struct ListNode* tmp = head; while (tmp) { ++cnt; tmp = tmp-\u0026gt;next; } return cnt; } 1.3 获取单链表中间结点 功能说明：\n该函数返回链表中心点的前一个结点，即轴对称的尾结点。 例如，若链表有3个结点，则返回的是第1个结点的地址。若链表有4个结点，则返回的是第二个结点的地址。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 struct ListNode* GetMidNode(struct ListNode* head) { int cnt = GetListNum(head); int i = 0; tmp = head; struct ListNode* cur = NULL; while (i \u0026lt; cnt/2 \u0026amp;\u0026amp; tmp) { cur = tmp; tmp = tmp-\u0026gt;next; ++i; } return cur; } 1.4 判断单链表是否存在环 方法说明：\n方法1：使用hashtable。 方法2：使用快慢指针。具体方法是慢指针每次前进一步，快指针每次前进两步。若链表存在环，则经过若干步后，快指针肯定会追上慢指针，即两个指针指向同一个结点。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 bool hasCycle(struct ListNode *head) { if (head == NULL || head-\u0026gt;next == NULL) { return false; } struct ListNode* slow = head; struct ListNode* fast = head-\u0026gt;next; while (slow != fast) { if (fast == NULL || fast-\u0026gt;next == NULL) { return false; } slow = slow-\u0026gt;next; fast = fast-\u0026gt;next-\u0026gt;next; } return true; } 1.4.1 进阶：获取单链表环的入口结点 方法1：使用hashtable。 方法2：使用快慢指针。 2 链表高级特性 3 C++中的链表","date":"2024-11-16T21:29:14+08:00","permalink":"https://alvincat.github.io/post/data_structure/linklist/link_list_function/","tags":["链表"],"title":"单链表常见功能函数"},{"categories":[],"contents":"","date":"2024-11-16T15:35:21+08:00","permalink":"https://alvincat.github.io/search/","tags":[],"title":"站内搜索结果"},{"categories":["Linux"],"contents":"这篇文章介绍C语言结构体字节对齐的问题。\n1 结构体字节对齐的规则 结构体变量的首地址能够被其最宽基本类型成员的大小所整除；???\n数据类型自身的对齐：例如，在x86_64系统，char型数据自身对齐值为1字节，short型数据为2字节，int/float型为4字节，long/double/void*型为8字节。\n结构体或者类的自身的对齐：其成员中自身对齐值中的最大值。\n指定对齐值的情况下的对齐规则：#pragma pack (value)时的指定对齐值value。指定规则后以指定规则进行对齐。\n使用伪指令#pragma pack(n)：C编译器将按照n个字节对齐； 使用伪指令#pragma pack()： 取消自定义字节对齐方式。 数据成员、结构体和类的有效对齐值：若存在指定对齐值，需要自身对齐值和指定对齐值中较小者，即有效对齐值=min{自身对齐值，当前指定的pack值}。\n2 x86环境各种基本数据类型的字节数 数据类型 x86 x86_64 char 1 1 short 2 2 int 4 4 long 4 8 float 4 4 double 8 8 void* 4 8 3 示例程序 当前的实例程序假定结构体首地址为0。环境关键信息如下：\nArchithecture: x86_64\nGCC version: 4.4.7\n3.1 指定1字节对齐的示例分析 1 2 3 4 5 6 7 8 #pragma pack(1) struct test { char a; // not padding int b; // not pading short c; }; #pragma pack() sizeof(struct test); // 7 字节 说明：\n变量a，char自身对齐值为1, 指定值为1; 两者取小的值为1。首地址为0，变量a是对齐的，因此变量a占用1个字节。此时偏移1字节。\n变量b, int类型自身对齐值为4, 指定值为1，两者取小的偏移值为1。当前偏移1字节，因此变量b前不需要填充，b占用4字节。此时偏移5字节。\n变量c, short类型自身对齐值为2，指定值为1，两者取小的偏移单位为1。当前偏移5字节，因此变量c前也不需要填充，c占用2字节。此时偏移7字节。\n结构体自身的对齐值取最大变量的长度(int)，即4字节。但是指定的长度为1字节，两者取小即可得到整个结构体的对齐单位为1字节。因此，整个结构体占用7字节。\n3.2 指定2字节对齐的示例分析 1 2 3 4 5 6 7 8 #pragma pack(2) struct test { char a; // pading 1Byte int b; // not padding short c; }; #pragma pack() sizeof(struct test); // 8 字节 说明：\n变量a，char自身对齐值为1, 指定值为2; 两者取小的值为1。首地址为0，变量a是对齐的，因此变量a占用1个字节。此时偏移1字节。\n变量b, int类型自身对齐值为4, 指定值为2，两者取小的偏移值为2。当前偏移1字节，因此变量b前需要填充1字节，b占用4字节。此时偏移6字节。\n变量c, short类型自身对齐值为2，指定值为2，两者取小的偏移单位为2。当前偏移6字节，因此变量c前不需要填充，c占用2字节。此时偏移8字节。\n结构体自身的对齐值取最大变量的长度(int)，即4字节。但是指定的长度为2字节，两者取小即可得到整个结构体的对齐单位为2字节。当前偏移长度为8字节，已经是对齐单位整数倍，所以无需填充。因此，整个结构体占用8字节。\n3.3 指定4字节对齐的示例分析 1 2 3 4 5 6 7 8 #pragma pack(4) struct test { char a; int b; short c; }; #pragma pack() sizeof(struct test); // 12字节 说明： 变量a，char自身对齐值为1, 指定值为4; 两者取小的值为1。首地址为0，变量a默认是对齐的，因此变量a占用1个字节，无需填充。当前偏移1字节。\n变量b, int类型自身对齐值为4, 指定值为4，两者取小的偏移值为4。当前偏移1字节，因此变量b前需要填充3字节，b占用4字节。当前偏移8字节。\n变量c, short类型自身对齐值为2，指定值为4，两者取小的偏移单位为2。当前偏移8字节，因此变量c前不需要填充，c占用2字节。当前偏移10字节。\n结构体自身的对齐值取最大变量的长度(int)，即4字节。指定的长度为4字节，两者取小即可得到整个结构体的对齐单位为4字节。当前偏移长度为10字节，不是对齐单位整数倍，所以需要填充2字节。因此，整个结构体占用12字节。\n3.3 指定8字节对齐的示例分析 1 2 3 4 5 6 7 8 #pragma pack(8) struct test { char a; int b; short c; }; #pragma pack() sizeof(struct test); // 12字节 说明： 变量a，char自身对齐值为1, 指定值为8; 两者取小的值为1。首地址为0，变量a默认是对齐的，因此变量a占用1个字节，无需填充。当前偏移1字节。\n变量b, int类型自身对齐值为4, 指定值为8，两者取小的偏移值为4。当前偏移1字节，因此变量b前需要填充3字节，b占用4字节。当前偏移8字节。\n变量c, short类型自身对齐值为2，指定值为8，两者取小的偏移单位为2。当前偏移8字节，因此变量c前不需要填充，c占用2字节。当前偏移10字节。\n结构体自身的对齐值取最大变量的长度(int)，即4字节。指定的长度为8字节，两者取小即可得到整个结构体的对齐单位为4字节。当前偏移长度为10字节，不是对齐单位整数倍，所以需要填充2字节。因此，整个结构体占用12字节。\n3.4 不指定字节，按照默认对齐的示例分析 1 2 3 4 5 6 7 struct test { char a; int b; short c; long d; }; sizeof(struct test); // 24字节 说明： 变量a，char自身对齐值为1; 首地址为0，变量a默认是对齐的，因此变量a占用1个字节，无需填充。当前偏移1字节。\n变量b, int类型自身对齐值为4。当前偏移1字节，因此变量b前需要填充3字节，b占用4字节。当前偏移8字节。\n变量c, short类型自身对齐值为2。当前偏移8字节，因此变量c前不需要填充，c占用2字节。当前偏移10字节。\n变量d, long类型自身对齐值为8。当前偏移10字节，因此变量d前需要填充6个字节，c占用8字节。当前偏移24字节。\n结构体自身的对齐值取最大变量的长度(long)，即8字节。无指定的对齐长度，因此整个结构体的对齐单位为8字节。当前偏移长度为24字节，是对齐单位整数倍，所以不需要填充。因此，整个结构体占用24字节。\n","date":"2024-11-15T22:52:34+08:00","permalink":"https://alvincat.github.io/post/linux/struct_alignment/","tags":["结构体字节对齐"],"title":"C语言结构体字节对齐问题"},{"categories":["数据结构"],"contents":"本文介绍链表的基本特性以及链表常用的操作。\n1 链表的特性 链表是一种链式存储数据的结构。相邻的两个结点之间在物理地址上并不是连续存放的。因此就决定了链表无法进行随机访问，只能按照链接关系进行顺序访问。 只能单向变量的链表称为单链表，可以双向访问的链表称为双向链表。\n2 链表的基本操作 链表的常用操作有：创建链表，链表结点的插入、删除，销毁链表等。\n2.1 链表结点的定义 链表结点的定义是一种递归形式的定义，链表中的指针是链表结点类型的指针。\n1 2 3 4 struct ListNode { int val; struct ListNode *next; }; 2.1 链表的创建 2.2 链表的销毁","date":"2024-11-15T17:52:42+08:00","permalink":"https://alvincat.github.io/post/data_structure/linklist/link_list_introduction/","tags":["链表"],"title":"链表基本特性及其相关操作"},{"categories":["Linux"],"contents":"本文记录Linux常用命令的用法。\n1 linux命令的综合使用 1 2 # 删除出指定文件之外的文件 ls | grep -xvF file.txt | xargs rm -rf -- ","date":"2024-11-15T17:13:30+08:00","permalink":"https://alvincat.github.io/post/linux/linux_common_tools/","tags":["Linux常用命令"],"title":"Linux常用命令的用法"},{"categories":["算法"],"contents":"本文记录字符串匹配算法的演进已经具体实现。\n字符串匹配算法(String Search Algorigthm) 一点说明：\n原串：即子串匹配过程中， 待查找的字符串；\n搜索串：即用来匹配的特定的一个子串。\n1 KMP算法 (The Knuth-Morris-Pratt Algorithm) 优点：在暴力解法的基础上，减少匹配过程中查找字符串比较次数。\n缺点：当待查找的字符串没有重复搜索串时，算法退化为暴力解法。\n算法中的概念：\n局部匹配表(partial match table):查找过程中的子串中真前缀和真后缀的最大公共长度。\n字符串的真前缀(proper prefix)：例如 “S”, “Sn”, “Sna”, 和 “Snap” 都是 “Snape”的proper prefix。\n字符串的真后缀(proper suffix)：例如“d”,“agrid”, “grid”, “rid”, “id”和 都是“Hagrid”的proper suffix。\n计算局部匹配表(partial math table) 局部匹配表有时也称为next数组。该表是由子串的内容决定的。计算过程如下(以下过程以字符串\u0026quot;abababca\u0026quot;为例)：\n字符串长度为1时，字符串为\u0026quot;a\u0026quot;。因此对应表项为0。\n字符串长度为2时，字符串为“ab”，proper prefix包含“a”；proper suffix包含“b”，因此对应表项为0。\n字符串长度为3时，字符串为“aba”，proper prefix包含“a”, “ab”； proper suffix包含“a”,“ba”，因此对应表项为1。\n字符串长度为4时，字符串为“abab”，proper prefix包含“a”, “ab”,“aba”；proper suffix包含“b”，“ab”，“bab”，因此对应表项为2。\n字符串长度为5时，字符串为“ababa”，proper prefix包含“a”, “ab”,“aba”,“abab”；proper suffix包含“a”，“ba”，“aba”，“baba”，因此对应表项为3。\n字符串长度为6时，字符串为“ababab”，proper prefix包含“a”, “ab”,“aba”,“abab”,“ababa”；proper suffix包含“b”，“ab”，“bab”，“abab”,，因此对应表项为3。\n使用局部匹配表进行字符串匹配 设局部匹配表为table。如果存在部分匹配值partial_match_length，而且table[partial_match_length] \u0026gt; 1，则子串可以跳过的长度为：partial_match_length - table[partial_match_length - 1] 。例如：\n第一次匹配情况，如下图所示：\n该匹配中部分匹配长度(partial_match_length)为1。而对应的值table[partial_match_length - 1]即table[0]等于0。因此我们不需要跳过任何字母。 接下来的匹配情况如下图所示：\n该匹配中部分匹配长度为(partial_match_length)为5。这个值对应的table[partial_match_length - 1](即table[4])值为3。这意味着partial_match_length - table[partial_match_length - 1](即5 - talbe[4]，即5-3，即2)。即子串向右移动2个字符。如图所示：\n移动后的匹配情况如上图所示，匹配成功长度(partial_match_length)为3。对应的table[partial_match_length - 1](即table[2])值为1。意味着我们向后移动长度为：partial_match_length - table[partial_match_length - 1](即3 - table[2] = 3 - 1 = 2)。移动后的结果如图所示：\n因子串尾部以超过原串长度，因此结束匹配。\n2 BM算法 (Boyer-Moore Algorithm) 1977年，德克萨斯大学的Robert S. Boyer教授和J Strother Moore教授发明了这种算法。因此取这两个人的名字而得。word中的查找功能就是使用该算法。\n算法中的概念：\n坏字符(bad character)：字符串匹配过程中，与搜索串不匹配的字符。 好后缀(good suffix): 即搜索串与原串尾部能够匹配的字符串。 坏字符实例，如下图: 好后缀实例，如下图：\n比较规则：首先，将搜索串与原串对齐，从搜索串尾部从后往前比较。\n坏字符移动规则: 后移位数 = 坏字符的位置 - 搜索词中的上一次出现位置。说明，若搜索串中不包含坏字符，则搜索串上一次出现位置为-1。若包含该字符，则为离坏字符位置最近的那个位置。\n好后缀规则 :后移位数 = 好后缀的位置 - 搜索词中的上一次出现位置。好后缀位置以后缀最后一个位置为准。说明，若搜索串中不包含坏字符，则搜索串上一次出现位置为-1。例如：\n如果字符串\u0026quot;ABCDAB\u0026quot;的后一个\u0026quot;AB\u0026quot;是\u0026quot;好后缀\u0026quot;。那么它的位置是5（从0开始计算，取最后的\u0026quot;B\u0026quot;的值），在\u0026quot;搜索词中的上一次出现位置\u0026quot;是1（第一个\u0026quot;B\u0026quot;的位置），所以后移 5 - 1 = 4位，前一个\u0026quot;AB\u0026quot;移到后一个\u0026quot;AB\u0026quot;的位置。 如果字符串\u0026quot;ABCDEF\u0026quot;的\u0026quot;EF\u0026quot;是好后缀，则\u0026quot;EF\u0026quot;的位置是5 ，上一次出现的位置是 -1（即未出现），所以后移 5 - (-1) = 6位，即整个字符串移到\u0026quot;F\u0026quot;的后一位。 注意：\n以上两个规则的中的位置指的是搜索串中的位置。 当通过坏字符规则和好后缀移动规则得到的值不同时，取较大的值作为移动量。 下面以字符串为\u0026quot;HERE IS A SIMPLE EXAMPLE\u0026quot;，搜索词为\u0026quot;EXAMPLE\u0026quot;为例，进行说明：\nstep1：\n首先遇到坏字符，计算移动位置：6 - (-1) = 7. step2:\n遇到坏字符，计算移动位置：6 - 4 = 2.\nstep3:\n遇到好后缀，计算移动位置：6 - 0 = 6。\nstep4:\n坏字符和好后缀的选择问题：\n坏字符的结果：\n后后缀的结果：\nstep5:\n3 Sunday算法(Sunday Algorigthm) sunday算法是对BM算法的改进。改进之处：当匹配失败时，判断搜索串下次匹配位置的第一个字符是否与搜索串第一个字符是否相同。进而减少匹配次数。\n","date":"2024-11-15T16:01:16+08:00","permalink":"https://alvincat.github.io/post/algorithm/string_match_algorightm/","tags":["字符串匹配"],"title":"字符串匹配算法"},{"categories":["环境搭建"],"contents":"Hugo中一些实用的配置。\n1 设置网站的页面宽度 在文件themes\\even\\assets\\sass\\_variables.scss中找到配置项$global-body-width，默认值为800。\n调整这个值就可以改变网站中页面的宽度。\n2 Hugo中使用图片的方法 在根目录static目录下创建目录放置图片即可。在markdown文件中按照形如/image/logo.png的方式进行引用即可。\n3 修改Hugo even主题主页的字体 将文件themes\\even\\assets\\sass\\_partial\\_header\\_logo.scss 中.logo的font-family属性按照如下形式修改即可：\n1 2 3 4 .logo { font-size: $logo-font-size; font-family: $global-serif-font-family; } 4 修改网站的语言 修改方法：修改网站工程根目录的config.toml文件，将defaultContentLanguage属性改为zh-cn 即可。切换后会使用theme主题i18n目录下对应的yaml文件。\n5 添加站内搜索功能 我自己的修改：\n源码仓：git@github.com:alvincat/MyGithubWebsite.git/master: 5f7a66cfe4e0a6cb94f33518297828c894e431b4\n模板仓：git@github.com:alvincat/HugoThemeEven.git/master: 088afb3d0cc34329a64b4e596a54e3e2af0c634b\n主要参考文档：\n给Hugo中的Even主题添加搜索功能 - 飞狐的部落格\n其他参考文档：\n给hugo添加搜索功能 | 搜百谷\nSuper fast, keyboard-optimized, client side Hugo search\n6 将页面置顶 若需要在主页将某个页面置顶，只需要在页面对应的md文件的文件头中添加weight: 1即可。 weight:1表示将该页面放在第1的位置，若需要将某个页面放在第二个位置，在源文件的头部添加weight:2即可。\n","date":"2024-11-14T23:34:32+08:00","permalink":"https://alvincat.github.io/post/hugo/hugo_some_usful_setting/","tags":["Hugo"],"title":"Hugo中一些实用的配置"},{"categories":["Linux"],"contents":"本文记录Git常用命令。\n1 Git常用命令 1.1 查询命令 1 2 3 git status # 查看当前git状态 git log # 查询修改记录 git tag -l # 查询tag 1.2 代码下载上传 1 2 3 4 5 6 7 # down load source code git clone -b main git@github.com:alvincat/MyGithubWebsite.git MyWebsite git submodule update --recursive # update submodule git push git pull git push --set-upstream origin gh_pages # upload new branch 1.3 分支相关操作 1 2 3 4 5 6 git branch # 查看本地所有分支 git branch | grep \u0026#34;*\u0026#34; #查看当前分支 git checkout branch_name # 切换分支 git checkout -b gh_pages # create branch git branch -D gh_pages # 删除本地分支 git push origin --delete main # 删除远端分支 1.4 修改相关操作 1 2 3 4 5 6 7 8 9 10 11 git commit -m \u0026#34;\u0026#34; # add commit git add file1 file2 # add to local cache git stash # 暂存当前修改 git stash pop # 恢复暂存内容 git reset --hard origin/master # 强制更新当前分支代码为master分支 git reset --mixed commit_id # 将制定commit_id以后的提交回退至未提交 git rebase -i head~2 git cherry-pick commit_id 1.5 远程仓库操作 1 2 3 4 5 6 7 8 9 10 11 12 # 查询本地关联的代码仓 git remote -v # 添加远程分支, 其中origin为远程代码仓在本地的name, 本地代码可以关联多个远程代码仓 git remote origin https://github.com/olOwOlo/hugo-theme-even git remote add myEvenBackup git@github.com:alvincat/HugoThemeEven.git # 提交代码时可以指定代码仓进行 # 提交代码至https://github.com/olOwOlo/hugo-theme-even的master分支 git push -u origin master # 提交代码至git@github.com:alvincat/HugoThemeEven.git的master分支 git push -u myEvenBackup master 2 Git相关配置 2.1 Git添加ssh公钥 设置用户名和邮箱 1 2 3 4 5 6 7 8 9 10 11 12 # 设置用户名 git config --global user.name \u0026#34;username\u0026#34; # 设置邮箱 git config --global user.email your_email@example.com # 查看用户名和密码 git config user.name git config user.email # 查看其他配置信息(git设置列表) git config --list 执行命令生成ssh公钥和私钥 windows环境 1 2 # 使用Ed25519加密算法生成公钥和私钥 ssh-keygen -t ed25519 -C \u0026#34;your_email@example.com\u0026#34; Linux或者MacOS环境 1 2 # 使用Ed25519加密算法生成公钥和私钥 ssh-keygen -t ed25519-sk -C \u0026#34;your_email@example.com\u0026#34; 将生成的公钥文件id_ed25519.pub中的内容添加至github即可使用ssh上传下载代码。 温馨提示：\n若添加公钥后，提交代码提示错误：push declined due to email privacy restrictions\n原因：将github关联的email设置为私密，对外不可见。\n解决方法：\n方法1：进入https://github.com/settings/emails页面，将【Block command line pushes that expose my email】勾选去掉。 方法2：使用github提供的转换邮件地址。(在标签【Keep my email addresses private】的内容中提供，形如：12345678+username@users.noreply.github.com)。使用这个邮件地址更新密钥即可。 2.2 gitignore的用法 git在提交代码时，存在部分本地生成的和代码无关的文件，不需要提交。这种文件或者目录就需要使用gitignore的机制进行过滤。使用方法如下：\n在代码根目录创建文件.gitignore 在文件中添加需要过滤的文件和目录，注意若要过滤整个目录，需要在目录后跟/ 常见情况解决方法：\n添加到.gitignore文件中的目录，再次提交后并未生效。解决方法，执行代码：git rm -r --cached \u0026lt;folder\u0026gt; ","date":"2024-11-14T17:13:30+08:00","permalink":"https://alvincat.github.io/post/git/git_commond/","tags":["Git"],"title":"Git常用命令"},{"categories":["环境搭建"],"contents":"本文记录Hugo配置github静态页面的关键步骤。\n1 Hugo简介 Hugo是由Go语言实现的静态网站生成器。简单、易用、高效、易扩展、快速部署。\nHugo官网：Hugo官网\nHugo的官方文档：Hugo中文文档\n2 使用Hugo发布静态网站的准备工作 2.1 下载安装部署网站工具 2.1.1 下载安装git Git下载地址：Download Git\nWindows下安装方法：运行二进制程序，然后按照提示操作即可。\n2.1.2 下载安装go 官方下载地址：Download and install - The Go Programming Language\nGo语言中文网下载地址：Go语言中文网下载地址\n我下载的go版本是：go1.17.3\n安装配置完成后，使用命令go version 查看版本号。\n温馨提示：若下载的是免安装版本，需要手动配置环境变量，否则无法使用。\n2.1.3 下载安装hugo-extend Hugo v0.138.0下载地址： Hugo v0.138.0下载地址\n我下载的是：hugo_extended_withdeploy_0.138.0_windows-amd64.zip\n安装配置完成后，使用命令hugo version 查看版本号。\n温馨提示：若下载的是免安装版本，需要手动配置环境变量，否则无法使用。\n2.2 创建代码仓 在github创建私有库MyGithubWebsite: 用于存放网站工程源码 在github创建公共代码username.github.io: 用于保存网站内容。\ngithub规定必须将网站内容放在形如username.github.io的代码仓中，此处的username为你的github的用户名。 2.3 下载代码 1 git clone git@github.com:alvincat/MyGithubWebsite.git MyWebsite 2.4 初始化网站 1 2 # 在网站根目录的上层目录执行命令，MyWebsite为网站工程根目录名 hugo new site MyWebsite --force 2.5 Hugo使用even模板 2.5.1 下载even模板 1 2 # 进入根目录，执行命令下载网站模板 git clone https://github.com/olOwOlo/hugo-theme-even themes/even 2.5.2 even模板配置 在even主题的 exampleSite 目录下有一个 config.toml 文件，将这个 config.toml 文件复制到你的站点根目录下，根据自己的需求更改即可。\n为了定制 favicon，你需要在站点根目录的 static 文件夹下放置下述所有文件，这将覆盖 themes/even/static/ 文件夹下的那些文件。\nandroid-chrome-192x192.png android-chrome-512x512.png apple-touch-icon.png browserconfig.xml favicon.ico favicon-16x16.png favicon-32x32.png manifest.json mstile-150x150.png safari-pinned-tab.svg 2.5.3 even文章模板配置 你可以通过 front-matter 针对每一篇文章单独进行设置。themes/even/archetypes/default.md 文件陈列了所有可用的参数。\n将该文件复制到站点根目录的 archetypes 文件夹下将会有所帮助。\n3 使用Hugo撰写博客 3.1 使用hugo创建文件 1 hugo new post/hello.md 注意:\n对于even这个主题，你应该使用 post 而不是 posts，即 hugo new post/some-content.md 建议使用hugo new命令来新建文件，而不要直接在post目录下创建文件。 3.2 hugo本地调试博客文章 1 hugo server -D 登陆浏览器查看结果：localhost\n3.3 发布网站 在站点根目录执行 以下Hugo 命令生成最终页面：\n1 hugo -D --baseURL=\u0026#34;https://alvincat.github.io/\u0026#34; 执行这条命令，就会在public目录下生成最终网站内容。\n将public的内容推送到username.github.io仓库，就可以访问网站了\n3.4 创建.gitignore文件，忽略部分文件 3.5 本地调试完成后，提交代码至github 1 2 3 git add file git commit -m \u0026#34;add file\u0026#34; git push 温馨提示：\n在本地调试完成提交前，建议先将public目录下的内容清空，重新编译后再提交，以免public目录存在修改的残留文件。\n4 使用github actions功能自动发布网站的方法 4.1 创建personal access token 按照setting -\u0026gt; Developer Settings -\u0026gt; Personal access tokens的顺序打开创建token界面。如下图所示。 按照Tokens(classic) -\u0026gt; Generate new token -\u0026gt; Generate new token(classic)的顺序创建token。如下图所示： 在创建token的界面勾选【workflow]按钮。如下图所示： 点击创建后，就会生成一串token编码。此时需要复制这串编码，后面添加的时候需要使用。 4.2 添加secrets 进入网站工程的setting界面，如下图所示： 进入添加secret界面，填写secretname和步骤5.1生成的token。(注意： 此处的secret name后续在配置文件中会用到。）如下图所示： 添加完成后就会提示添加成功。如下图所示：\n4.3 添加active自动化配置文件 在网站工程根目录创建目录.github/workflows/，然后再该目录下创建一个yml文件，文件名自定。此处文件名为hugo.yml。文件内容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 name: GitHub Pages on: push: branches: - master # 博客工程根目录的默认分支，我的是master，请以实际为准 jobs: deploy: runs-on: ubuntu-latest concurrency: group: ${{ github.workflow }}-${{ github.ref }} steps: - uses: actions/checkout@v2 with: submodules: false fetch-depth: 0 - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#39;latest\u0026#39; extended: true # 如果你使用的不是extended版本的hugo，将true改为false - name: Build run: hugo --minify - name: Deploy uses: peaceiris/actions-gh-pages@v3 if: ${{ github.ref == \u0026#39;refs/heads/master\u0026#39; }} # 博客工程根目录的默认分支，我的是master，请以实际为准 with: personal_token: ${{ secrets.YOUR_SECRET}} # 如果secret取了其他名称，将YOUR_SECRET替换掉 external_repository: alvincat/alvincat.github.io # 填写远程仓库，名字 publish_dir: ./public #cname: www.example.com # 填写你的自定义域名。如果没有用自定义域名，注释掉这行 该配置文件的作用就是当私有库MyGithubWebsite的master分支代码提交后，将public目录的内容推送到username.github.io的gh-pages分支。可以通过查看MyGithubWebsite的action页面确认，该配置是否生效。 如下图所示： 其实该功能也可以手动完成，当本地调试完成后，将public的内容推送到username.github.io的gh-pages分支。\n1 2 3 4 5 6 cd public git init git remote add origin git@github.com:alvincat/alvincat.github.io.git git add . git commit -m \u0026#39;add blog\u0026#39; git push origin gh-pages 4.4 修改username.github.io代码仓的page页面关联分支 当步骤5.4更新成功后，就会将生成的网站内容推送到username.github.io代码仓的gh-pages分支。因此需要将username.github.io代码仓的page关联分支切换为gh-pages。\n修改方法如下：\n5 参考文献 将Hugo静态网站部署到Github Pages\nHugo + even + GitHub Pages+ Utterances搭建个人博客\n利用GitHub Action实现Hugo博客在GitHub Pages自动部署\nHugo + GitHub Action，搭建你的博客自动发布系统\n","date":"2024-11-14T16:51:30+08:00","permalink":"https://alvincat.github.io/post/hugo/hugo_build_static_page/","tags":["Hugo"],"title":"Hugo配置github静态页面的方法"},{"categories":[],"contents":"关于我的详细信息。\n个人信息 Name : alvincat 个人爱好 联系我 \u0026#x1f4e7; : alvincat@126.com Github: https://github.com/alvincat 友情链接","date":"2024-11-14T11:16:25+08:00","permalink":"https://alvincat.github.io/about/","tags":[],"title":"关于我"},{"categories":["操作系统"],"contents":"该页为的操作系统导航页。\n操作系统 Kernel_boot_process\n","date":"2024-11-13T17:57:26+08:00","permalink":"https://alvincat.github.io/post/index/content_os/","tags":[""],"title":"操作系统导航页"},{"categories":["环境搭建"],"contents":"该页为的环境搭建导航页。\n环境搭建 Hugo配置github静态页面的方法\nHugo中一些实用的配置\n","date":"2024-11-13T16:58:15+08:00","permalink":"https://alvincat.github.io/post/index/content_environment_deploy/","tags":[""],"title":"环境搭建导航页"},{"categories":["Linux"],"contents":"该页为的Linux相关内容的导航页。\nLinux C语言结构体字节对齐问题\nc语言编码注意事项\nGit常用命令\nVim常用设置以及常用命令\nLinux常用命令的用法\nUbuntu系统常用设置和命令\nLinux系统常用的系统配置\n","date":"2024-11-13T16:57:51+08:00","permalink":"https://alvincat.github.io/post/index/content_linux/","tags":[""],"title":"Linux相关内容的导航页"},{"categories":["数据结构"],"contents":"该页为数据结构的导航页。\n数据结构 链表 单链表常见功能函数\n链表基本特性及其相关操作\n哈希表 哈希表: 哈希表的原理和实现\nLRU\n二叉树 创建二叉树的方法\n二叉树的遍历方法\n","date":"2024-11-13T16:56:59+08:00","permalink":"https://alvincat.github.io/post/index/content_data_structure/","tags":[""],"title":"数据结构导航页"},{"categories":["算法"],"contents":"该页为算法的导航页。\n算法 字符串匹配算法\n遍历-DFS\n遍历-BFS\n","date":"2024-11-13T16:56:45+08:00","permalink":"https://alvincat.github.io/post/index/content_algorithm/","tags":[""],"title":"算法导航页"}]