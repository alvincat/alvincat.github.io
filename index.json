[{"categories":["Linux"],"contents":"这篇文章介绍C语言结构体字节对齐的问题。\n1 结构体字节对齐的规则 结构体变量的首地址能够被其最宽基本类型成员的大小所整除；???\n数据类型自身的对齐：例如，在x86_64系统，char型数据自身对齐值为1字节，short型数据为2字节，int/float型为4字节，long/double/void*型为8字节。\n结构体或者类的自身的对齐：其成员中自身对齐值中的最大值。\n指定对齐值的情况下的对齐规则：#pragma pack (value)时的指定对齐值value。指定规则后以指定规则进行对齐。\n使用伪指令#pragma pack(n)：C编译器将按照n个字节对齐； 使用伪指令#pragma pack()： 取消自定义字节对齐方式。 数据成员、结构体和类的有效对齐值：若存在指定对齐值，需要自身对齐值和指定对齐值中较小者，即有效对齐值=min{自身对齐值，当前指定的pack值}。\n2 x86环境各种基本数据类型的字节数 数据类型 x86 x86_64 char 1 1 short 2 2 int 4 4 long 4 8 float 4 4 double 8 8 void* 4 8 3 示例程序 当前的实例程序假定结构体首地址为0。环境关键信息如下：\nArchithecture: x86_64\nGCC version: 4.4.7\n3.1 指定1字节对齐的示例分析 1 2 3 4 5 6 7 8 #pragma pack(1) struct test { char a; // not padding int b; // not pading short c; }; #pragma pack() sizeof(struct test); // 7 字节 说明：\n变量a，char自身对齐值为1, 指定值为1; 两者取小的值为1。首地址为0，变量a是对齐的，因此变量a占用1个字节。此时偏移1字节。\n变量b, int类型自身对齐值为4, 指定值为1，两者取小的偏移值为1。当前偏移1字节，因此变量b前不需要填充，b占用4字节。此时偏移5字节。\n变量c, short类型自身对齐值为2，指定值为1，两者取小的偏移单位为1。当前偏移5字节，因此变量c前也不需要填充，c占用2字节。此时偏移7字节。\n结构体自身的对齐值取最大变量的长度(int)，即4字节。但是指定的长度为1字节，两者取小即可得到整个结构体的对齐单位为1字节。因此，整个结构体占用7字节。\n3.2 指定2字节对齐的示例分析 1 2 3 4 5 6 7 8 #pragma pack(2) struct test { char a; // pading 1Byte int b; // not padding short c; }; #pragma pack() sizeof(struct test); // 8 字节 说明：\n变量a，char自身对齐值为1, 指定值为2; 两者取小的值为1。首地址为0，变量a是对齐的，因此变量a占用1个字节。此时偏移1字节。\n变量b, int类型自身对齐值为4, 指定值为2，两者取小的偏移值为2。当前偏移1字节，因此变量b前需要填充1字节，b占用4字节。此时偏移6字节。\n变量c, short类型自身对齐值为2，指定值为2，两者取小的偏移单位为2。当前偏移6字节，因此变量c前不需要填充，c占用2字节。此时偏移8字节。\n结构体自身的对齐值取最大变量的长度(int)，即4字节。但是指定的长度为2字节，两者取小即可得到整个结构体的对齐单位为2字节。当前偏移长度为8字节，已经是对齐单位整数倍，所以无需填充。因此，整个结构体占用8字节。\n3.3 指定4字节对齐的示例分析 1 2 3 4 5 6 7 8 #pragma pack(4) struct test { char a; int b; short c; }; #pragma pack() sizeof(struct test); // 12字节 说明： 变量a，char自身对齐值为1, 指定值为4; 两者取小的值为1。首地址为0，变量a默认是对齐的，因此变量a占用1个字节，无需填充。当前偏移1字节。\n变量b, int类型自身对齐值为4, 指定值为4，两者取小的偏移值为4。当前偏移1字节，因此变量b前需要填充3字节，b占用4字节。当前偏移8字节。\n变量c, short类型自身对齐值为2，指定值为4，两者取小的偏移单位为2。当前偏移8字节，因此变量c前不需要填充，c占用2字节。当前偏移10字节。\n结构体自身的对齐值取最大变量的长度(int)，即4字节。指定的长度为4字节，两者取小即可得到整个结构体的对齐单位为4字节。当前偏移长度为10字节，不是对齐单位整数倍，所以需要填充2字节。因此，整个结构体占用12字节。\n3.3 指定8字节对齐的示例分析 1 2 3 4 5 6 7 8 #pragma pack(8) struct test { char a; int b; short c; }; #pragma pack() sizeof(struct test); // 12字节 说明： 变量a，char自身对齐值为1, 指定值为8; 两者取小的值为1。首地址为0，变量a默认是对齐的，因此变量a占用1个字节，无需填充。当前偏移1字节。\n变量b, int类型自身对齐值为4, 指定值为8，两者取小的偏移值为4。当前偏移1字节，因此变量b前需要填充3字节，b占用4字节。当前偏移8字节。\n变量c, short类型自身对齐值为2，指定值为8，两者取小的偏移单位为2。当前偏移8字节，因此变量c前不需要填充，c占用2字节。当前偏移10字节。\n结构体自身的对齐值取最大变量的长度(int)，即4字节。指定的长度为8字节，两者取小即可得到整个结构体的对齐单位为4字节。当前偏移长度为10字节，不是对齐单位整数倍，所以需要填充2字节。因此，整个结构体占用12字节。\n3.4 不指定字节，按照默认对齐的示例分析 1 2 3 4 5 6 7 struct test { char a; int b; short c; long d; }; sizeof(struct test); // 24字节 说明： 变量a，char自身对齐值为1; 首地址为0，变量a默认是对齐的，因此变量a占用1个字节，无需填充。当前偏移1字节。\n变量b, int类型自身对齐值为4。当前偏移1字节，因此变量b前需要填充3字节，b占用4字节。当前偏移8字节。\n变量c, short类型自身对齐值为2。当前偏移8字节，因此变量c前不需要填充，c占用2字节。当前偏移10字节。\n变量d, long类型自身对齐值为8。当前偏移10字节，因此变量d前需要填充6个字节，c占用8字节。当前偏移24字节。\n结构体自身的对齐值取最大变量的长度(long)，即8字节。无指定的对齐长度，因此整个结构体的对齐单位为8字节。当前偏移长度为24字节，是对齐单位整数倍，所以不需要填充。因此，整个结构体占用24字节。\n","permalink":"http://localhost:1313/post/linux/struct_alignment/","tags":["结构体字节对齐"],"title":"C语言结构体字节对齐问题"},{"categories":["数据结构"],"contents":"本文介绍链表的基本特性以及链表常用的操作。\n1 链表的特性 链表是一种链式存储数据的结构。相邻的两个结点之间在物理地址上并不是连续存放的。因此就决定了链表无法进行随机访问，只能按照链接关系进行顺序访问。 只能单向变量的链表称为单链表，可以双向访问的链表称为双向链表。\n2 链表的基本操作 链表的常用操作有：创建链表，链表结点的插入、删除，销毁链表等。\n2.1 链表结点的定义 链表结点的定义是一种递归形式的定义，链表中的指针是链表结点类型的指针。\n1 2 3 4 struct ListNode { int val; struct ListNode *next; }; 2.1 链表的创建 2.2 链表的销毁 3 链表常见功能函数 链表相关的功能有：反转链表，获取链表的长度，获取链表的中间结点，判断两条链表是否相加，判断链表是否有环，合并两个有序链表等。\n3.1 翻转链表 3.1.1 迭代方式翻转链表 迭代方式翻转链表也称为链表头插法。\n方法1：新增一个临时头结点 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // 新增额外头结点的 struct ListNode* reverseList(struct ListNode* head) { if (head == NULL || head-\u0026gt;next == NULL) { return head; } struct ListNode* headp = (struct ListNode*)malloc(sizeof(struct ListNode)); headp-\u0026gt;val = 0; headp-\u0026gt;next = NULL; struct ListNode* tail = NULL; struct ListNode* cur = head; while (cur) { struct ListNode* pre = cur-\u0026gt;next; tail = headp-\u0026gt;next; headp-\u0026gt;next = cur; cur-\u0026gt;next = tail; cur = pre; } cur = headp-\u0026gt;next; free(headp); headp = NULL; return cur; } 方法2：不新增头结点，进行翻转 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 struct ListNode* reverseList(struct ListNode* head) { if (head == NULL || head-\u0026gt;next == NULL) { return head; } struct ListNode* cur = head-\u0026gt;next; head-\u0026gt;next = NULL; while (cur) { struct ListNode* pre = cur-\u0026gt;next; cur-\u0026gt;next = head; head = cur; cur = pre; } return head; } 3.1.2 递归方式翻转链表 递归方式代码比较简单，但是要不太容易理解。递归的关键是抽象出一个通用的模型以及边界条件的处理。\n1 2 3 4 5 6 7 8 9 10 11 12 struct ListNode* reverseList(struct ListNode* head) { if (head == NULL || head-\u0026gt;next == NULL) { return head; } struct ListNode* prev = reverseList(head-\u0026gt;next); head-\u0026gt;next-\u0026gt;next = head; head-\u0026gt;next = NULL; return prev; } 3.2 获取链表长度 1 2 3 4 5 6 7 8 9 10 11 12 13 14 int GetListNum(struct ListNode* head) { if (head == NULL) { return 0; } int cnt = 0; struct ListNode* tmp = head; while (tmp) { ++cnt; tmp = tmp-\u0026gt;next; } return cnt; } 3.3 获取链表中间结点 1 2 3 4 5 6 7 8 9 10 11 12 13 14 struct ListNode* GetMidNode(struct ListNode* head) { int cnt = GetListNum(head); int i = 0; tmp = head; struct ListNode* cur = NULL; while (i \u0026lt; cnt/2 \u0026amp;\u0026amp; tmp) { cur = tmp; tmp = tmp-\u0026gt;next; ++i; } return cur; } 4 链表高级特性 5 C++中的链表","permalink":"http://localhost:1313/post/datastructure/linklist/","tags":["链表"],"title":"链表及其相关操作"},{"categories":["Linux"],"contents":"本文记录Linux常用命令。\n1 linux命令的综合使用 1 2 # 删除出指定文件之外的文件 ls | grep -xvF file.txt | xargs rm -rf -- ","permalink":"http://localhost:1313/post/linux/linux_common_tools/","tags":["Linux常用命令"],"title":"Linux常用命令的用法"},{"categories":["算法"],"contents":"本文记录字符串匹配算法的演进已经具体实现。\n字符串匹配算法(String Search Algorigthm) 一点说明：\n原串：即子串匹配过程中， 待查找的字符串；\n搜索串：即用来匹配的特定的一个子串。\n1 KMP算法 (The Knuth-Morris-Pratt Algorithm) 优点：在暴力解法的基础上，减少匹配过程中查找字符串比较次数。\n缺点：当待查找的字符串没有重复搜索串时，算法退化为暴力解法。\n算法中的概念：\n局部匹配表(partial match table):查找过程中的子串中真前缀和真后缀的最大公共长度。\n字符串的真前缀(proper prefix)：例如 “S”, “Sn”, “Sna”, 和 “Snap” 都是 “Snape”的proper prefix。\n字符串的真后缀(proper suffix)：例如“d”,“agrid”, “grid”, “rid”, “id”和 都是“Hagrid”的proper suffix。\n计算局部匹配表(partial math table) 局部匹配表有时也称为next数组。该表是由子串的内容决定的。计算过程如下(以下过程以字符串\u0026quot;abababca\u0026quot;为例)：\n字符串长度为1时，字符串为\u0026quot;a\u0026quot;。因此对应表项为0。\n字符串长度为2时，字符串为“ab”，proper prefix包含“a”；proper suffix包含“b”，因此对应表项为0。\n字符串长度为3时，字符串为“aba”，proper prefix包含“a”, “ab”； proper suffix包含“a”,“ba”，因此对应表项为1。\n字符串长度为4时，字符串为“abab”，proper prefix包含“a”, “ab”,“aba”；proper suffix包含“b”，“ab”，“bab”，因此对应表项为2。\n字符串长度为5时，字符串为“ababa”，proper prefix包含“a”, “ab”,“aba”,“abab”；proper suffix包含“a”，“ba”，“aba”，“baba”，因此对应表项为3。\n字符串长度为6时，字符串为“ababab”，proper prefix包含“a”, “ab”,“aba”,“abab”,“ababa”；proper suffix包含“b”，“ab”，“bab”，“abab”,，因此对应表项为3。 使用局部匹配表进行字符串匹配 设局部匹配表为table。如果存在部分匹配值partial_match_length，而且table[partial_match_length] \u0026gt; 1，则子串可以跳过的长度为：partial_match_length - table[partial_match_length - 1] 。例如：\n第一次匹配情况，如下图所示：\n该匹配中部分匹配长度(partial_match_length)为1。而对应的值table[partial_match_length - 1]即table[0]等于0。因此我们不需要跳过任何字母。 接下来的匹配情况如下图所示：\n该匹配中部分匹配长度为(partial_match_length)为5。这个值对应的table[partial_match_length - 1](即table[4])值为3。这意味着partial_match_length - table[partial_match_length - 1](即5 - talbe[4]，即5-3，即2)。即子串向右移动2个字符。如图所示：\n移动后的匹配情况如上图所示，匹配成功长度(partial_match_length)为3。对应的table[partial_match_length - 1](即table[2])值为1。意味着我们向后移动长度为：partial_match_length - table[partial_match_length - 1](即3 - table[2] = 3 - 1 = 2)。移动后的结果如图所示：\n因子串尾部以超过原串长度，因此结束匹配。\n2 BM算法 (Boyer-Moore Algorithm) 1977年，德克萨斯大学的Robert S. Boyer教授和J Strother Moore教授发明了这种算法。因此取这两个人的名字而得。word中的查找功能就是使用该算法。\n算法中的概念：\n坏字符(bad character)：字符串匹配过程中，与搜索串不匹配的字符。 好后缀(good suffix): 即搜索串与原串尾部能够匹配的字符串。 坏字符实例，如下图: 好后缀实例，如下图：\n比较规则：首先，将搜索串与原串对齐，从搜索串尾部从后往前比较。\n坏字符移动规则: 后移位数 = 坏字符的位置 - 搜索词中的上一次出现位置。说明，若搜索串中不包含坏字符，则搜索串上一次出现位置为-1。若包含该字符，则为离坏字符位置最近的那个位置。\n好后缀规则 :后移位数 = 好后缀的位置 - 搜索词中的上一次出现位置。好后缀位置以后缀最后一个位置为准。说明，若搜索串中不包含坏字符，则搜索串上一次出现位置为-1。例如：\n如果字符串\u0026quot;ABCDAB\u0026quot;的后一个\u0026quot;AB\u0026quot;是\u0026quot;好后缀\u0026quot;。那么它的位置是5（从0开始计算，取最后的\u0026quot;B\u0026quot;的值），在\u0026quot;搜索词中的上一次出现位置\u0026quot;是1（第一个\u0026quot;B\u0026quot;的位置），所以后移 5 - 1 = 4位，前一个\u0026quot;AB\u0026quot;移到后一个\u0026quot;AB\u0026quot;的位置。 如果字符串\u0026quot;ABCDEF\u0026quot;的\u0026quot;EF\u0026quot;是好后缀，则\u0026quot;EF\u0026quot;的位置是5 ，上一次出现的位置是 -1（即未出现），所以后移 5 - (-1) = 6位，即整个字符串移到\u0026quot;F\u0026quot;的后一位。 注意：\n以上两个规则的中的位置指的是搜索串中的位置。 当通过坏字符规则和好后缀移动规则得到的值不同时，取较大的值作为移动量。 下面以字符串为\u0026quot;HERE IS A SIMPLE EXAMPLE\u0026quot;，搜索词为\u0026quot;EXAMPLE\u0026quot;为例，进行说明：\nstep1：\n首先遇到坏字符，计算移动位置：6 - (-1) = 7. step2:\n遇到坏字符，计算移动位置：6 - 4 = 2.\nstep3:\n遇到好后缀，计算移动位置：6 - 0 = 6。\nstep4:\n坏字符和好后缀的选择问题：\n坏字符的结果：\n后后缀的结果：\nstep5:\n3 Sunday算法(Sunday Algorigthm) sunday算法是对BM算法的改进。改进之处：当匹配失败时，判断搜索串下次匹配位置的第一个字符是否与搜索串第一个字符是否相同。进而减少匹配次数。\n","permalink":"http://localhost:1313/post/algorithm/string_match_algorightm/","tags":["字符串匹配"],"title":"字符串匹配算法"},{"categories":["环境搭建"],"contents":"Hugo中一些实用的配置。\n1 设置网站的页面宽度 在文件themes\\even\\assets\\sass\\_variables.scss中找到配置项$global-body-width，默认值为800。\n调整这个值就可以改变网站中页面的宽度。\n2 Hugo中使用图片的方法 在根目录static目录下创建目录放置图片即可。在markdown文件中按照形如/image/logo.png的方式进行引用即可。\n3 修改Hugo even主题主页的字体 将文件themes\\even\\assets\\sass\\_partial\\_header\\_logo.scss 中.logo的font-fami属性按照如下形式修改即可：\n1 2 3 4 .logo { font-size: $logo-font-size; font-family: $global-serif-font-family; } 4 修改网站的语言 修改方法：修改网站工程根目录的config.toml文件，将defaultContentLanguage属性改为zh-cn 即可。切换后会使用theme主题i18n目录下对应的yaml文件。\n5 添加站内搜索功能","permalink":"http://localhost:1313/post/hugo/hugo_some_usful_setting/","tags":["Hugo"],"title":"Hugo中一些实用的配置"},{"categories":["Linux"],"contents":"本文记录Git常用命令。\n1 查询命令 1 2 3 git status # 查看当前git状态 git log # 查询修改记录 git tag -l # 查询tag 2 代码下载上传 1 2 3 4 5 6 7 # down load source code git clone -b main git@github.com:alvincat/MyGithubWebsite.git MyWebsite git submodule update --recursive # update submodule git push git pull git push --set-upstream origin gh_pages # upload new branch 3 分支相关操作 1 2 3 4 5 6 git branch # 查看本地所有分支 git branch | grep \u0026#34;*\u0026#34; #查看当前分支 git checkout branch_name # 切换分支 git checkout -b gh_pages # create branch git branch -D gh_pages # 删除本地分支 git push origin --delete main # 删除远端分支 4 修改相关操作 1 2 3 4 5 6 7 8 9 10 11 git commit -m \u0026#34;\u0026#34; # add commit git add file1 file2 # add to local cache git stash # 暂存当前修改 git stash pop # 恢复暂存内容 git reset --hard origin/master # 强制更新当前分支代码为master分支 git reset --mixed commit_id # 将制定commit_id以后的提交回退至未提交 git rebase -i head~2 git cherry-pick commit_id 5 远程仓库操作 1 2 3 4 5 6 7 8 9 10 11 12 # 查询本地关联的代码仓 git remote -v # 添加远程分支, 其中origin为远程代码仓在本地的name, 本地代码可以关联多个远程代码仓 git remote origin https://github.com/olOwOlo/hugo-theme-even git remote add myEvenBackup git@github.com:alvincat/HugoThemeEven.git # 提交代码时可以指定代码仓进行 # 提交代码至https://github.com/olOwOlo/hugo-theme-even的master分支 git push -u origin master # 提交代码至git@github.com:alvincat/HugoThemeEven.git的master分支 git push -u myEvenBackup master 6 gitignore的用法 git在提交代码时，存在部分本地生成的和代码无关的文件，不需要提交。这种文件或者目录就需要使用gitignore的机制进行过滤。使用方法如下：\n在代码根目录创建文件.gitignore 在文件中添加需要过滤的文件和目录，注意若要过滤整个目录，需要在目录后跟/ 常见情况解决方法：\n添加到.gitignore文件中的目录，再次提交后并未生效。解决方法，执行代码：git rm -r --cached \u0026lt;folder\u0026gt; ","permalink":"http://localhost:1313/post/git/git_commond/","tags":["Git"],"title":"Git常用命令"},{"categories":["环境搭建"],"contents":"本文记录Hugo配置github静态页面的关键步骤。\n1 Hugo简介 Hugo是由Go语言实现的静态网站生成器。简单、易用、高效、易扩展、快速部署。\nHugo官网：Hugo官网\nHugo的官方文档：Hugo中文文档\n2 使用Hugo发布静态网站的准备工作 2.1 下载安装部署网站工具 2.1.1 下载安装git Git下载地址：Download Git\nWindows下安装方法：运行二进制程序，然后按照提示操作即可。\n2.1.2 下载安装go 官方下载地址：Download and install - The Go Programming Language\nGo语言中文网下载地址：Go语言中文网下载地址\n我下载的go版本是：go1.17.3\n安装配置完成后，使用命令go version 查看版本号。\n温馨提示：若下载的是免安装版本，需要手动配置环境变量，否则无法使用。\n2.1.3 下载安装hugo-extend Hugo v0.138.0下载地址： Hugo v0.138.0下载地址\n我下载的是：hugo_extended_withdeploy_0.138.0_windows-amd64.zip\n安装配置完成后，使用命令hugo version 查看版本号。\n温馨提示：若下载的是免安装版本，需要手动配置环境变量，否则无法使用。\n2.2 创建代码仓 在github创建私有库MyGithubWebsite: 用于存放网站工程源码 在github创建公共代码username.github.io: 用于保存网站内容。\ngithub规定必须将网站内容放在形如username.github.io的代码仓中，此处的username为你的github的用户名。 2.3 下载代码 1 git clone git@github.com:alvincat/MyGithubWebsite.git MyWebsite 2.4 初始化网站 1 2 # 在网站根目录的上层目录执行命令，MyWebsite为网站工程根目录名 hugo new site MyWebsite --force 2.5 Hugo使用even模板 2.5.1 下载even模板 1 2 # 进入根目录，执行命令下载网站模板 git clone https://github.com/olOwOlo/hugo-theme-even themes/even 2.5.2 even模板配置 在even主题的 exampleSite 目录下有一个 config.toml 文件，将这个 config.toml 文件复制到你的站点根目录下，根据自己的需求更改即可。\n为了定制 favicon，你需要在站点根目录的 static 文件夹下放置下述所有文件，这将覆盖 themes/even/static/ 文件夹下的那些文件。\nandroid-chrome-192x192.png android-chrome-512x512.png apple-touch-icon.png browserconfig.xml favicon.ico favicon-16x16.png favicon-32x32.png manifest.json mstile-150x150.png safari-pinned-tab.svg 2.5.3 even文章模板配置 你可以通过 front-matter 针对每一篇文章单独进行设置。themes/even/archetypes/default.md 文件陈列了所有可用的参数。\n将该文件复制到站点根目录的 archetypes 文件夹下将会有所帮助。\n3 使用Hugo撰写博客 3.1 使用hugo创建文件 1 hugo new post/hello.md 注意:\n对于even这个主题，你应该使用 post 而不是 posts，即 hugo new post/some-content.md 建议使用hugo new命令来新建文件，而不要直接在post目录下创建文件。 3.2 hugo本地调试博客文章 1 hugo server -D 登陆浏览器查看结果：localhost\n3.3 测试最终生成的内容 在站点根目录执行 Hugo 命令生成最终页面：\n1 hugo --theme=hyde --baseURL=\u0026#34;http://coderzh.github.io/\u0026#34; 3.4 创建.gitignore文件，忽略部分文件 3.5 本地调试完成后，提交代码至github 1 2 3 git add file git commit -m \u0026#34;add file\u0026#34; git push 温馨提示：\n在本地调试完成提交前，建议先将public目录下的内容清空，重新编译后再提交，以免public目录存在修改的残留文件。\n4 使用github actions功能自动发布网站的方法 4.1 创建personal access token 按照setting -\u0026gt; Developer Settings -\u0026gt; Personal access tokens的顺序打开创建token界面。如下图所示。 按照Tokens(classic) -\u0026gt; Generate new token -\u0026gt; Generate new token(classic)的顺序创建token。如下图所示： 在创建token的界面勾选【workflow]按钮。如下图所示： 点击创建后，就会生成一串token编码。此时需要复制这串编码，后面添加的时候需要使用。 4.2 添加secrets 进入网站工程的setting界面，如下图所示： 进入添加secret界面，填写secretname和步骤5.1生成的token。(注意： 此处的secret name后续在配置文件中会用到。）如下图所示： 添加完成后就会提示添加成功。如下图所示：\n4.3 添加active自动化配置文件 在网站工程根目录创建目录.github/workflows/，然后再该目录下创建一个yml文件，文件名自定。此处文件名为hugo.yml。文件内容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 name: GitHub Pages on: push: branches: - master # 博客工程根目录的默认分支，我的是master，请以实际为准 jobs: deploy: runs-on: ubuntu-latest concurrency: group: ${{ github.workflow }}-${{ github.ref }} steps: - uses: actions/checkout@v2 with: submodules: false fetch-depth: 0 - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#39;latest\u0026#39; extended: true # 如果你使用的不是extended版本的hugo，将true改为false - name: Build run: hugo --minify - name: Deploy uses: peaceiris/actions-gh-pages@v3 if: ${{ github.ref == \u0026#39;refs/heads/master\u0026#39; }} # 博客工程根目录的默认分支，我的是master，请以实际为准 with: personal_token: ${{ secrets.YOUR_SECRET}} # 如果secret取了其他名称，将YOUR_SECRET替换掉 external_repository: alvincat/alvincat.github.io # 填写远程仓库，名字 publish_dir: ./public #cname: www.example.com # 填写你的自定义域名。如果没有用自定义域名，注释掉这行 该配置文件的作用就是当私有库MyGithubWebsite的master分支代码提交后，将public目录的内容推送到username.github.io的gh-pages分支。可以通过查看MyGithubWebsite的action页面确认，该配置是否生效。 如下图所示： 其实该功能也可以手动完成，当本地调试完成后，将public的内容推送到username.github.io的gh-pages分支。\n1 2 3 4 5 6 cd public git init git remote add origin git@github.com:alvincat/alvincat.github.io.git git add . git commit -m \u0026#39;add blog\u0026#39; git push origin gh-pages 4.4 修改username.github.io代码仓的page页面关联分支 当步骤5.4更新成功后，就会将生成的网站内容推送到username.github.io代码仓的gh-pages分支。因此需要将username.github.io代码仓的page关联分支切换为gh-pages。\n修改方法如下：\n5 参考文献 将Hugo静态网站部署到Github Pages\nHugo + even + GitHub Pages+ Utterances搭建个人博客\n利用GitHub Action实现Hugo博客在GitHub Pages自动部署\nHugo + GitHub Action，搭建你的博客自动发布系统\n","permalink":"http://localhost:1313/post/hugo/hugo_build_static_page/","tags":["Hugo"],"title":"Hugo配置github静态页面的方法"},{"categories":[],"contents":"关于我的详细信息。\n个人信息 Name : alvincat 个人爱好 跑步，骑行，游泳，羽毛球 联系我 Email : alvincat@126.com Github: https://github.com/alvincat 友情链接","permalink":"http://localhost:1313/about/","tags":[],"title":"关于我"},{"categories":null,"contents":"","permalink":"http://localhost:1313/search/","tags":null,"title":"站内搜索"}]