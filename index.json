[{"categories":[""],"contents":"该页面为网站的导航页面。\n汇编语言导航页 C++导航页 算法导航页 数据结构导航页 操作系统导航页 Linux相关内容导航页 工具使用导航页 环境搭建导航页 ","date":"2024-11-13T16:30:08+08:00","permalink":"http://www.alvincat.top/contents/","tags":[""],"title":"网站导航页"},{"categories":["others"],"contents":"经典音乐 经典钢琴曲 Name Author discription 命运交响曲 贝多芬 蓝色多瑙河 经典古筝曲 经典萨克斯曲 经典交响乐 Name Author discription victory Two Steps From Hell 《英雄联盟》背景音乐 Star Sky Two Steps From Hell Strength of a Thousand Men Two Steps From Hell Empire of Angels Two Steps From Hell El Dorado Two Steps From Hell Breath and Life Audiomachine Electric Romeo Immediate Music Revelations Audiomachine The Dawn 亡灵序曲 He’s a Pirate Klaus Badelt 《加勒比海盗》主题曲 七剑战歌 川井宪次 Rise Epic Music Freedom Is Ours Dragon Rider Two Steps From Hell Disappear Audiomachine Time Hans Zimmer 《盗梦空间》 Cornfield Chase Hans Zimmer 《星际穿越》 Guardians at the Gate Future World Music 经典英语歌曲 Name Author discription Apologize Timbaland OneRepublic Baby One More Time britney spears 布兰妮·斯皮尔斯演唱的一首歌曲, 为世界畅销单曲之一 Because I Love You Shakin Stevens Shakin\u0026rsquo; Stevens，英国及欧洲的超级巨星 Because Of You kelly clarkson 《Because of You》是美国流行摇滚女歌手凯莉·克莱森演唱的一首流行歌曲 Bressanone Matthew Lien Casablanca Bertie Higgins 《Casablanca》是《北非谍影》的主题曲 Careless Whisper Wham 《英国组合威猛乐队（Wham）的一首歌曲，由乔治·迈克尔演唱 dream it possible OneRepublic Edelweiss James Lord Pierpont Edelweiss是美国电影和音乐剧《音乐之声》中的著名歌曲。 I Will Always Love You Whitney Houston 电影《保镖》的主题曲 My Heart Will Go On Celine Dion 1997年著名电影《泰坦尼克号》的主题曲。 Right Here Waiting Richard Marx 电影《终有一天感动你》(Bed of Roses)主题曲 Say You Say Me Lionel Richie 电影《飞越苏联》的主题曲 Take My Breath Away Jessica Simpson 1986年美国影片《壮志凌云》的主题曲 Take me to your heart Michael Learns To Rock The day you went away M2M The Color Of My Love Celine Dion 席琳·迪翁出生于加拿大魁北克省，是最著名的法语和英语流行女歌手，有流行天后之称。 Yesterday Once More The carpenters Yesterday Once More是卡朋特乐队演唱的歌曲，始创于1973年。 The Sound Of Silence Paul Simon,Garfunkel 美国电影《毕业生》的主题歌 We Will Rock You Queen 歌曲词曲由乐队吉他手布赖恩·梅制作，于1977年发行 Remember When Avril Ramona Lavigne Whibley God Is A Girl Groove Coverage 德国2001年创立的乐队Groove Coverage演唱的 Can You Feel The Love Tonight Elton John 动画电影《狮子王》的插曲，由英国歌手艾尔顿·约翰演唱 Complicated Avril Lavigne 《Complicated》是加拿大唱作女歌手艾薇儿·拉维尼演唱的一首流行歌曲 Love More Than I Can Say Bobby Vee 《《More Than I Can Say》是香港艺人许冠英的粤语歌曲《虾妹共你》的原曲 Love More Than I Can Say Bobby Vee 《《More Than I Can Say》是香港艺人许冠英的粤语歌曲《虾妹共你》的原曲 Pretty Young Thing Michael Jackson 这是《Thriller》专辑发行的第六支单曲，也是第六支热门100单曲榜上的Top 10金曲 Unchained Melod The Righteous Brothers 因电影《人鬼情未了》而流行的著名歌曲 I See You Leona Lewis 2010年为电影《阿凡达》献唱主题曲《I See You》风靡全球。 Lemon Tree Fool\u0026rsquo;s Garden 流行音乐之王的迈克尔·杰克逊于1982年发行《颤栗》专辑的主打歌曲之一 Pretty Boy M2M M2M（窈窕美眉）是由两个来自挪威的小女孩Marit及Marion所组成的团体 One Love blue 英国blue乐队发行了第二张专辑《OneLove》里的歌曲，以R\u0026amp;B曲风为主 Auld Lang Syne Robert Burns 在中国各地普遍称为友谊地久天长，是《魂断蓝桥》《Its.A.Wonderful.Life》《When Harry Met Sally》中的电影主题曲 Dangerous Michael Jackson 世界流行天王Michael Jackson（迈克尔·杰克逊）于1991年11月26日发行的专辑 Beat It Michael Jackson 《Beat It》是一首反对社会暴力音乐作品 As Long As You Love Me Backstreet Boys 后街男孩代表作之一，也是其最脍炙人口的歌曲之一 Love Story Taylor Swift 后街男孩代表作之一，也是其最脍炙人口的歌曲之一 Lonely NANA 中间唱RAP的男声才是Nana，才是主角，女声是Sibela Speak Softly Love Andy williams 电影《教父》的主题曲 Big big world Emilia Rydberg 500 miles Journeymen See You Again Wiz Khalifa，Charlie Puth 这首歌在电影中是为了缅怀因车祸逝世的速度与激情的演员Paul Walker而创作的。 Let It Go Idina Menzel /Demi Lovato 2013年动画作品《冰雪奇缘》当中的主题曲 Satisfaction The Rolling Stones 英国著名乐队滚石乐队（The Rolling Stones)演唱歌曲，居于最伟大的100首英文歌曲第二名 The Rose Amanda McBroom 《The Rose》(歌声泪痕)中作为片尾曲首唱 Oh My Love JOHN LENON Scarborough Fair Paul Simon, Art Garfunkel 1968年奥斯卡获奖片《毕业生》中的主题曲 Tears in Heaven Eric Clapton dragostea din tei O-Zone 郭美美演唱的《不怕不怕》的来源。 Gloomy Sunday Billie Holiday Tom\u0026rsquo;s Diner Suzanne Vega Hotel California The Eagles Eyes on me 王菲 I Want It That way Backstreet Boys Every Body Backstreet Boys Never Grow Old The Cranberries Dying in The Sun The Cranberries Spancil Hill The Corrs Complicated 艾薇儿 That\u0026rsquo;s Why (You Go Away) Michael Learns to Rock Show Me The Meaning Of Being Lonely Backstreet Boys Juliet LMNT Gigolo 两只蝴蝶英文版 I Feel Close To You 仓木麻衣和孙燕姿合唱 Are You The One Timo Tolkki you don\u0026rsquo;t have to say you love me M2M Numb Linkin Park The phoenix Fall Out Boy Move your body Sia Counting Stars OneRepublic 数星星 That girl Olly Murs Try Colbie Caillat Better Man Robbie Williams Canon Flamenco JerryC Beautiful Ones Suede Stand Rascal Flatts Yeah Usher ft. Lil Jon, Ludacris Yellow Coldplay Shape Of My Heart Backstreet Boys / Sting All About Us t.A.T.u. In the End Linkin Park Never Had A Dream Come True S Club 7 Anyone Of Us Gareth Gates Don\u0026rsquo;t Tell Me Avril Lavigne Crazy Frog Crazy Frog Far Away From Home Groove Coverage Thank You Dido Kiss The Rain Yiruma Earphones Victon Heal The World Michael Jackson Long Long Way To Go Def Leppard Hall Of Fame The Script ft. will.i.am Lone Ranger Rachel Platten La La La Naughty Boy ft. Sam Smith My Stupid Heart Walk Off the Earth Hymn for the Weekend Coldplay In the End Linkin Park Rolling in the Deep Adele Uptown Funk Mark Ronson ft. Bruno Mars Salt Ava Max Whataya Want from Me Adam Lambert Natural Imagine Dragons Believer Imagine Dragons Sold Out Hardy New Divide Linkin Park DJ Got Us Fallin\u0026rsquo; in Love Usher ft. Pitbull Da Da Da Trio Whistle Flo Rida Dream It Possible Delacey Talking to the Moon Bruno Mars Legends Never Die Against The Current Rise Katy Perry This is What You Asked For Bring Me The Horizon My Songs Sting Run Away Aurora Señorita Shawn Mendes \u0026amp; Camila Cabello Dance Monkey Tones and I Stronger Kanye West What Makes You Beautiful One Direction Right Now Akon The Nights Avicii Waiting for Love Avicii Beautiful Now Zedd ft. Jon Bellion Faded Alan Walker We Don’t Talk Anymore Charlie Puth ft. Selena Gomez Here With You Lost Frequencies \u0026amp; Netsky Wake Hillsong Young \u0026amp; Free Children of the Dark Mono Inc. Something Just Like This The Chainsmokers \u0026amp; Coldplay Someone Like You Adele Shape of You Ed Sheeran Sugar Maroon 5 Good Time Owl City \u0026amp; Carly Rae Jepsen I Am You Stray Kids Let Me Down Slowly Alec Benjamin Poker Face Lady Gaga Baby Justin Bieber ft. Ludacris Diamonds Rihanna Be What You Wanna Be Darin It\u0026rsquo;s My Life Bon Jovi Jealousy Martin Solveig Just One Last Dance Sarah Connor Cry on My Shoulder Supertramp /DeutschlandSuchtDenSuperstar You Raise Me Up Josh Groban /Westlife My Love Westlife All Rise Blue Smooth Criminal Michael Jackson / Alien Ant Farm Free Loop Daniel Powter 其他经典歌曲\nName Author discription Je m\u0026rsquo;appelle Hélène 伊莲·罗莱斯 法国连续25周的冠军单曲 El Cóndor Pasa (If I Could) Daniel Alomía Robles 是一首秘鲁歌曲，世界名曲 背景旋律\nName Author discription Classic River You Young Suk 最早出自2003年韩国电影《假如爱有天意》，是贯穿全片的主题旋律 ","date":"2025-03-28T20:38:00+08:00","permalink":"http://www.alvincat.top/post/others/music/","tags":[""],"title":"Music"},{"categories":["CPP"],"contents":"1 常用关键字的用法 1.1 typedef的用法 typedef提供了一种给数据类型命名的方式。这样可以极大的提高代码的可读性。\n格式大致为typedef innner_type alias_type，示例：\n1 2 3 typedef int* int_pointer; typedef unsigned char U8; typedef unsigned short U16; ","date":"2025-03-25T21:34:33+08:00","permalink":"http://www.alvincat.top/post/cpp/c_common_tips/","tags":[""],"title":"C_common_tips"},{"categories":["CSAPP"],"contents":"本文总结计算机中信息的表示和处理方法。\n2 信息的处理和表示 2.1 信息的存储 2.1.0 数字的编码 2.1.0.1 无符号数 无符号数是基于传统的二进制标识法，可以表示大于等于0的数字。\n2.1.0.2 二进制补码(two\u0026rsquo;s-complement) 二进制补码用来表示有符号整数的常见形式。\n2.1.0.3 浮点数 浮点数是以二进制为基数的实数科学计数法形式。\n2.1.1 进制转换 2.1.1.1 十进制的转换 十进制转换为其他进制的方法均使用辗转相除法即可。例如： 一个十进制数x要转换为十六进制数，可以表示为：x = q * 16 + r 。然后通过q反复进行这个过程，直到q为0为止。\n2.1.1.1.1 十进制转十六进制 例如：\nq subprocess r 314156 = 19634 * 16 + 12 (C) 19634 = 1227 * 16 + 2 (2) 1227 = 76 * 16 + 11 (B) 76 = 4 * 16 + 12 (C) 4 = 0 * 16 + 4 (4) 最终得到结果：314156 = 0x4CB2C。\n2.1.1.1.2 十进制转二进制 例如：\nq subprocess r 29 = 14 * 2 + 1 (1) 14 = 7 * 2 + 0 (0) 7 = 3 * 2 + 1 (1) 3 = 1 * 2 + 1 (1) 1 = 0 * 2 + 1 (1) 最终得到结果：29 = 11101。\n2.1.1.2 十六进制的转换 2.1.1.2.1 十六进制转十进制 十六进制数转换为十进制数，只需要将对应的十六进制位乘以16的幂，然后相加即可。例如： $ 0xACB = 10 * 16^2 + 12 * 16^1 + 11 * 16^0 = 10 * 256 + 12 * 16 + 11 = 2763$\n2.1.1.2.2 十六进制转二进制 十六机制和二进制之间的对应关系如下： 每位十六机制数对应4bit二进制。可以使用如下两种方法进行转换。\n方法1：切分法。即使用如下对照表进行转换即可。 Hex Bin Hex Bin 0 0000 8 1000 1 0001 9 1001 2 0010 A 1010 3 0011 B 1011 4 0100 C 1100 5 0101 D 1101 6 0110 E 1110 7 0111 F 1111 例如： 针对0x2DFB，转换方法如下：\n2 -\u0026gt; 0010\nD -\u0026gt; 1101\nF -\u0026gt; 1111\nB -\u0026gt; 1011\n因此0x2DFB(H) = 0010 1101 1111 1011(B)\n方法2：先将十六机制转换为十进制，然后再将十进制转换为二进制。\n十六进制转换为十进制的方法见2.1.1.2.1节。\n十进制转换为二进制的方法见2.1.1.1.2节。 温馨提示：推荐使用方法1，简单快捷。\n2.1.1.3 二进制的换换 2.1.1.3.1 二进制转十进制 二进制转换为十进制的方法和十六进制转换为10进制的方法类似。例如：\n$ 1111 1011 $\n$ = 1 * 2^7 + 1 * 2^6 + 1 * 2^5 + 1 * 2^4 + 1 * 2^3 + 0 * 2^2 + 1 * 2^1 + 1 * 2^0 $\n$ = 1 * 128 + 1 * 64 + 1 * 32 + 1 * 16 + 1 * 8 + 0 * 4 + 1 * 2 + 1 * 1 $\n$ = 128 + 64 + 32 + 16 + 8 + 0 + 2 + 1 $\n$ = 251 $\n2.1.1.3.2 二进制转十六进制 二进制转换为十六进制的方法为十六进制转换为二进制的逆过程，方法参考2.1.1.2.2节。\n唯一需要注意的地方就是：\n若使用切分法二进制转换为十六进制的时候，需要从右往进行切分，每4bit二进制对应一位十六进制数。不足4位的在左侧补0。\n例如：针对二进制数1 1010 1001 0001\n先将二进制数的数位补为4的整数倍。1 1010 1001 0001 -\u0026gt; 0001 1010 1001 0001 按照对照表进行转换：\n0001 -\u0026gt; 1(H)\n1010 -\u0026gt; A(H)\n1001 -\u0026gt; 9(H)\n0001 -\u0026gt; 1(H) 最终得到结果为： 1 1010 1001 0001 = 0x1A91(H) 2.2 整数的表示 2.3 整数的运算 2.4 浮点数 2.5 总结","date":"2025-03-07T22:13:37+08:00","permalink":"http://www.alvincat.top/post/linux/csapp/representing_manipulating_information/","tags":[""],"title":"信息的表示和处理"},{"categories":[""],"contents":"本文介绍前缀树这种数据结构。\n1 前缀树简介 前缀树是一种用于存储和查询字典或者集合中的字符串的数据结构。\n前缀树和普通的二叉树不同的是，它的结点中存储的是从根结点到当前结点的路径上的字符。\n因此每个结点的子结点都拥有相同的前缀，根结点表示空字符串。\n前缀树主要用于代码补全、拼写检查和IP路由。\n2 前缀树的代码实现","date":"2025-01-23T21:41:39+08:00","permalink":"http://www.alvincat.top/post/data_structure/tree/prefix_tree/","tags":[""],"title":"前缀树"},{"categories":[""],"contents":"VirtualBox实现宿主机访问虚拟机以及虚拟机联网的方法。\nVirtualBox实现宿主机访问虚拟机以及虚拟机联网的方法 1 VirtualBox初始设置 1.1 创建NAT网络 选中虚拟机中的系统(系统应处于关闭状态)(①),然后选择【管理\u0026ndash;\u0026gt;全局设定】（②③）。如图 1-1所示。 图 1-1\n通过图 1-1的操作打开VirtualBox全局设定对话框。然后选择【网络】（①），定位到网络子选项， 选择【NAT网络】(②),点击右侧的【添加】按钮(③)，创建一个NAT虚拟网络(④)。如图 1-2所示。单击【修改】按钮(⑤)，可以修改NAT网络的参数,如图 1-3所示：\n图 1-2\n图 1-3\n1.2 创建Host-Only网卡 类似于图 1-2，点击【仅主机（host-only）网络】（②），默认情况下，系统已经创建了一个Host-Only网卡（③）。若没有可以点击【添加】按钮（⑤），添加一个Host-Only网络。 图 1-4\n选中已经添加的Host-Only网卡，然后点击【编辑】按钮，打开【仅主机（Host-Only）网络明细】对话框，就可以对Host-Only网卡进行编辑，如图 1 5所示。Ipv4地址和子网掩码可以保持不变。 图 1-5\n点击【DHCP服务器】子选项卡，取消【启用服务器】选项，即不适用动态IP，如图 1 6所示。\n图 1-6\n1.3 VirtualBox 7.x版本配置网路的方法 图 1-7\n2 CentOS系统网络参数设置 2.1 网络连接设置 选中虚拟机中的系统(①),然后点击【设置】（②）,打开虚拟系统的设置对话框（③），如图 2 1所示： 图 2-1\n2.1.1 网卡1设置 选择【网络】（①），勾选网络连接，然后点击【网卡1】（②），连接方式选择【网络地址转换（NAT）】,其他设置同图 2 2所示即可。 图 2-2\n2.1.2 网卡2设置 点击【网卡2】（②），勾选网络连接，连接方式选择【仅主机（Host-Only）网络】（③），界面名称选择【Virtual Host-Only Ethernet Adapter】（4），其他设置同图 2 3所示即可。 图 2-3\n","date":"2025-01-23T20:41:27+08:00","permalink":"http://www.alvincat.top/post/tools/virtualbox_set_network_interface/","tags":[""],"title":"VirtualBox实现宿主机访问虚拟机以及虚拟机联网的方法"},{"categories":[""],"contents":"面试问题汇总\n1 技术类问题 1.1 使用STAR法则描述项目 STAR法则是Situation（情况）、Task（任务）、Action（行动）、Result（结果）。\n具体含义为:\nSituation：当时的背景情况是什么？ Task：当时的目标任务是什么？ Action：针对当时的情况，你采用了什么方法？ Result：结果怎样，你学习到了什么？ 2 非技术类问题 2.1 离职原因 2.2 你的职业规划是啥？ 2.3 能接受加班吗/对加班的看法？ 2.4 你的优点？ 2.5 你的缺点？ 2.6 做过的最满意/最值得骄傲的项目是什么？ 2.7 谈一谈你的一次失败经历？ 2.8 与上级意见不一致时，你将怎么办? 思路：\n1. 一般可以这样回答“我会给上级以必要的解释和提醒，在这种情况下，我会服从上级的意见。”\n2. 如果面试你的是总经理，而你所应聘的职位另有一位经理且这位经理当时不在场，可以这样回答：“对于非原则性问题，我会服从上级的意见，对于涉及公司利益的重大问题，我希望能向更高层领导反映。”\n2.9 你有什么想问面试官的吗？ 2.10 我们为什么要录用你/你的优势是什么？ 2.11 你为什么选择我们公司? 2.12 对这项工作，你有哪些可预见的困难? 2.13 你有什么业余爱好？ 回答思路：\n业余爱好能在一定程度上反映应聘者的性格、观念、心态，这是招聘单位问该问题的主要原因。 最好不要说自己没有业余爱好。 不要说自己有那些庸俗的、令人感觉不好的爱好。 最好不要说自己仅限于读书、听音乐、上网，否则可能令面试官怀疑应聘者性格孤僻。 最好能有一些户外的业余爱好来“点缀”你的形象。 2.14 谈谈你的家庭情况？","date":"2025-01-21T17:32:40+08:00","permalink":"http://www.alvincat.top/post/tools/iterview_questions/","tags":[""],"title":"面试问题汇总"},{"categories":["storage"],"contents":"本文介绍分布式系统中经典的一致性哈希算法。\n文章转载至：《16 张图解一致性哈希算法》作者：小林coding\n1 服务器集群分配请求的策略 大多数网站背后肯定不是只有一台服务器提供服务，因为单机的并发量和数据量都是有限的，所以都会用多台服务器构成集群来对外提供服务。 但是问题来了，现在有那么多个节点（后面统称服务器为节点，因为少一个字），要如何分配客户端的请求呢？\n其实这个问题就是「负载均衡问题」。解决负载均衡问题的算法很多，不同的负载均衡算法，对应的就是不同的分配策略，适应的业务场景也不同。 最简单的方式，引入一个中间的负载均衡层，让它将外界的请求「轮流」的转发给内部的集群。比如集群有 3 个节点，外界请求有 3 个，那么每个节点都会处理 1 个请求，达到了分配请求的目的。\n考虑到每个节点的硬件配置有所区别，我们可以引入权重值，将硬件配置更好的节点的权重值设高，然后根据各个节点的权重值，按照一定比重分配在不同的节点上，让硬件配置更好的节点承担更多的请求，这种算法叫做加权轮询。\n加权轮询算法使用场景是建立在每个节点存储的数据都是相同的前提。所以，每次读数据的请求，访问任意一个节点都能得到结果。 但是，加权轮询算法是无法应对「分布式系统」的，因为分布式系统中，每个节点存储的数据是不同的。\n当我们想提高系统的容量，就会将数据水平切分到不同的节点来存储，也就是将数据分布到了不同的节点。比如一个分布式 KV（key-valu） 缓存系统，某个 key 应该到哪个或者哪些节点上获得，应该是确定的，不是说任意访问一个节点都可以得到缓存结果的。\n因此，我们要想一个能应对分布式系统的负载均衡算法。\n2 哈希算法 有的同学可能很快就想到了：哈希算法。因为对同一个关键字进行哈希计算，每次计算都是相同的值，这样就可以将某个 key 确定到一个节点了，可以满足分布式系统的负载均衡需求。 哈希算法最简单的做法就是进行取模运算，比如分布式系统中有 3 个节点，基于 hash(key) % 3 公式对数据进行了映射。 如果客户端要获取指定 key 的数据，通过下面的公式可以定位节点：hash(key) % 3 如果经过上面这个公式计算后得到的值是 0，就说明该 key 需要去第一个节点获取。\n但是有一个很致命的问题，如果节点数量发生了变化，也就是在对系统做扩容或者缩容时，必须迁移改变了映射关系的数据，否则会出现查询不到数据的问题。\n举个例子，假设我们有一个由 A、B、C 三个节点组成分布式 KV 缓存系统，基于计算公式 hash(key) % 3 将数据进行了映射，每个节点存储了不同的数据：\n现在有 3 个查询 key 的请求，分别查询 key-01，key-02，key-03 的数据，这三个 key 分别经过 hash() 函数计算后的值为 hash( key-01) = 6、hash( key-02) = 7、hash(key-03) = 8，然后再对这些值进行取模运算。\n通过这样的哈希算法，每个 key 都可以定位到对应的节点。\n当 3 个节点不能满足业务需求了，这时我们增加了一个节点，节点的数量从 3 变化为 4，意味取模哈希函数中基数的变化，这样会导致大部分映射关系改变，如下图：\n比如，之前的 hash(key-01) % 3 = 0，就变成了 hash(key-01) % 4 = 2，查询 key-01 数据时，寻址到了节点 C，而 key-01 的数据是存储在节点 A 上的，不是在节点 C，所以会查询不到数据。\n同样的道理，如果我们对分布式系统进行缩容，比如移除一个节点，也会因为取模哈希函数中基数的变化，可能出现查询不到数据的问题。\n要解决这个问题的办法，就需要我们进行迁移数据，比如节点的数量从 3 变化为 4 时，要基于新的计算公式 hash(key) % 4 ，重新对数据和节点做映射。\n假设总数据条数为 M，哈希算法在面对节点数量变化时，最坏情况下所有数据都需要迁移，所以它的数据迁移规模是 O(M)，这样数据的迁移成本太高了。\n所以，我们应该要重新想一个新的算法，来避免分布式系统在扩容或者缩容时，发生过多的数据迁移。\n3 一致性哈希算法 一致性哈希算法就很好地解决了分布式系统在扩容或者缩容时，发生过多的数据迁移的问题。 一致哈希算法也用了取模运算，但与哈希算法不同的是，哈希算法是对节点的数量进行取模运算，而一致哈希算法是对 2^32 进行取模运算，是一个固定的值。 我们可以把一致哈希算法是对 2^32 进行取模运算的结果值组织成一个圆环，就像钟表一样，钟表的圆可以理解成由 60 个点组成的圆，而此处我们把这个圆想象成由 2^32 个点组成的圆，这个圆环被称为哈希环，如下图：\n一致性哈希要进行两步哈希：\n对存储节点进行哈希计算，也就是对存储节点做哈希映射，比如根据节点的 IP 地址进行哈希； 当对数据进行存储或访问时，对数据进行哈希映射； 所以，一致性哈希是指将「存储节点」和「数据」都映射到一个首尾相连的哈希环上。 问题来了，对「数据」进行哈希映射得到一个结果要怎么找到存储该数据的节点呢？\n答案是，映射的结果值往顺时针的方向的找到第一个节点，就是存储该数据的节点。\n举个例子，有 3 个节点经过哈希计算，映射到了如下图的位置： 接着，对要查询的 key-01 进行哈希计算，确定此 key-01 映射在哈希环的位置，然后从这个位置往顺时针的方向找到第一个节点，就是存储该 key-01 数据的节点。\n比如，下图中的 key-01 映射的位置，往顺时针的方向找到第一个节点就是节点 A。 所以，当需要对指定 key 的值进行读写的时候，要通过下面 2 步进行寻址：\n首先，对 key 进行哈希计算，确定此 key 在环上的位置； 然后，从这个位置沿着顺时针方向走，遇到的第一节点就是存储 key 的节点。 知道了一致哈希寻址的方式，我们来看看，如果增加一个节点或者减少一个节点会发生大量的数据迁移吗？\n假设节点数量从 3 增加到了 4，新的节点 D 经过哈希计算后映射到了下图中的位置：\n你可以看到，key-01、key-03 都不受影响，只有 key-02 需要被迁移节点 D。\n假设节点数量从 3 减少到了 2，比如将节点 A 移除： 你可以看到，key-02 和 key-03 不会受到影响，只有 key-01 需要被迁移节点 B。\n因此，在一致哈希算法中，如果增加或者移除一个节点，仅影响该节点在哈希环上顺时针相邻的后继节点，其它数据也不会受到影响。\n上面这些图中 3 个节点映射在哈希环还是比较分散的，所以看起来请求都会「均衡」到每个节点。\n但是一致性哈希算法并不保证节点能够在哈希环上分布均匀，这样就会带来一个问题，会有大量的请求集中在一个节点上。\n比如，下图中 3 个节点的映射位置都在哈希环的右半边： 这时候有一半以上的数据的寻址都会找节点 A，也就是访问请求主要集中的节点 A 上，这肯定不行的呀，说好的负载均衡呢，这种情况一点都不均衡。\n另外，在这种节点分布不均匀的情况下，进行容灾与扩容时，哈希环上的相邻节点容易受到过大影响，容易发生雪崩式的连锁反应。\n比如，上图中如果节点 A 被移除了，当节点 A 宕机后，根据一致性哈希算法的规则，其上数据应该全部迁移到相邻的节点 B 上，这样，节点 B 的数据量、访问量都会迅速增加很多倍，一旦新增的压力超过了节点 B 的处理能力上限，就会导致节点 B 崩溃，进而形成雪崩式的连锁反应。\n所以，一致性哈希算法虽然减少了数据迁移量，但是存在节点分布不均匀的问题。\n4 增加虚拟节点的一致性哈希算法 要想解决节点能在哈希环上分配不均匀的问题，就是要有大量的节点，节点数越多，哈希环上的节点分布的就越均匀。\n但问题是，实际中我们没有那么多节点。所以这个时候我们就加入虚拟节点，也就是对一个真实节点做多个副本。\n具体做法是，不再将真实节点映射到哈希环上，而是将虚拟节点映射到哈希环上，并将虚拟节点映射到实际节点，所以这里有「两层」映射关系。\n比如对每个节点分别设置 3 个虚拟节点：\n对节点 A 加上编号来作为虚拟节点：A-01、A-02、A-03 对节点 B 加上编号来作为虚拟节点：B-01、B-02、B-03 对节点 C 加上编号来作为虚拟节点：C-01、C-02、C-03 引入虚拟节点后，原本哈希环上只有 3 个节点的情况，就会变成有 9 个虚拟节点映射到哈希环上，哈希环上的节点数量多了 3 倍。 你可以看到，节点数量多了后，节点在哈希环上的分布就相对均匀了。这时候，如果有访问请求寻址到「A-01」这个虚拟节点，接着再通过「A-01」虚拟节点找到真实节点 A，这样请求就能访问到真实节点 A 了。 上面为了方便你理解，每个真实节点仅包含 3 个虚拟节点，这样能起到的均衡效果其实很有限。而在实际的工程中，虚拟节点的数量会大很多，比如 Nginx 的一致性哈希算法，每个权重为 1 的真实节点就含有160 个虚拟节点。 另外，虚拟节点除了会提高节点的均衡度，还会提高系统的稳定性。当节点变化时，会有不同的节点共同分担系统的变化，因此稳定性更高。 比如，当某个节点被移除时，对应该节点的多个虚拟节点均会移除，而这些虚拟节点按顺时针方向的下一个虚拟节点，可能会对应不同的真实节点，即这些不同的真实节点共同分担了节点变化导致的压力。 而且，有了虚拟节点后，还可以为硬件配置更好的节点增加权重，比如对权重更高的节点增加更多的虚拟机节点即可。 因此，带虚拟节点的一致性哈希方法不仅适合硬件配置不同的节点的场景，而且适合节点规模会发生变化的场景。\n5 总结 不同的负载均衡算法适用的业务场景也不同的。\n轮询这类的策略只能适用与每个节点的数据都是相同的场景，访问任意节点都能请求到数据。\n但是不适用分布式系统，因为分布式系统意味着数据水平切分到了不同的节点上，访问数据的时候，一定要寻址存储该数据的节点。\n哈希算法虽然能建立数据和节点的映射关系，但是每次在节点数量发生变化的时候，最坏情况下所有数据都需要迁移，这样太麻烦了。\n所以不适用节点数量变化的场景。为了减少迁移的数据量，就出现了一致性哈希算法。\n一致性哈希是指将「存储节点」和「数据」都映射到一个首尾相连的哈希环上。 如果增加或者移除一个节点，仅影响该节点在哈希环上顺时针相邻的后继节点，其它数据也不会受到影响。但是一致性哈希算法不能够均匀的分布节点，会出现大量请求都集中在一个节点的情况，在这种情况下进行容灾与扩容时，容易出现雪崩的连锁反应。\n为了解决一致性哈希算法不能够均匀的分布节点的问题，就需要引入虚拟节点，对一个真实节点做多个副本。\n不再将真实节点映射到哈希环上，而是将虚拟节点映射到哈希环上，并将虚拟节点映射到实际节点，所以这里有「两层」映射关系。引入虚拟节点后，可以会提高节点的均衡度，还会提高系统的稳定性。所以，带虚拟节点的一致性哈希方法不仅适合硬件配置不同的节点的场景，而且适合节点规模会发生变化的场景。\n","date":"2025-01-15T19:29:13+08:00","permalink":"http://www.alvincat.top/post/storage_system/consistent_hash/","tags":["consistent_hash"],"title":"一致性哈希算法"},{"categories":["storage"],"contents":"本文介绍raft协议。转载自：https://github.com/maemual/raft-zh_cn\n摘要 Raft 是一种为了管理复制日志的一致性算法。它提供了和 Paxos 算法相同的功能和性能，但是它的算法结构和 Paxos 不同，使得 Raft 算法更加容易理解并且更容易构建实际的系统。为了提升可理解性，Raft 将一致性算法分解成了几个关键模块，例如领导人选举、日志复制和安全性。同时它通过实施一个更强的一致性来减少需要考虑的状态的数量。一项用户研究的结果表明，对于学生而言，Raft 算法比 Paxos 算法更加容易学习。Raft 算法还包括一个新的机制来允许集群成员的动态改变，它利用重叠的大多数来保证安全性。\n1 介绍 一致性算法允许一组机器像一个整体一样工作，即使其中一些机器出现故障也能够继续工作下去。正因为如此，一致性算法在构建可信赖的大规模软件系统中扮演着重要的角色。在过去的 10 年里，Paxos 算法统治着一致性算法这一领域：绝大多数的实现都是基于 Paxos 或者受其影响。同时 Paxos 也成为了教学领域里讲解一致性问题时的示例。\n但是不幸的是，尽管有很多工作都在尝试降低它的复杂性，但是 Paxos 算法依然十分难以理解。并且，Paxos 自身的算法结构需要进行大幅的修改才能够应用到实际的系统中。因此工业界和学术界都对 Paxos 算法感到十分头疼。\n努力研究过 Paxos 算法之后，我们开始寻找一种新的一致性算法，可以为构建实际的系统和教学提供更好的基础。与 Paxos 不同，我们的首要目标是可理解性：我们是否可以在实际系统中定义一个一致性算法，并且比 Paxos 算法更容易学习。此外，我们希望该算法方便系统构建者的直觉的发展。重要的不仅仅是算法能够工作，更重要的是能够很清楚地知道它为什么能工作。\nRaft 一致性算法就是这些工作的结果。在设计 Raft 算法的时候，我们使用一些特别的技巧来提升它的可理解性，包括算法分解（Raft 主要被分成了领导人选举，日志复制和安全三个模块）和减少状态机的状态（相对于 Paxos，Raft 减少了非确定性和服务器互相处于非一致性的方式）。一份针对两所大学 43 个学生的研究表明 Raft 明显比 Paxos 算法更加容易理解。在这些学生同时学习了这两种算法之后，和 Paxos 比起来，其中 33 个学生能够回答有关于 Raft 的问题。\nRaft 算法在许多方面和现有的一致性算法都很相似（主要是 Oki 和 Liskov 的 Viewstamped Replication），但是它也有一些独特的特性：\n强领导人：和其他一致性算法相比，Raft 使用一种更强的领导能力形式。比如，日志条目只从领导人发送给其他的服务器。这种方式简化了对复制日志的管理并且使得 Raft 算法更加易于理解。 领导选举：Raft 算法使用一个随机计时器来选举领导人。这种方式只是在任何一致性算法都必须实现的心跳机制上增加了一点机制。在解决冲突的时候会更加简单快捷。 成员关系调整：Raft 使用一种共同一致的方法来处理集群成员变换的问题，在这种方法下，处于调整过程中的两种不同的配置集群中大多数机器会有重叠，这就使得集群在成员变换的时候依然可以继续工作。 我们相信，Raft 算法不论出于教学目的还是作为实践项目的基础都是要比 Paxos 或者其他一致性算法要优异的。它比其他算法更加简单，更加容易理解；它的算法描述足以实现一个现实的系统；它有好多开源的实现并且在很多公司里使用；它的安全特性已经被正式定义和证明；它的效率和其他算法比起来也不相上下。\n接下来，这篇论文会介绍以下内容：复制状态机问题（第 2 节），讨论 Paxos 的优点和缺点（第 3 节），讨论我们为了可理解性而采取的方法（第 4 节），阐述 Raft 一致性算法（第 5-8 节），评价 Raft 算法（第 9 节），以及一些相关的工作（第 10 节）。\n2 复制状态机 一致性算法是从复制状态机的背景下提出的（参考英文原文引用37）。在这种方法中，一组服务器上的状态机产生相同状态的副本，并且在一些机器宕掉的情况下也可以继续运行。复制状态机在分布式系统中被用于解决很多容错的问题。例如，大规模的系统中通常都有一个集群领导人，像 GFS、HDFS 和 RAMCloud，典型应用就是一个独立的复制状态机去管理领导选举和存储配置信息并且在领导人宕机的情况下也要存活下来。比如 Chubby 和 ZooKeeper。\n图 1 ：复制状态机的结构。一致性算法管理着来自客户端指令的复制日志。状态机从日志中处理相同顺序的相同指令，所以产生的结果也是相同的。\n复制状态机通常都是基于复制日志实现的，如图 1。每一个服务器存储一个包含一系列指令的日志，并且按照日志的顺序进行执行。每一个日志都按照相同的顺序包含相同的指令，所以每一个服务器都执行相同的指令序列。因为每个状态机都是确定的，每一次执行操作都产生相同的状态和同样的序列。\n一致性算法的任务是保证复制日志的一致性。服务器上的一致性模块接收客户端发送的指令然后添加到自己的日志中。它和其他服务器上的一致性模块进行通信来保证每一个服务器上的日志最终都以相同的顺序包含相同的请求，即使有些服务器发生故障。一旦指令被正确的复制，每一个服务器的状态机按照日志顺序处理他们，然后输出结果被返回给客户端。因此，服务器集群看起来形成了一个高可靠的状态机。\n实际系统中使用的一致性算法通常含有以下特性：\n安全性保证（绝对不会返回一个错误的结果）：在非拜占庭错误情况下，包括网络延迟、分区、丢包、重复和乱序等错误都可以保证正确。 可用性：集群中只要有大多数的机器可运行并且能够相互通信、和客户端通信，就可以保证可用。因此，一个典型的包含 5 个节点的集群可以容忍两个节点的失败。服务器被停止就认为是失败。它们稍后可能会从可靠存储的状态中恢复并重新加入集群。 不依赖时序来保证一致性：物理时钟错误或者极端的消息延迟只有在最坏情况下才会导致可用性问题。 通常情况下，一条指令可以尽可能快的在集群中大多数节点响应一轮远程过程调用时完成。小部分比较慢的节点不会影响系统整体的性能。 3 Paxos 算法的问题 在过去的 10 年里，Leslie Lamport 的 Paxos 算法几乎已经成为一致性的代名词：Paxos 是在课程教学中最经常使用的算法，同时也是大多数一致性算法实现的起点。Paxos 首先定义了一个能够达成单一决策一致的协议，比如单条的复制日志项。我们把这一子集叫做单决策 Paxos。然后通过组合多个 Paxos 协议的实例来促进一系列决策的达成。Paxos 保证安全性和活性，同时也支持集群成员关系的变更。Paxos 的正确性已经被证明，在通常情况下也很高效。\n不幸的是，Paxos 有两个明显的缺点。第一个缺点是 Paxos 算法特别的难以理解。完整的解释是出了名的不透明；通过极大的努力之后，也只有少数人成功理解了这个算法。因此，有了几次用更简单的术语来解释 Paxos 的尝试。尽管这些解释都只关注了单决策的子集问题，但依然很具有挑战性。在 2012 年 NSDI 的会议中的一次调查显示，很少有人对 Paxos 算法感到满意，甚至在经验老道的研究者中也是如此。我们自己也尝试去理解 Paxos；我们一直没能理解 Paxos 直到我们读了很多对 Paxos 的简化解释并且设计了我们自己的算法之后，这一过程花了近一年时间。\n我们假设 Paxos 的不透明性来自它选择单决策问题作为它的基础。单决策 Paxos 是晦涩微妙的，它被划分成了两种没有简单直观解释和无法独立理解的情景。因此，这导致了很难建立起直观的感受为什么单决策 Paxos 算法能够工作。构成多决策 Paxos 增加了很多错综复杂的规则。我们相信，在多决策上达成一致性的问题（一份日志而不是单一的日志记录）能够被分解成其他的方式并且更加直接和明显。\nPaxos算法的第二个问题就是它没有提供一个足够好的用来构建一个现实系统的基础。一个原因是还没有一种被广泛认同的多决策问题的算法。Lamport 的描述基本上都是关于单决策 Paxos 的；他简要描述了实施多决策 Paxos 的方法，但是缺乏很多细节。当然也有很多具体化 Paxos 的尝试，但是他们都互相不一样，和 Paxos 的概述也不同。例如 Chubby 这样的系统实现了一个类似于 Paxos 的算法，但是大多数的细节并没有被公开。\n而且，Paxos 算法的结构也不是十分易于构建实践的系统；单决策分解也会产生其他的结果。例如，独立地选择一组日志条目然后合并成一个序列化的日志并没有带来太多的好处，仅仅增加了不少复杂性。围绕着日志来设计一个系统是更加简单高效的；新日志条目以严格限制的顺序增添到日志中去。另一个问题是，Paxos 使用了一种对等的点对点的方式作为它的核心（尽管它最终提议了一种弱领导人的方法来优化性能）。在只有一个决策会被制定的简化世界中是很有意义的，但是很少有现实的系统使用这种方式。如果有一系列的决策需要被制定，首先选择一个领导人，然后让他去协调所有的决议，会更加简单快速。\n因此，实际的系统中很少有和 Paxos 相似的实践。每一种实现都是从 Paxos 开始研究，然后发现很多实现上的难题，再然后开发了一种和 Paxos 明显不一样的结构。这样是非常费时和容易出错的，并且理解 Paxos 的难度使得这个问题更加糟糕。Paxos 算法在理论上被证明是正确可行的，但是现实的系统和 Paxos 差别是如此的大，以至于这些证明没有什么太大的价值。下面来自 Chubby 实现非常典型：\n在Paxos算法描述和实现现实系统中间有着巨大的鸿沟。最终的系统建立在一种没有经过证明的算法之上。\n由于以上问题，我们认为 Paxos 算法既没有提供一个良好的基础给实践的系统，也没有给教学很好的帮助。基于一致性问题在大规模软件系统中的重要性，我们决定看看我们是否可以设计一个拥有更好特性的替代 Paxos 的一致性算法。Raft 算法就是这次实验的结果。\n4 为了可理解性的设计 设计 Raft 算法我们有几个初衷：它必须提供一个完整的实际的系统实现基础，这样才能大大减少开发者的工作；它必须在任何情况下都是安全的并且在大多数的情况下都是可用的；并且它的大部分操作必须是高效的。但是我们最重要也是最大的挑战是可理解性。它必须保证对于普遍的人群都可以十分容易的去理解。另外，它必须能够让人形成直观的认识，这样系统的构建者才能够在现实中进行必然的扩展。\n在设计 Raft 算法的时候，有很多的点需要我们在各种备选方案中进行选择。在这种情况下，我们评估备选方案基于可理解性原则：解释各个备选方案有多大的难度（例如，Raft 的状态空间有多复杂，是否有微妙的暗示）？对于一个读者而言，完全理解这个方案和暗示是否容易？\n我们意识到对这种可理解性分析上具有高度的主观性；尽管如此，我们使用了两种通常适用的技术来解决这个问题。第一个技术就是众所周知的问题分解：我们尽可能地将问题分解成几个相对独立的，可被解决的、可解释的和可理解的子问题。例如，Raft 算法被我们分成领导人选举，日志复制，安全性和成员变更几个部分。\n我们使用的第二个方法是通过减少状态的数量来简化需要考虑的状态空间，使得系统更加连贯并且在可能的时候消除不确定性。特别的，所有的日志是不允许有空洞的，并且 Raft 限制了日志之间变成不一致状态的可能。尽管在大多数情况下我们都试图消除不确定性，但是也有一些情况下不确定性可以提升可理解性。尤其是，随机化方法增加了不确定性，但是他们有利于减少状态空间数量，通过处理所有可能选择时使用相似的方法。我们使用随机化来简化 Raft 中领导人选举算法。\n5 Raft 一致性算法 Raft 是一种用来管理章节 2 中描述的复制日志的算法。图 2 为了参考之用，总结这个算法的简略版本，图 3 列举了这个算法的一些关键特性。图中的这些元素会在剩下的章节逐一介绍。\nRaft 通过选举一个杰出的领导人，然后给予他全部的管理复制日志的责任来实现一致性。领导人从客户端接收日志条目（log entries），把日志条目复制到其他服务器上，并告诉其他的服务器什么时候可以安全地将日志条目应用到他们的状态机中。拥有一个领导人大大简化了对复制日志的管理。例如，领导人可以决定新的日志条目需要放在日志中的什么位置而不需要和其他服务器商议，并且数据都从领导人流向其他服务器。一个领导人可能会发生故障，或者和其他服务器失去连接，在这种情况下一个新的领导人会被选举出来。\n通过领导人的方式，Raft 将一致性问题分解成了三个相对独立的子问题，这些问题会在接下来的子章节中进行讨论：\n领导选举：当现存的领导人发生故障的时候, 一个新的领导人需要被选举出来（章节 5.2） 日志复制：领导人必须从客户端接收日志条目（log entries）然后复制到集群中的其他节点，并强制要求其他节点的日志和自己保持一致。 安全性：在 Raft 中安全性的关键是在图 3 中展示的状态机安全：如果有任何的服务器节点已经应用了一个确定的日志条目到它的状态机中，那么其他服务器节点不能在同一个日志索引位置应用一个不同的指令。章节 5.4 阐述了 Raft 算法是如何保证这个特性的；这个解决方案涉及到选举机制（5.2 节）上的一个额外限制。 在展示一致性算法之后，这一章节会讨论一些可用性的问题和计时在系统中的作用。\n状态：\n所有服务器上的持久性状态 (在响应 RPC 请求之前，已经更新到了稳定的存储设备)\n参数 解释 currentTerm 服务器已知最新的任期（在服务器首次启动时初始化为0，单调递增） votedFor 当前任期内收到选票的 candidateId，如果没有投给任何候选人 则为空 log[] 日志条目；每个条目包含了用于状态机的命令，以及领导人接收到该条目时的任期（初始索引为1） 所有服务器上的易失性状态\n参数 解释 commitIndex 已知已提交的最高的日志条目的索引（初始值为0，单调递增） lastApplied 已经被应用到状态机的最高的日志条目的索引（初始值为0，单调递增） 领导人（服务器）上的易失性状态 (选举后已经重新初始化)\n参数 解释 nextIndex[] 对于每一台服务器，发送到该服务器的下一个日志条目的索引（初始值为领导人最后的日志条目的索引+1） matchIndex[] 对于每一台服务器，已知的已经复制到该服务器的最高日志条目的索引（初始值为0，单调递增） 追加条目（AppendEntries）RPC：\n由领导人调用，用于日志条目的复制，同时也被当做心跳使用\n参数 解释 term 领导人的任期 leaderId 领导人 ID 因此跟随者可以对客户端进行重定向（译者注：跟随者根据领导人 ID 把客户端的请求重定向到领导人，比如有时客户端把请求发给了跟随者而不是领导人） prevLogIndex 紧邻新日志条目之前的那个日志条目的索引 prevLogTerm 紧邻新日志条目之前的那个日志条目的任期 entries[] 需要被保存的日志条目（被当做心跳使用时，则日志条目内容为空；为了提高效率可能一次性发送多个） leaderCommit 领导人的已知已提交的最高的日志条目的索引 返回值 解释 term 当前任期，对于领导人而言 它会更新自己的任期 success 如果跟随者所含有的条目和 prevLogIndex 以及 prevLogTerm 匹配上了，则为 true 接收者的实现：\n返回假 如果领导人的任期小于接收者的当前任期（译者注：这里的接收者是指跟随者或者候选人）（5.1 节） 返回假 如果接收者日志中没有包含这样一个条目 即该条目的任期在 prevLogIndex 上能和 prevLogTerm 匹配上 （译者注：在接收者日志中 如果能找到一个和 prevLogIndex 以及 prevLogTerm 一样的索引和任期的日志条目 则继续执行下面的步骤 否则返回假）（5.3 节） 如果一个已经存在的条目和新条目（译者注：即刚刚接收到的日志条目）发生了冲突（因为索引相同，任期不同），那么就删除这个已经存在的条目以及它之后的所有条目 （5.3 节） 追加日志中尚未存在的任何新条目 如果领导人的已知已提交的最高日志条目的索引大于接收者的已知已提交最高日志条目的索引（leaderCommit \u0026gt; commitIndex），则把接收者的已知已经提交的最高的日志条目的索引commitIndex 重置为 领导人的已知已经提交的最高的日志条目的索引 leaderCommit 或者是 上一个新条目的索引 取两者的最小值 请求投票（RequestVote）RPC：\n由候选人负责调用用来征集选票（5.2 节）\n参数 解释 term 候选人的任期号 candidateId 请求选票的候选人的 ID lastLogIndex 候选人的最后日志条目的索引值 lastLogTerm 候选人最后日志条目的任期号 返回值 解释 term 当前任期号，以便于候选人去更新自己的任期号 voteGranted 候选人赢得了此张选票时为真 接收者实现：\n如果term \u0026lt; currentTerm返回 false （5.2 节） 如果 votedFor 为空或者为 candidateId，并且候选人的日志至少和自己一样新，那么就投票给他（5.2 节，5.4 节） 所有服务器需遵守的规则：\n所有服务器：\n如果commitIndex \u0026gt; lastApplied，则 lastApplied 递增，并将log[lastApplied]应用到状态机中（5.3 节） 如果接收到的 RPC 请求或响应中，任期号T \u0026gt; currentTerm，则令 currentTerm = T，并切换为跟随者状态（5.1 节） 跟随者（5.2 节）：\n响应来自候选人和领导人的请求 如果在超过选举超时时间的情况之前没有收到当前领导人（即该领导人的任期需与这个跟随者的当前任期相同）的心跳/附加日志，或者是给某个候选人投了票，就自己变成候选人 候选人（5.2 节）：\n在转变成候选人后就立即开始选举过程 自增当前的任期号（currentTerm） 给自己投票 重置选举超时计时器 发送请求投票的 RPC 给其他所有服务器 如果接收到大多数服务器的选票，那么就变成领导人 如果接收到来自新的领导人的附加日志（AppendEntries）RPC，则转变成跟随者 如果选举过程超时，则再次发起一轮选举 领导人：\n一旦成为领导人：发送空的附加日志（AppendEntries）RPC（心跳）给其他所有的服务器；在一定的空余时间之后不停的重复发送，以防止跟随者超时（5.2 节） 如果接收到来自客户端的请求：附加条目到本地日志中，在条目被应用到状态机后响应客户端（5.3 节） 如果对于一个跟随者，最后日志条目的索引值大于等于 nextIndex（lastLogIndex ≥ nextIndex），则发送从 nextIndex 开始的所有日志条目： 如果成功：更新相应跟随者的 nextIndex 和 matchIndex 如果因为日志不一致而失败，则 nextIndex 递减并重试 假设存在 N 满足N \u0026gt; commitIndex，使得大多数的 matchIndex[i] ≥ N以及log[N].term == currentTerm 成立，则令 commitIndex = N（5.3 和 5.4 节） 图 2：一个关于 Raft 一致性算法的浓缩总结（不包括成员变换和日志压缩）。\n特性 解释 选举安全特性 对于一个给定的任期号，最多只会有一个领导人被选举出来（5.2 节） 领导人只附加原则 领导人绝对不会删除或者覆盖自己的日志，只会增加（5.3 节） 日志匹配原则 如果两个日志在某一相同索引位置日志条目的任期号相同，那么我们就认为这两个日志从头到该索引位置之间的内容完全一致（5.3 节） 领导人完全特性 如果某个日志条目在某个任期号中已经被提交，那么这个条目必然出现在更大任期号的所有领导人中（5.4 节） 状态机安全特性 如果某一服务器已将给定索引位置的日志条目应用至其状态机中，则其他任何服务器在该索引位置不会应用不同的日志条目（5.4.3 节） 图 3：Raft 在任何时候都保证以上的各个特性。\n5.1 Raft 基础 一个 Raft 集群包含若干个服务器节点；5 个服务器节点是一个典型的例子，这允许整个系统容忍 2 个节点失效。在任何时刻，每一个服务器节点都处于这三个状态之一：领导人、跟随者或者候选人。在通常情况下，系统中只有一个领导人并且其他的节点全部都是跟随者。跟随者都是被动的：他们不会发送任何请求，只是简单的响应来自领导人或者候选人的请求。领导人处理所有的客户端请求（如果一个客户端和跟随者联系，那么跟随者会把请求重定向给领导人）。第三种状态，候选人，是用来在 5.2 节描述的选举新领导人时使用。图 4 展示了这些状态和他们之间的转换关系；这些转换关系会在接下来进行讨论。\n图 4：服务器状态。跟随者只响应来自其他服务器的请求。如果跟随者接收不到消息，那么他就会变成候选人并发起一次选举。获得集群中大多数选票的候选人将成为领导人。在一个任期内，领导人一直都会是领导人，直到自己宕机了。\n图 5：时间被划分成一个个的任期，每个任期始于一次选举。在选举成功后，领导人会管理整个集群直到任期结束。有时候选举会失败，那么这个任期就会没有领导人而结束。任期之间的切换可以在不同的时间不同的服务器上观察到。\nRaft 把时间分割成任意长度的任期，如图 5。任期用连续的整数标记。每一段任期从一次选举开始，就像章节 5.2 描述的一样，一个或者多个候选人尝试成为领导人。 如果一个候选人赢得选举，然后他就在接下来的任期内充当领导人的职责。 在某些情况下，一次选举过程会造成选票的瓜分。在这种情况下，这一任期会以没有领导人结束；一个新的任期（和一次新的选举）会很快重新开始。\nRaft 保证了在一个给定的任期内，最多只有一个领导人。\n不同的服务器节点可能多次观察到任期之间的转换，但在某些情况下，一个节点也可能观察不到任何一次选举或者整个任期全程。任期在 Raft 算法中充当逻辑时钟的作用，任期使得服务器可以检测一些过期的信息：比如过期的领导人。 每个节点存储一个当前任期号，这一编号在整个时期内单调递增。\n每当服务器之间通信的时候都会交换当前任期号；如果一个服务器的当前任期号比其他人小，那么他会更新自己的任期号到较大的任期号值。\n如果一个候选人或者领导人发现自己的任期号过期了，那么他会立即恢复成跟随者状态。\n如果一个节点接收到一个包含过期的任期号的请求，那么他会直接拒绝这个请求。\nRaft 算法中服务器节点之间通信使用远程过程调用（RPCs），并且基本的一致性算法只需要两种类型的 RPCs。请求投票（RequestVote） RPCs 由候选人在选举期间发起（章节 5.2），然后附加条目（AppendEntries）RPCs 由领导人发起，用来复制日志和提供一种心跳机制（章节 5.3）。第 7 节为了在服务器之间传输快照增加了第三种 RPC。当服务器没有及时的收到 RPC 的响应时，会进行重试， 并且他们能够并行的发起 RPCs 来获得最佳的性能。\n5.2 领导人选举 Raft 使用一种心跳机制来触发领导人选举。\n当服务器程序启动时，他们都是跟随者身份。\n一个服务器节点继续保持着跟随者状态只要他从领导人或者候选人处接收到有效的 RPCs。 领导人周期性的向所有跟随者发送心跳包（即不包含日志项内容的附加条目（AppendEntries） RPCs）来维持自己的权威。\n如果一个跟随者在一段时间里没有接收到任何消息，也就是选举超时，那么他就会认为系统中没有可用的领导人,并且发起选举以选出新的领导人。\n要开始一次选举过程，跟随者先要增加自己的当前任期号并且转换到候选人状态。然后他会并行地向集群中的其他服务器节点发送请求投票的 RPCs 来给自己投票。\n候选人会继续保持着当前状态直到以下三件事情之一发生：\n(a) 他自己赢得了这次的选举，\n(b) 其他的服务器成为领导人，\n(c) 一段时间之后没有任何一个获胜的人。这些结果会分别的在下面的段落里进行讨论。\n当一个候选人从整个集群的大多数服务器节点获得了针对同一个任期号的选票，那么他就赢得了这次选举并成为领导人。每一个服务器最多会对一个任期号投出一张选票，按照先来先服务的原则（注意：5.4 节在投票上增加了一点额外的限制）。要求大多数选票的规则确保了最多只会有一个候选人赢得此次选举（图 3 中的选举安全性）。一旦候选人赢得选举，他就立即成为领导人。然后他会向其他的服务器发送心跳消息来建立自己的权威并且阻止发起新的选举。\n在等待投票的时候，候选人可能会从其他的服务器接收到声明它是领导人的附加条目（AppendEntries）RPC。如果这个领导人的任期号（包含在此次的 RPC中）不小于候选人当前的任期号，那么候选人会承认领导人合法并回到跟随者状态。 如果此次 RPC 中的任期号比自己小，那么候选人就会拒绝这次的 RPC 并且继续保持候选人状态。\n第三种可能的结果是候选人既没有赢得选举也没有输：如果有多个跟随者同时成为候选人，那么选票可能会被瓜分以至于没有候选人可以赢得大多数人的支持。当这种情况发生的时候，每一个候选人都会超时，然后通过增加当前任期号来开始一轮新的选举。然而，没有其他机制的话，选票可能会被无限的重复瓜分。\nRaft 算法使用随机选举超时时间的方法来确保很少会发生选票瓜分的情况，就算发生也能很快的解决。为了阻止选票起初就被瓜分，选举超时时间是从一个固定的区间（例如 150-300 毫秒）随机选择。这样可以把服务器都分散开以至于在大多数情况下只有一个服务器会选举超时；然后他赢得选举并在其他服务器超时之前发送心跳包。同样的机制被用在选票瓜分的情况下。每一个候选人在开始一次选举的时候会重置一个随机的选举超时时间，然后在超时时间内等待投票的结果；这样减少了在新的选举中另外的选票瓜分的可能性。9.3 节展示了这种方案能够快速的选出一个领导人。\n领导人选举这个例子，体现了可理解性原则是如何指导我们进行方案设计的。起初我们计划使用一种排名系统：每一个候选人都被赋予一个唯一的排名，供候选人之间竞争时进行选择。如果一个候选人发现另一个候选人拥有更高的排名，那么他就会回到跟随者状态，这样高排名的候选人能够更加容易的赢得下一次选举。但是我们发现这种方法在可用性方面会有一点问题（如果高排名的服务器宕机了，那么低排名的服务器可能会超时并再次进入候选人状态。而且如果这个行为发生得足够快，则可能会导致整个选举过程都被重置掉）。我们针对算法进行了多次调整，但是每次调整之后都会有新的问题。最终我们认为随机重试的方法是更加明显和易于理解的。\n5.3 日志复制 一旦一个领导人被选举出来，他就开始为客户端提供服务。\n客户端的每一个请求都包含一条被复制状态机执行的指令。\n领导人把这条指令作为一条新的日志条目附加到日志中去，然后并行地发起附加条目 RPCs 给其他的服务器，让他们复制这条日志条目。当这条日志条目被安全地复制（下面会介绍），领导人会应用这条日志条目到它的状态机中然后把执行的结果返回给客户端。如果跟随者崩溃或者运行缓慢，再或者网络丢包，领导人会不断的重复尝试附加日志条目 RPCs （尽管已经回复了客户端）直到所有的跟随者都最终存储了所有的日志条目。\n图 6：日志由有序序号标记的条目组成。每个条目都包含创建时的任期号（图中框中的数字），和一个状态机需要执行的指令。一个条目当可以安全地被应用到状态机中去的时候，就认为是可以提交了。\n日志以图 6 展示的方式组织。每一个日志条目存储一条状态机指令和从领导人收到这条指令时的任期号。日志中的任期号用来检查是否出现不一致的情况，同时也用来保证图 3 中的某些性质。每一条日志条目同时也都有一个整数索引值来表明它在日志中的位置。\n领导人来决定什么时候把日志条目应用到状态机中是安全的；这种日志条目被称为已提交。Raft 算法保证所有已提交的日志条目都是持久化的并且最终会被所有可用的状态机执行。在领导人将创建的日志条目复制到大多数的服务器上的时候，日志条目就会被提交（例如在图 6 中的条目 7）。同时，领导人的日志中之前的所有日志条目也都会被提交，包括由其他领导人创建的条目。5.4 节会讨论某些当在领导人改变之后应用这条规则的隐晦内容，同时他也展示了这种提交的定义是安全的。领导人跟踪了最大的将会被提交的日志项的索引，并且索引值会被包含在未来的所有附加日志 RPCs （包括心跳包），这样其他的服务器才能最终知道领导人的提交位置。一旦跟随者知道一条日志条目已经被提交，那么他也会将这个日志条目应用到本地的状态机中（按照日志的顺序）。\n我们设计了 Raft 的日志机制来维护不同服务器日志之间的高层次的一致性。这么做不仅简化了系统的行为也使其更具有可预测性，同时它也是安全性保证的一个重要组件。Raft 维护着以下的特性，这些特性共同组成了图 3 中的日志匹配特性（Log Matching Property）：\n如果在不同的日志中的两个条目拥有相同的索引和任期号，那么他们存储了相同的指令。 如果在不同的日志中的两个条目拥有相同的索引和任期号，那么他们之前的所有日志条目也全部相同。 第一个特性来自这样的一个事实，领导人最多在一个任期里在指定的一个日志索引位置创建一条日志条目，同时日志条目在日志中的位置也从来不会改变。第二个特性由附加日志 RPC 的一个简单的一致性检查所保证。在发送附加日志 RPC 的时候，领导人会把新的日志条目前紧挨着的条目的索引位置和任期号包含在日志内。如果跟随者在它的日志中找不到包含相同索引位置和任期号的条目，那么他就会拒绝接收新的日志条目。一致性检查就像一个归纳步骤：一开始空的日志状态肯定是满足日志匹配特性的，然后一致性检查在日志扩展的时候保护了日志匹配特性。因此，每当附加日志 RPC 返回成功时，领导人就知道跟随者的日志一定是和自己相同的了。\n在正常的操作中，领导人和跟随者的日志保持一致性，所以附加日志 RPC 的一致性检查从来不会失败。然而，领导人崩溃的情况会使得日志处于不一致的状态（老的领导人可能还没有完全复制所有的日志条目）。这种不一致问题会在领导人和跟随者的一系列崩溃下加剧。图 7 展示了跟随者的日志可能和新的领导人不同。跟随者可能会丢失一些在新的领导人中存在的日志条目，他也可能拥有一些领导人没有的日志条目，或者两者都发生。丢失或者多出日志条目可能会持续多个任期。\n图 7：当一个领导人成功当选时，跟随者可能是任何情况（a-f）。每一个盒子表示是一个日志条目；里面的数字表示任期号。跟随者可能会缺少一些日志条目（a-b），可能会有一些未被提交的日志条目（c-d），或者两种情况都存在（e-f）。例如，场景 f 可能会这样发生，某服务器在任期 2 的时候是领导人，已附加了一些日志条目到自己的日志中，但在提交之前就崩溃了；很快这个机器就被重启了，在任期 3 重新被选为领导人，并且又增加了一些日志条目到自己的日志中；在任期 2 和任期 3 的日志被提交之前，这个服务器又宕机了，并且在接下来的几个任期里一直处于宕机状态。\n在 Raft 算法中，领导人是通过强制跟随者直接复制自己的日志来处理不一致问题的。这意味着在跟随者中的冲突的日志条目会被领导人的日志覆盖。5.4 节会阐述如何通过增加一些限制来使得这样的操作是安全的。\n要使得跟随者的日志进入和自己一致的状态，领导人必须找到最后两者达成一致的地方，然后删除跟随者从那个点之后的所有日志条目，并发送自己在那个点之后的日志给跟随者。所有的这些操作都在进行附加日志 RPCs 的一致性检查时完成。领导人针对每一个跟随者维护了一个 nextIndex，这表示下一个需要发送给跟随者的日志条目的索引地址。当一个领导人刚获得权力的时候，他初始化所有的 nextIndex 值为自己的最后一条日志的 index 加 1（图 7 中的 11）。如果一个跟随者的日志和领导人不一致，那么在下一次的附加日志 RPC 时的一致性检查就会失败。在被跟随者拒绝之后，领导人就会减小 nextIndex 值并进行重试。最终 nextIndex 会在某个位置使得领导人和跟随者的日志达成一致。当这种情况发生，附加日志 RPC 就会成功，这时就会把跟随者冲突的日志条目全部删除并且加上领导人的日志。一旦附加日志 RPC 成功，那么跟随者的日志就会和领导人保持一致，并且在接下来的任期里一直继续保持。\n如果需要的话，算法可以通过减少被拒绝的附加日志 RPCs 的次数来优化。例如，当附加日志 RPC 的请求被拒绝的时候，跟随者可以(返回)冲突条目的任期号和该任期号对应的最小索引地址。借助这些信息，领导人可以减小 nextIndex 一次性越过该冲突任期的所有日志条目；这样就变成每个任期需要一次附加条目 RPC 而不是每个条目一次。在实践中，我们十分怀疑这种优化是否是必要的，因为失败是很少发生的并且也不大可能会有这么多不一致的日志。\n通过这种机制，领导人在获得权力的时候就不需要任何特殊的操作来恢复一致性。他只需要进行正常的操作，然后日志就能在回复附加日志 RPC 的一致性检查失败的时候自动趋于一致。领导人从来不会覆盖或者删除自己的日志（图 3 的领导人只附加特性）。\n日志复制机制展示出了第 2 节中形容的一致性特性：Raft 能够接受，复制并应用新的日志条目只要大部分的机器是工作的；在通常的情况下，新的日志条目可以在一次 RPC 中被复制给集群中的大多数机器；并且单个的缓慢的跟随者不会影响整体的性能。\n5.4 安全性 前面的章节里描述了 Raft 算法是如何选举和复制日志的。然而，到目前为止描述的机制并不能充分的保证每一个状态机会按照相同的顺序执行相同的指令。例如，一个跟随者可能会进入不可用状态同时领导人已经提交了若干的日志条目，然后这个跟随者可能会被选举为领导人并且覆盖这些日志条目；因此，不同的状态机可能会执行不同的指令序列。\n这一节通过在领导选举的时候增加一些限制来完善 Raft 算法。这一限制保证了任何的领导人对于给定的任期号，都拥有了之前任期的所有被提交的日志条目（图 3 中的领导人完整特性）。增加这一选举时的限制，我们对于提交时的规则也更加清晰。最终，我们将展示对于领导人完整特性（Leader Completeness Property） 的简要证明，并且说明该特性是如何引导复制状态机做出正确行为的。\n5.4.1 选举限制 在任何基于领导人的一致性算法中，领导人都必须存储所有已经提交的日志条目。在某些一致性算法中，例如 Viewstamped Replication，某个节点即使是一开始并没有包含所有已经提交的日志条目，它也能被选为领导人。这些算法都包含一些额外的机制来识别丢失的日志条目并把他们传送给新的领导人，要么是在选举阶段要么在之后很快进行。不幸的是，这种方法会导致相当大的额外的机制和复杂性。Raft 使用了一种更加简单的方法，它可以保证在选举的时候新的领导人拥有所有之前任期中已经提交的日志条目，而不需要传送这些日志条目给领导人。这意味着日志条目的传送是单向的，只从领导人传给跟随者，并且领导人从不会覆盖自身本地日志中已经存在的条目。\nRaft 使用投票的方式来阻止一个候选人赢得选举，除非这个候选人包含了所有已经提交的日志条目。\n候选人为了赢得选举必须联系集群中的大部分节点，这意味着每一个已经提交的日志条目在这些服务器节点中肯定存在于至少一个节点上。如果候选人的日志至少和大多数的服务器节点一样新（这个新的定义会在下面讨论），那么他一定持有了所有已经提交的日志条目。\n请求投票（RequestVote） RPC 实现了这样的限制：RPC 中包含了候选人的日志信息，然后投票人会拒绝掉那些日志没有自己新的投票请求。\nRaft 通过比较两份日志中最后一条日志条目的索引值和任期号定义谁的日志比较新。\n如果两份日志最后的条目的任期号不同，那么任期号大的日志更加新。\n如果两份日志最后的条目任期号相同，那么日志比较长的那个就更加新。\n5.4.2 提交之前任期内的日志条目 如同 5.3 节介绍的那样，领导人知道一条当前任期内的日志记录是可以被提交的，只要它被存储到了大多数的服务器上。如果一个领导人在提交日志条目之前崩溃了，未来后续的领导人会继续尝试复制这条日志记录。然而，一个领导人不能断定一个之前任期里的日志条目被保存到大多数服务器上的时候就一定已经提交了。图 8 展示了一种情况，一条已经被存储到大多数节点上的老日志条目，也依然有可能会被未来的领导人覆盖掉。\n图 8：如图的时间序列展示了为什么领导人无法决定对老任期号的日志条目进行提交。在 (a) 中，S1 是领导人，部分的(跟随者)复制了索引位置 2 的日志条目。在 (b) 中，S1 崩溃了，然后 S5 在任期 3 里通过 S3、S4 和自己的选票赢得选举，然后从客户端接收了一条不一样的日志条目放在了索引 2 处。然后到 (c)，S5 又崩溃了；S1 重新启动，选举成功，开始复制日志。在这时，来自任期 2 的那条日志已经被复制到了集群中的大多数机器上，但是还没有被提交。如果 S1 在 (d) 中又崩溃了，S5 可以重新被选举成功（通过来自 S2，S3 和 S4 的选票），然后覆盖了他们在索引 2 处的日志。反之，如果在崩溃之前，S1 把自己主导的新任期里产生的日志条目复制到了大多数机器上，就如 (e) 中那样，那么在后面任期里面这些新的日志条目就会被提交（因为 S5 就不可能选举成功）。 这样在同一时刻就同时保证了，之前的所有老的日志条目就会被提交。\n为了消除图 8 里描述的情况，Raft 永远不会通过计算副本数目的方式去提交一个之前任期内的日志条目。只有领导人当前任期里的日志条目通过计算副本数目可以被提交；一旦当前任期的日志条目以这种方式被提交，那么由于日志匹配特性，之前的日志条目也都会被间接的提交。在某些情况下，领导人可以安全的知道一个老的日志条目是否已经被提交（例如，该条目是否存储到所有服务器上），但是 Raft 为了简化问题使用一种更加保守的方法。\n当领导人复制之前任期里的日志时，Raft 会为所有日志保留原始的任期号, 这在提交规则上产生了额外的复杂性。在其他的一致性算法中，如果一个新的领导人要重新复制之前的任期里的日志时，它必须使用当前新的任期号。Raft 使用的方法更加容易辨别出日志，因为它可以随着时间和日志的变化对日志维护着同一个任期编号。另外，和其他的算法相比，Raft 中的新领导人只需要发送更少日志条目（其他算法中必须在他们被提交之前发送更多的冗余日志条目来为他们重新编号）。\n5.4.3 安全性论证 在给定了完整的 Raft 算法之后，我们现在可以更加精确的讨论领导人完整性特性（这一讨论基于 9.2 节的安全性证明）。我们假设领导人完全性特性是不存在的，然后我们推出矛盾来。假设任期 T 的领导人（领导人 T）在任期内提交了一条日志条目，但是这条日志条目没有被存储到未来某个任期的领导人的日志中。设大于 T 的最小任期 U 的领导人 U 没有这条日志条目。\n图 9：如果 S1 （任期 T 的领导人）在它的任期里提交了一条新的日志，然后 S5 在之后的任期 U 里被选举为领导人，那么至少会有一个机器，如 S3，既拥有来自 S1 的日志，也给 S5 投票了。\n在领导人 U 选举的时候一定没有那条被提交的日志条目（领导人从不会删除或者覆盖任何条目）。 领导人 T 复制这条日志条目给集群中的大多数节点，同时，领导人 U 从集群中的大多数节点赢得了选票。因此，至少有一个节点（投票者、选民）同时接受了来自领导人 T 的日志条目，并且给领导人 U 投票了，如图 9。这个投票者是产生这个矛盾的关键。 这个投票者必须在给领导人 U 投票之前先接受了从领导人 T 发来的已经被提交的日志条目；否则他就会拒绝来自领导人 T 的附加日志请求（因为此时他的任期号会比 T 大）。 投票者在给领导人 U 投票时依然保存有这条日志条目，因为任何中间的领导人都包含该日志条目（根据上述的假设），领导人从不会删除条目，并且跟随者只有在和领导人冲突的时候才会删除条目。 投票者把自己选票投给领导人 U 时，领导人 U 的日志必须和投票者自己一样新。这就导致了两者矛盾之一。 首先，如果投票者和领导人 U 的最后一条日志的任期号相同，那么领导人 U 的日志至少和投票者一样长，所以领导人 U 的日志一定包含所有投票者的日志。这是另一处矛盾，因为投票者包含了那条已经被提交的日志条目，但是在上述的假设里，领导人 U 是不包含的。 除此之外，领导人 U 的最后一条日志的任期号就必须比投票人大了。此外，他也比 T 大，因为投票人的最后一条日志的任期号至少和 T 一样大（他包含了来自任期 T 的已提交的日志）。创建了领导人 U 最后一条日志的之前领导人一定已经包含了那条被提交的日志（根据上述假设，领导人 U 是第一个不包含该日志条目的领导人）。所以，根据日志匹配特性，领导人 U 一定也包含那条被提交的日志，这里产生矛盾。 这里完成了矛盾。因此，所有比 T 大的领导人一定包含了所有来自 T 的已经被提交的日志。 日志匹配原则保证了未来的领导人也同时会包含被间接提交的条目，例如图 8 (e) 中的索引 2。 通过领导人完全特性，我们就能证明图 3 中的状态机安全特性，即如果服务器已经在某个给定的索引值应用了日志条目到自己的状态机里，那么其他的服务器不会应用一个不一样的日志到同一个索引值上。在一个服务器应用一条日志条目到他自己的状态机中时，他的日志必须和领导人的日志，在该条目和之前的条目上相同，并且已经被提交。现在我们来考虑在任何一个服务器应用一个指定索引位置的日志的最小任期；日志完全特性保证拥有更高任期号的领导人会存储相同的日志条目，所以之后的任期里应用某个索引位置的日志条目也会是相同的值。因此，状态机安全特性是成立的。\n最后，Raft 要求服务器按照日志中索引位置顺序应用日志条目。和状态机安全特性结合起来看，这就意味着所有的服务器会应用相同的日志序列集到自己的状态机中，并且是按照相同的顺序。\n5.5 跟随者和候选人崩溃 到目前为止，我们都只关注了领导人崩溃的情况。跟随者和候选人崩溃后的处理方式比领导人要简单的多，并且他们的处理方式是相同的。如果跟随者或者候选人崩溃了，那么后续发送给他们的 RPCs 都会失败。Raft 中处理这种失败就是简单地通过无限的重试；如果崩溃的机器重启了，那么这些 RPC 就会完整的成功。如果一个服务器在完成了一个 RPC，但是还没有响应的时候崩溃了，那么在他重新启动之后就会再次收到同样的请求。Raft 的 RPCs 都是幂等的，所以这样重试不会造成任何问题。例如一个跟随者如果收到附加日志请求但是他已经包含了这一日志，那么他就会直接忽略这个新的请求。\n5.6 时间和可用性 Raft 的要求之一就是安全性不能依赖时间：整个系统不能因为某些事件运行的比预期快一点或者慢一点就产生了错误的结果。但是，可用性（系统可以及时的响应客户端）不可避免的要依赖于时间。例如，如果消息交换比服务器故障间隔时间长，候选人将没有足够长的时间来赢得选举；没有一个稳定的领导人，Raft 将无法工作。\n领导人选举是 Raft 中对时间要求最为关键的方面。Raft 可以选举并维持一个稳定的领导人,只要系统满足下面的时间要求：\n广播时间（broadcastTime） \u0026laquo; 选举超时时间（electionTimeout） \u0026laquo; 平均故障间隔时间（MTBF）\n在这个不等式中，广播时间指的是从一个服务器并行的发送 RPCs 给集群中的其他服务器并接收响应的平均时间；选举超时时间就是在 5.2 节中介绍的选举的超时时间限制；然后平均故障间隔时间就是对于一台服务器而言，两次故障之间的平均时间。广播时间必须比选举超时时间小一个量级，这样领导人才能够发送稳定的心跳消息来阻止跟随者开始进入选举状态；通过随机化选举超时时间的方法，这个不等式也使得选票瓜分的情况变得不可能。选举超时时间应该要比平均故障间隔时间小上几个数量级，这样整个系统才能稳定的运行。当领导人崩溃后，整个系统会大约相当于选举超时的时间里不可用；我们希望这种情况在整个系统的运行中很少出现。\n广播时间和平均故障间隔时间是由系统决定的，但是选举超时时间是我们自己选择的。Raft 的 RPCs 需要接收方将信息持久化的保存到稳定存储中去，所以广播时间大约是 0.5 毫秒到 20 毫秒，取决于存储的技术。因此，选举超时时间可能需要在 10 毫秒到 500 毫秒之间。大多数的服务器的平均故障间隔时间都在几个月甚至更长，很容易满足时间的需求。\n6 集群成员变化 到目前为止，我们都假设集群的配置（加入到一致性算法的服务器集合）是固定不变的。但是在实践中，偶尔是会改变集群的配置的，例如替换那些宕机的机器或者改变复制级别。尽管可以通过暂停整个集群，更新所有配置，然后重启整个集群的方式来实现，但是在更改的时候集群会不可用。另外，如果存在手工操作步骤，那么就会有操作失误的风险。为了避免这样的问题，我们决定自动化配置改变并且将其纳入到 Raft 一致性算法中来。\n为了让配置修改机制能够安全，那么在转换的过程中不能够存在任何时间点使得两个领导人在同一个任期里同时被选举成功。不幸的是，任何服务器直接从旧的配置直接转换到新的配置的方案都是不安全的。一次性原子地转换所有服务器是不可能的，所以在转换期间整个集群存在划分成两个独立的大多数群体的可能性（见图 10）。\n图 10：直接从一种配置转到新的配置是十分不安全的，因为各个机器可能在任何的时候进行转换。在这个例子中，集群配额从 3 台机器变成了 5 台。不幸的是，存在这样的一个时间点，两个不同的领导人在同一个任期里都可以被选举成功。一个是通过旧的配置，一个通过新的配置。\n为了保证安全性，配置更改必须使用两阶段方法。目前有很多种两阶段的实现。例如，有些系统在第一阶段停掉旧的配置所以集群就不能处理客户端请求；然后在第二阶段在启用新的配置。在 Raft 中，集群先切换到一个过渡的配置，我们称之为共同一致（joint consensus)；一旦共同一致已经被提交了，那么系统就切换到新的配置上。共同一致是老配置和新配置的结合：\n日志条目被复制给集群中新、老配置的所有服务器。 新、旧配置的服务器都可以成为领导人。 达成一致（针对选举和提交）需要分别在两种配置上获得大多数的支持。 共同一致允许独立的服务器在不影响安全性的前提下，在不同的时间进行配置转换过程。此外，共同一致可以让集群在配置转换的过程中依然响应客户端的请求。\n集群配置在复制日志中以特殊的日志条目来存储和通信；图 11 展示了配置转换的过程。当一个领导人接收到一个改变配置从 C-old 到 C-new 的请求，他会为了共同一致存储配置（图中的 C-old,new），以前面描述的日志条目和副本的形式。一旦一个服务器将新的配置日志条目增加到它的日志中，他就会用这个配置来做出未来所有的决定（服务器总是使用最新的配置，无论他是否已经被提交）。这意味着领导人要使用 C-old,new 的规则来决定日志条目 C-old,new 什么时候需要被提交。如果领导人崩溃了，被选出来的新领导人可能是使用 C-old 配置也可能是 C-old,new 配置，这取决于赢得选举的候选人是否已经接收到了 C-old,new 配置。在任何情况下， C-new 配置在这一时期都不会单方面的做出决定。\n一旦 C-old,new 被提交，那么无论是 C-old 还是 C-new，如果不经过另一个配置的允许都不能单独做出决定，并且领导人完全特性保证了只有拥有 C-old,new 日志条目的服务器才有可能被选举为领导人。这个时候，领导人创建一条关于 C-new 配置的日志条目并复制给集群就是安全的了。再者，每个服务器在见到新的配置的时候就会立即生效。当新的配置在 C-new 的规则下被提交，旧的配置就变得无关紧要，同时不使用新的配置的服务器就可以被关闭了。如图 11，C-old 和 C-new 没有任何机会同时做出单方面的决定；这保证了安全性。\n图 11：一个配置切换的时间线。虚线表示已经被创建但是还没有被提交的配置日志条目，实线表示最后被提交的配置日志条目。领导人首先创建了 C-old,new 的配置条目在自己的日志中，并提交到 C-old,new 中（C-old 的大多数和 C-new 的大多数）。然后他创建 C-new 条目并提交到 C-new 中的大多数。这样就不存在 C-new 和 C-old 可以同时做出决定的时间点。\n在关于重新配置还有三个问题需要提出。第一个问题是，新的服务器可能初始化没有存储任何的日志条目。当这些服务器以这种状态加入到集群中，那么他们需要一段时间来更新追赶，这时还不能提交新的日志条目。为了避免这种可用性的间隔时间，Raft 在配置更新之前使用了一种额外的阶段，在这个阶段，新的服务器以没有投票权身份加入到集群中来（领导人复制日志给他们，但是不考虑他们是大多数）。一旦新的服务器追赶上了集群中的其他机器，重新配置可以像上面描述的一样处理。\n第二个问题是，集群的领导人可能不是新配置的一员。在这种情况下，领导人就会在提交了 C-new 日志之后退位（回到跟随者状态）。这意味着有这样的一段时间，领导人管理着集群，但是不包括他自己；他复制日志但是不把他自己算作是大多数之一。当 C-new 被提交时，会发生领导人过渡，因为这时是最早新的配置可以独立工作的时间点（将总是能够在 C-new 配置下选出新的领导人）。在此之前，可能只能从 C-old 中选出领导人。\n第三个问题是，移除不在 C-new 中的服务器可能会扰乱集群。这些服务器将不会再接收到心跳，所以当选举超时，他们就会进行新的选举过程。他们会发送拥有新的任期号的请求投票 RPCs，这样会导致当前的领导人回退成跟随者状态。新的领导人最终会被选出来，但是被移除的服务器将会再次超时，然后这个过程会再次重复，导致整体可用性大幅降低。\n为了避免这个问题，当服务器确认当前领导人存在时，服务器会忽略请求投票 RPCs。确切地说，当服务器在当前最小选举超时时间内收到一个请求投票 RPC，他不会更新当前的任期号或者投出选票。这不会影响正常的选举，每个服务器在开始一次选举之前，至少等待一个最小选举超时时间。然而，这有利于避免被移除的服务器扰乱：如果领导人能够发送心跳给集群，那么他就不会被更大的任期号废黜。\n7 日志压缩 Raft 的日志在正常操作中不断地增长，但是在实际的系统中，日志不能无限制地增长。随着日志不断增长，他会占用越来越多的空间，花费越来越多的时间来重置。如果没有一定的机制去清除日志里积累的陈旧的信息，那么会带来可用性问题。\n快照是最简单的压缩方法。在快照系统中，整个系统的状态都以快照的形式写入到稳定的持久化存储中，然后到那个时间点之前的日志全部丢弃。快照技术被使用在 Chubby 和 ZooKeeper 中，接下来的章节会介绍 Raft 中的快照技术。\n增量压缩的方法，例如日志清理或者日志结构合并树，都是可行的。这些方法每次只对一小部分数据进行操作，这样就分散了压缩的负载压力。首先，他们先选择一个已经积累的大量已经被删除或者被覆盖对象的区域，然后重写那个区域还活跃的对象，之后释放那个区域。和简单操作整个数据集合的快照相比，需要增加复杂的机制来实现。状态机可以实现 LSM tree 使用和快照相同的接口，但是日志清除方法就需要修改 Raft 了。\n图 12：一个服务器用新的快照替换了从 1 到 5 的条目，快照值存储了当前的状态。快照中包含了最后的索引位置和任期号。\n图 12 展示了 Raft 中快照的基础思想。每个服务器独立地创建快照，只包括已经被提交的日志。主要的工作包括将状态机的状态写入到快照中。Raft 也包含一些少量的元数据到快照中：最后被包含索引指的是被快照取代的最后的条目在日志中的索引值（状态机最后应用的日志），最后被包含的任期指的是该条目的任期号。保留这些数据是为了支持快照后紧接着的第一个条目的附加日志请求时的一致性检查，因为这个条目需要前一日志条目的索引值和任期号。为了支持集群成员更新（第 6 节），快照中也将最后的一次配置作为最后一个条目存下来。一旦服务器完成一次快照，他就可以删除最后索引位置之前的所有日志和快照了。\n尽管通常服务器都是独立地创建快照，但是领导人必须偶尔的发送快照给一些落后的跟随者。这通常发生在当领导人已经丢弃了下一条需要发送给跟随者的日志条目的时候。幸运的是这种情况不是常规操作：一个与领导人保持同步的跟随者通常都会有这个条目。然而一个运行非常缓慢的跟随者或者新加入集群的服务器（第 6 节）将不会有这个条目。这时让这个跟随者更新到最新的状态的方式就是通过网络把快照发送给他们。\n安装快照 RPC：\n由领导人调用以将快照的分块发送给跟随者。领导人总是按顺序发送分块。\n参数 解释 term 领导人的任期号 leaderId 领导人的 ID，以便于跟随者重定向请求 lastIncludedIndex 快照中包含的最后日志条目的索引值 lastIncludedTerm 快照中包含的最后日志条目的任期号 offset 分块在快照中的字节偏移量 data[] 从偏移量开始的快照分块的原始字节 done 如果这是最后一个分块则为 true 结果 解释 term 当前任期号（currentTerm），便于领导人更新自己 接收者实现：\n如果term \u0026lt; currentTerm就立即回复 如果是第一个分块（offset 为 0）就创建一个新的快照 在指定偏移量写入数据 如果 done 是 false，则继续等待更多的数据 保存快照文件，丢弃具有较小索引的任何现有或部分快照 如果现存的日志条目与快照中最后包含的日志条目具有相同的索引值和任期号，则保留其后的日志条目并进行回复 丢弃整个日志 使用快照重置状态机（并加载快照的集群配置） 图 13：一个关于安装快照的简要概述。为了便于传输，快照都是被分成分块的；每个分块都给了跟随者生命的迹象，所以跟随者可以重置选举超时计时器。\n在这种情况下领导人使用一种叫做安装快照的新的 RPC 来发送快照给太落后的跟随者；见图 13。当跟随者通过这种 RPC 接收到快照时，他必须自己决定对于已经存在的日志该如何处理。通常快照会包含没有在接收者日志中存在的信息。在这种情况下，跟随者丢弃其整个日志；它全部被快照取代，并且可能包含与快照冲突的未提交条目。如果接收到的快照是自己日志的前面部分（由于网络重传或者错误），那么被快照包含的条目将会被全部删除，但是快照后面的条目仍然有效，必须保留。\n这种快照的方式背离了 Raft 的强领导人原则，因为跟随者可以在不知道领导人情况下创建快照。但是我们认为这种背离是值得的。领导人的存在，是为了解决在达成一致性的时候的冲突，但是在创建快照的时候，一致性已经达成，这时不存在冲突了，所以没有领导人也是可以的。数据依然是从领导人传给跟随者，只是跟随者可以重新组织他们的数据了。\n我们考虑过一种替代的基于领导人的快照方案，即只有领导人创建快照，然后发送给所有的跟随者。但是这样做有两个缺点。第一，发送快照会浪费网络带宽并且延缓了快照处理的时间。每个跟随者都已经拥有了所有产生快照需要的信息，而且很显然，自己从本地的状态中创建快照比通过网络接收别人发来的要经济。第二，领导人的实现会更加复杂。例如，领导人需要发送快照的同时并行的将新的日志条目发送给跟随者，这样才不会阻塞新的客户端请求。\n还有两个问题影响了快照的性能。首先，服务器必须决定什么时候应该创建快照。如果快照创建的过于频繁，那么就会浪费大量的磁盘带宽和其他资源；如果创建快照频率太低，他就要承受耗尽存储容量的风险，同时也增加了从日志重建的时间。一个简单的策略就是当日志大小达到一个固定大小的时候就创建一次快照。如果这个阈值设置的显著大于期望的快照的大小，那么快照对磁盘压力的影响就会很小了。\n第二个影响性能的问题就是写入快照需要花费显著的一段时间，并且我们还不希望影响到正常操作。解决方案是通过写时复制的技术，这样新的更新就可以被接收而不影响到快照。例如，具有函数式数据结构的状态机天然支持这样的功能。另外，操作系统的写时复制技术的支持（如 Linux 上的 fork）可以被用来创建完整的状态机的内存快照（我们的实现就是这样的）。\n8 客户端交互 这一节将介绍客户端是如何和 Raft 进行交互的，包括客户端如何发现领导人和 Raft 是如何支持线性化语义的。这些问题对于所有基于一致性的系统都存在，并且 Raft 的解决方案和其他的也差不多。\nRaft 中的客户端发送所有请求给领导人。当客户端启动的时候，他会随机挑选一个服务器进行通信。如果客户端第一次挑选的服务器不是领导人，那么那个服务器会拒绝客户端的请求并且提供他最近接收到的领导人的信息（附加条目请求包含了领导人的网络地址）。如果领导人已经崩溃了，那么客户端的请求就会超时；客户端之后会再次重试随机挑选服务器的过程。\n我们 Raft 的目标是要实现线性化语义（每一次操作立即执行，只执行一次，在他调用和收到回复之间）。但是，如上述，Raft 是可能执行同一条命令多次的：例如，如果领导人在提交了这条日志之后，但是在响应客户端之前崩溃了，那么客户端会和新的领导人重试这条指令，导致这条命令就被再次执行了。解决方案就是客户端对于每一条指令都赋予一个唯一的序列号。然后，状态机跟踪每条指令最新的序列号和相应的响应。如果接收到一条指令，它的序列号已经被执行了，那么就立即返回结果，而不重新执行指令。\n只读的操作可以直接处理而不需要记录日志。但是，在不增加任何限制的情况下，这么做可能会冒着返回脏数据的风险，因为响应客户端请求的领导人可能在他不知道的时候已经被新的领导人取代了。线性化的读操作必须不能返回脏数据，Raft 需要使用两个额外的措施在不使用日志的情况下保证这一点。首先，领导人必须有关于被提交日志的最新信息。领导人完全特性保证了领导人一定拥有所有已经被提交的日志条目，但是在他任期开始的时候，他可能不知道哪些是已经被提交的。为了知道这些信息，他需要在他的任期里提交一条日志条目。Raft 中通过领导人在任期开始的时候提交一个空白的没有任何操作的日志条目到日志中去来实现。第二，领导人在处理只读的请求之前必须检查自己是否已经被废黜了（他自己的信息已经变脏了如果一个更新的领导人被选举出来）。Raft 中通过让领导人在响应只读请求之前，先和集群中的大多数节点交换一次心跳信息来处理这个问题。可选的，领导人可以依赖心跳机制来实现一种租约的机制，但是这种方法依赖时间来保证安全性（假设时间误差是有界的）。\n9 算法实现和评估 我们已经为 RAMCloud 实现了 Raft 算法作为存储配置信息的复制状态机的一部分，并且帮助 RAMCloud 协调故障转移。这个 Raft 实现包含大约 2000 行 C++ 代码，其中不包括测试、注释和空行。这些代码是开源的。同时也有大约 25 个其他独立的第三方的基于这篇论文草稿的开源实现，针对不同的开发场景。同时，很多公司已经部署了基于 Raft 的系统。\n这一节会从三个方面来评估 Raft 算法：可理解性、正确性和性能。\n9.1 可理解性 为了和 Paxos 比较 Raft 算法的可理解能力，我们针对高层次的本科生和研究生，在斯坦福大学的高级操作系统课程和加州大学伯克利分校的分布式计算课程上，进行了一次学习的实验。我们分别拍了针对 Raft 和 Paxos 的视频课程，并准备了相应的小测验。Raft 的视频讲课覆盖了这篇论文的所有内容除了日志压缩；Paxos 讲课包含了足够的资料来创建一个等价的复制状态机，包括单决策 Paxos，多决策 Paxos，重新配置和一些实际系统需要的性能优化（例如领导人选举）。小测验测试一些对算法的基本理解和解释一些边角的示例。每个学生都是看完第一个视频，回答相应的测试，再看第二个视频，回答相应的测试。大约有一半的学生先进行 Paxos 部分，然后另一半先进行 Raft 部分，这是为了说明两者从第一部分的算法学习中获得的表现和经验的差异。我们计算参加人员的每一个小测验的得分来看参与者是否在 Raft 算法上更加容易理解。\n我们尽可能的使得 Paxos 和 Raft 的比较更加公平。这个实验偏爱 Paxos 表现在两个方面：43 个参加者中有 15 个人在之前有一些 Paxos 的经验，并且 Paxos 的视频要长 14%。如表格 1 总结的那样，我们采取了一些措施来减轻这种潜在的偏见。我们所有的材料都可供审查。\n关心 缓和偏见采取的手段 可供查看的材料 相同的讲课质量 两者使用同一个讲师。Paxos 使用的是现在很多大学里经常使用的。Paxos 会长 14%。 视频 相同的测验难度 问题以难度分组，在两个测验里成对出现。 小测验 公平评分 使用评价量规。随机顺序打分，两个测验交替进行。 评价量规（rubric） 表 1：考虑到可能会存在的偏见，对于每种情况的解决方法，和相应的材料。\n参加者平均在 Raft 的测验中比 Paxos 高 4.9 分（总分 60，那么 Raft 的平均得分是 25.7，而 Paxos 是 20.8）；图 14 展示了每个参与者的得分。配置t-检验（又称student‘s t-test）表明，在 95% 的可信度下，真实的 Raft 分数分布至少比 Paxos 高 2.5 分。\n图 14：一个散点图表示了 43 个学生在 Paxos 和 Raft 的小测验中的成绩。在对角线之上的点表示在 Raft 获得了更高分数的学生。\n我们也建立了一个线性回归模型来预测一个新的学生的测验成绩，基于以下三个因素：他们使用的是哪个小测验，之前对 Paxos 的经验，和学习算法的顺序。模型预测，对小测验的选择会产生 12.5 分的差别。这显著的高于之前的 4.9 分，因为很多学生在之前都已经有了对于 Paxos 的经验，这相当明显的帮助 Paxos，对 Raft 就没什么太大影响了。但是奇怪的是，模型预测对于先进行 Paxos 小测验的人而言，Raft的得分低了6.3分; 虽然我们不知道为什么，这似乎在统计上是有意义的。\n我们同时也在测验之后调查了参与者，他们认为哪个算法更加容易实现和解释；这个的结果在图 15 上。压倒性的结果表明 Raft 算法更加容易实现和解释（41 人中的 33个）。但是，这种自己报告的结果不如参与者的成绩更加可信，并且参与者可能因为我们的 Raft 更加易于理解的假说而产生偏见。\n图 15：通过一个 5 分制的问题，参与者（左边）被问哪个算法他们觉得在一个高效正确的系统里更容易实现，右边被问哪个更容易向学生解释。\n关于 Raft 用户学习有一个更加详细的讨论。\n9.2 正确性 在第 5 节，我们已经制定了正式的规范，和对一致性机制的安全性证明。这个正式规范使用 TLA+ 规范语言使图 2 中总结的信息非常清晰。它长约400行，并作为证明的主题。同时对于任何想实现 Raft 的人也是十分有用的。我们通过 TLA 证明系统非常机械的证明了日志完全特性。然而，这个证明依赖的约束前提还没有被机械证明（例如，我们还没有证明规范的类型安全）。而且，我们已经写了一个非正式的证明关于状态机安全性是完备的，并且是相当清晰的（大约 3500 个词）。\n9.3 性能 Raft 和其他一致性算法例如 Paxos 有着差不多的性能。在性能方面，最重要的关注点是，当领导人被选举成功时，什么时候复制新的日志条目。Raft 通过很少数量的消息包（一轮从领导人到集群大多数机器的消息）就达成了这个目的。同时，进一步提升 Raft 的性能也是可行的。例如，很容易通过支持批量操作和管道操作来提高吞吐量和降低延迟。对于其他一致性算法已经提出过很多性能优化方案；其中有很多也可以应用到 Raft 中来，但是我们暂时把这个问题放到未来的工作中去。\n我们使用我们自己的 Raft 实现来衡量 Raft 领导人选举的性能并且回答两个问题。首先，领导人选举的过程收敛是否快速？第二，在领导人宕机之后，最小的系统宕机时间是多久？\n图 16：发现并替换一个已经崩溃的领导人的时间。上面的图考察了在选举超时时间上的随机化程度，下面的图考察了最小选举超时时间。每条线代表了 1000 次实验（除了 150-150 毫秒只试了 100 次），和相应的确定的选举超时时间。例如，150-155 毫秒意思是，选举超时时间从这个区间范围内随机选择并确定下来。这个实验在一个拥有 5 个节点的集群上进行，其广播时延大约是 15 毫秒。对于 9 个节点的集群，结果也差不多。\n为了衡量领导人选举，我们反复的使一个拥有五个节点的服务器集群的领导人宕机，并计算需要多久才能发现领导人已经宕机并选出一个新的领导人（见图 16）。为了构建一个最坏的场景，在每一的尝试里，服务器都有不同长度的日志，意味着有些候选人是没有成为领导人的资格的。另外，为了促成选票瓜分的情况，我们的测试脚本在终止领导人之前同步的发送了一次心跳广播（这大约和领导人在崩溃前复制一个新的日志给其他机器很像）。领导人均匀的随机的在心跳间隔里宕机，也就是最小选举超时时间的一半。因此，最小宕机时间大约就是最小选举超时时间的一半。\n图 16 中上面的图表明，只需要在选举超时时间上使用很少的随机化就可以大大避免选票被瓜分的情况。在没有随机化的情况下，在我们的测试里，选举过程往往都需要花费超过 10 秒钟由于太多的选票瓜分的情况。仅仅增加 5 毫秒的随机化时间，就大大的改善了选举过程，现在平均的宕机时间只有 287 毫秒。增加更多的随机化时间可以大大改善最坏情况：通过增加 50 毫秒的随机化时间，最坏的完成情况（1000 次尝试）只要 513 毫秒。\n图 16 中下面的图显示，通过减少选举超时时间可以减少系统的宕机时间。在选举超时时间为 12-24 毫秒的情况下，只需要平均 35 毫秒就可以选举出新的领导人（最长的一次花费了 152 毫秒）。然而，进一步降低选举超时时间的话就会违反 Raft 的时间不等式需求：在选举新领导人之前，领导人就很难发送完心跳包。这会导致没有意义的领导人改变并降低了系统整体的可用性。我们建议使用更为保守的选举超时时间，比如 150-300 毫秒；这样的时间不大可能导致没有意义的领导人改变，而且依然提供不错的可用性。\n10 相关工作 已经有很多关于一致性算法的工作被发表出来，其中很多都可以归到下面的类别中：\nLamport 关于 Paxos 的原始描述，和尝试描述的更清晰。 关于 Paxos 的更详尽的描述，补充遗漏的细节并修改算法，使得可以提供更加容易的实现基础。 实现一致性算法的系统，例如 Chubby，ZooKeeper 和 Spanner。对于 Chubby 和 Spanner 的算法并没有公开发表其技术细节，尽管他们都声称是基于 Paxos 的。ZooKeeper 的算法细节已经发表，但是和 Paxos 着实有着很大的差别。 Paxos 可以应用的性能优化。 Oki 和 Liskov 的 Viewstamped Replication（VR），一种和 Paxos 差不多的替代算法。原始的算法描述和分布式传输协议耦合在了一起，但是核心的一致性算法在最近的更新里被分离了出来。VR 使用了一种基于领导人的方法，和 Raft 有很多相似之处。 Raft 和 Paxos 最大的不同之处就在于 Raft 的强领导特性：Raft 使用领导人选举作为一致性协议里必不可少的部分，并且将尽可能多的功能集中到了领导人身上。这样就可以使得算法更加容易理解。例如，在 Paxos 中，领导人选举和基本的一致性协议是正交的：领导人选举仅仅是性能优化的手段，而且不是一致性所必须要求的。但是，这样就增加了多余的机制：Paxos 同时包含了针对基本一致性要求的两阶段提交协议和针对领导人选举的独立的机制。相比较而言，Raft 就直接将领导人选举纳入到一致性算法中，并作为两阶段一致性的第一步。这样就减少了很多机制。\n像 Raft 一样，VR 和 ZooKeeper 也是基于领导人的，因此他们也拥有一些 Raft 的优点。但是，Raft 比 VR 和 ZooKeeper 拥有更少的机制因为 Raft 尽可能的减少了非领导人的功能。例如，Raft 中日志条目都遵循着从领导人发送给其他人这一个方向：附加条目 RPC 是向外发送的。在 VR 中，日志条目的流动是双向的（领导人可以在选举过程中接收日志）；这就导致了额外的机制和复杂性。根据 ZooKeeper 公开的资料看，它的日志条目也是双向传输的，但是它的实现更像 Raft。\n和上述我们提及的其他基于一致性的日志复制算法中，Raft 的消息类型更少。例如，我们数了一下 VR 和 ZooKeeper 使用的用来基本一致性需要和成员改变的消息数（排除了日志压缩和客户端交互，因为这些都比较独立且和算法关系不大）。VR 和 ZooKeeper 都分别定义了 10 种不同的消息类型，相对的，Raft 只有 4 种消息类型（两种 RPC 请求和对应的响应）。Raft 的消息都稍微比其他算法的要信息量大，但是都很简单。另外，VR 和 ZooKeeper 都在领导人改变时传输了整个日志；所以为了能够实践中使用，额外的消息类型就很必要了。\nRaft 的强领导人模型简化了整个算法，但是同时也排斥了一些性能优化的方法。例如，平等主义 Paxos （EPaxos）在某些没有领导人的情况下可以达到很高的性能。平等主义 Paxos 充分发挥了在状态机指令中的交换性。任何服务器都可以在一轮通信下就提交指令，除非其他指令同时被提出了。然而，如果指令都是并发的被提出，并且互相之间不通信沟通，那么 EPaxos 就需要额外的一轮通信。因为任何服务器都可以提交指令，所以 EPaxos 在服务器之间的负载均衡做的很好，并且很容易在 WAN 网络环境下获得很低的延迟。但是，他在 Paxos 上增加了非常明显的复杂性。\n一些集群成员变换的方法已经被提出或者在其他的工作中被实现，包括 Lamport 的原始的讨论，VR 和 SMART。我们选择使用共同一致的方法因为他对一致性协议的其他部分影响很小，这样我们只需要很少的一些机制就可以实现成员变换。Lamport 的基于 α 的方法之所以没有被 Raft 选择是因为它假设在没有领导人的情况下也可以达到一致性。和 VR 和 SMART 相比较，Raft 的重新配置算法可以在不限制正常请求处理的情况下进行；相比较的，VR 需要停止所有的处理过程，SMART 引入了一个和 α 类似的方法，限制了请求处理的数量。Raft 的方法同时也需要更少的额外机制来实现，和 VR、SMART 比较而言。\n11 结论 算法的设计通常会把正确性，效率或者简洁作为主要的目标。尽管这些都是很有意义的目标，但是我们相信，可理解性也是一样的重要。在开发者把算法应用到实际的系统中之前，这些目标没有一个会被实现，这些都会必然的偏离发表时的形式。除非开发人员对这个算法有着很深的理解并且有着直观的感觉，否则将会对他们而言很难在实现的时候保持原有期望的特性。\n在这篇论文中，我们尝试解决分布式一致性问题，但是一个广为接受但是十分令人费解的算法 Paxos 已经困扰了无数学生和开发者很多年了。我们创造了一种新的算法 Raft，显而易见的比 Paxos 要容易理解。我们同时也相信，Raft 也可以为实际的实现提供坚实的基础。把可理解性作为设计的目标改变了我们设计 Raft 的方式；随着设计的进展，我们发现自己重复使用了一些技术，比如分解问题和简化状态空间。这些技术不仅提升了 Raft 的可理解性，同时也使我们坚信其正确性。\n12 raft协议的动画演示 raft协议动画演示\n13 raft常见面试问题汇总","date":"2025-01-15T15:22:33+08:00","permalink":"http://www.alvincat.top/post/storage_system/raft/","tags":[""],"title":"Raft协议"},{"categories":["Tools"],"contents":"本文介绍网络相关的工具的使用方法\n1 使用ncat模拟服务 使用前提：需要在UNIX系统中已经安装ncat软件而且shell可以正常使用。\n1.1 The discard service 1 2 3 4 5 # TCP discard server ncat -l --keep-open 9 --recv-only \u0026gt; /dev/null # UDP discard server ncat --udp -l --keep-open 9 --recv-only \u0026gt; /dev/null 1.2 echo service The echo service is defined in RFC 862. It runs on TCP or UDP port 7. One step more advanced than discard, it sends back any data received until the connection is closed. How do you instruct Ncat to return what it receives? One easy way is to run everything through /bin/cat.\n1 2 3 4 5 # TCP echo server ncat -l 7 --keep-open --exec \u0026#34;/bin/cat\u0026#34; # UDP echo server ncat -l 7 --keep-open --udp --exec \u0026#34;/bin/cat\u0026#34; 1.3 daytime service The daytime service, defined in RFC 867, sends a human-readable date and time string over TCP or UDP port 13. It ignores any input. The format of the date and time string is left unspecified, so we are free to use the output of /bin/date. Because we are not interested in anything sent by the client we use the \u0026ndash;send-only option.\n1 2 3 4 5 # TCP daytime server ncat -l 13 --keep-open --send-only --exec \u0026#34;/bin/date\u0026#34; # UDP daytime server ncat -l 13 --keep-open --udp --send-only --exec \u0026#34;/bin/date\u0026#34; 1.4 qotd server The qotd (quote of the day) service is defined in RFC 865. When a connection is made to TCP or UDP port 17, it sends back a short message, ignoring any input. Ncat can do this by invoking a program that generates messages. A traditional choice is /usr/games/fortune, though there are many possibilities. /usr/bin/uptime, for example, could be useful.\n1 2 3 4 TCP qotd server ncat -l 17 --keep-open --send-only --exec \u0026#34;/usr/games/fortune\u0026#34; UDP qotd server do ncat -l 17 --keep-open --udp --send-only --exec \u0026#34;/usr/games/fortune\u0026#34; 1.5 chargen service The chargen service from RFC 864 rounds out our tour of diagnostic services. It runs on TCP and UDP port 19. With TCP, chargen ignores any input and sends a never-ending stream of data. Never-ending, that is, until the connection is closed by the user, who the RFC suggests may have “had enough”. There are many ways of generating the characters; reading from /dev/zero and running yes come to mind.\n1 2 3 4 5 6 # TCP chargen server yes \u0026#34;chargenchargenchargen\u0026#34; | ncat -l --keep-open 19 --send-only # UDP chargen server ncat -l 19 --keep-open --udp --send-only --sh-exec \\ \u0026#34;yes chargenchargenchargen | dd count=1 bs=$(($RANDOM % 512)) 2\u0026gt; /dev/null\u0026#34; 参考文献： ncat emulating Diagnostic Services\n2 tcpdump软件的用法 tcpdump抓取的数据是以太网帧，通过该命令的参数控制帧的过滤和显示。\n2.1 常用参数功能介绍 1 2 3 4 5 6 7 8 # -i 指定监控网卡 # -e Print the link-level header on each dump line. # -n Don’t convert host addresses to names. # -t Don’t print a timestamp on each dump line. # -s 每个数据的最大显示长度 # -v 打印IP数据报头部信息中关键字段的值（例如tos,ttl,offset,传输层协议，长度等信息）。 # -x 将数据按照十六进制显示 # -X 将数据按照十六进制显示，并显示对应的ASCII。 2.2 tcpdump软件使用实例 2.2.1 指定源IP地址和目的IP地址抓包 1 tcpdump -i eth0 -ent \u0026#39;(dst 192.168.56.6 and src 192.168.56.8) or (dst 192.168.56.8 and src 192.168.56.6)\u0026#39; 2.2.2 指定服务抓包 port domain说明只抓取使用domain域名服务的数据包，即DNS查询和应答报文。\n1 tcpdump -i eth0 -nt -s 500 port domain 2.2.3 指定网卡抓包 1 2 # 抓取本地回路上的数据包 tcpdump -ntx -i lo 2.2.4 指定协议抓包 1 2 # 只抓取icmp报文 tcpdump -i eth0 -ntv icmp 2.2.5 指定端口抓包 1 2 # 只抓发送至或者来自54321端口的TCP报文段 tcpdump -i eth0 -n port 54321 3 ping命名的用法 3.1 ping命令常用参数说明 1 2 -i interval # Wait interval seconds between sending each packet. -s packetsize # Specifies the number of data bytes to be sent. 4 ifconfig命令的用法 1 2 3 -a # display all interfaces which are currently available, even if down up # This flag causes the interface to be activated down # This flag causes the driver for this interface to be shut down. 4.1 ifconfig查询结果中的字段含义 enp0s8: flags=4163\u0026lt;UP,BROADCAST,RUNNING,MULTICAST\u0026gt; mtu 1500\ninet 192.168.56.8 netmask 255.255.255.0 broadcast 192.168.56.255\ninet6 fe80::a00:27ff:fe8b:9089 prefixlen 64 scopeid 0x20\nenp0s8: 表示网卡的名称 UP：表示当前网卡处于UP状态 mtu 1500: 表示当前网卡的以太网帧的长度为1500字节(Byte) inet：为该网卡的IPv4地址，netmask为子网掩码 inet6: 表示该网卡的IPv6地址 4.2 ifconfig示例 1 2 3 4 5 # 显示当前设备上所有网卡信息，包含down的网卡 ifconfig -a # 查询指定网卡的信息 ifconfig eth0 5 route命令的用法 5.1 route常用参数说明 1 2 3 4 5 6 -C # operate on the kernel’s routing cache. -n # show numerical addresses instead of trying to determine symbolic host names -v # select verbose operation del # delete a route. add # add a new route. dev If # force the route to be associated with the specified device 5.2 route使用示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 # deletes the current default route, which is labeled \u0026#34;default\u0026#34; # or 0.0.0.0 in the destination field of the current routing table. route del default # deletes the route. Since the Linux routing kernel uses classless addressing, # you pretty much always have to specify the netmask that is same as as seen in \u0026#39;route -n\u0026#39; listing. route del -net 192.56.76.0 netmask 255.255.255.0 # adds a default route (which will be used if no other route matches). # All packets using this route will be gatewayed through the address of a node named \u0026#34;mango\u0026#34;. # The device which will actually be used for that route depends on how we can reach \u0026#34;mango\u0026#34; - # \u0026#34;mango\u0026#34; must be on directly reachable route. route add default gw mango # Adds the route to the host named \u0026#34;mango\u0026#34; via # the SLIP interface (assuming that \u0026#34;mango\u0026#34; is the SLIP host). route add mango sl0 # 查看路由表缓冲区 # # route -Cn # Kernel IP routing cache # Source Destination Gateway Flags Metric Ref Use Iface # 192.168.56.2 192.168.56.1 192.168.56.1 0 1 0 eth1 # 192.168.56.1 192.168.56.2 192.168.56.2 il 0 0 26 lo route -Cn 6 netstat命令的用法 1 2 3 4 5 6 7 8 9 10 11 -a, --all # Show both listening and non-listening (for TCP this means established connections) sockets. With the --interfaces option, show interfaces that are not marked -l, --listening # Show only listening sockets. (These are omitted by default.) -p, --program # Show the PID and name of the program to which each socket belongs. -n, --numeric # Show numerical addresses instead of trying to determine symbolic host, port or user names. -t|--tcp # filter tcp -u|--udp # filter udp -C # Print routing information from the route cache. -F # Print routing information from the FIB. (This is the default.) --route , -r # Display the kernel routing tables. ","date":"2025-01-09T16:26:52+08:00","permalink":"http://www.alvincat.top/post/tools/network_tools/","tags":[""],"title":"Linux网络相关工具的使用方法"},{"categories":[""],"contents":"本文对Nginx源码功能进行简要介绍。\n1 Nginx源码功能结构\n1 2 3 4 5 6 7 src |__ core/ |__ event/ |__ http/ |__ mail/ |__ os/ |__ stream/ 1.1 core： 基础功能 其中core目录中提供一些基础功能：\nngx_log: 打印日志 ngx_thread_pool： 线程池功能 ngx_rbtree： 红黑树功能 ngx_radix_tree： radix tree功能 ngx_string： 字符串处理 1.2 event：事件处理 ngx_event_timer：定时器功能 1.3 http: http服务 1.4 mail：邮件服务 1.5 os相关 1.6 stream","date":"2025-01-03T13:21:21+08:00","permalink":"http://www.alvincat.top/post/linux/nginx/nginx_introduction/","tags":[""],"title":"Nginx源码功能简介"},{"categories":["CPP"],"contents":"本文介绍C++ 11及后续版本中的新特性\n1 C++ 11新增关键字(部分) 1.1 constexpr constexpr 和const的功能类似，只值 constexpr 类型在编译时会进行变量类型检查，检查变量的值是否为常量表达式。\n声明为 constexpr的变量一定是常量，而且必须使用常量表达式初始化\n1.2 decltype decltype的作用是获取并返回操作数的类型。\n针对的场景：希望从表达式的类型推导出要定义的变量的类型，但是不想用该表达式初始化变量。例如：\n1 2 const int ci = 0; decltype(ci) x = 1; // x的类型为const int 1.3 =default = default是用于限定构造函数的，要求编译器生成构造函数。它可以出现在类内部，也可以作为定义出现在类外部。 若在类内部，则默认构造函数是内联的，如果在内外部，则该构造函数默认不是内联的。\n1.4 =delete 用于修饰函数，将函数定义为已删除。所有尝试调用已删除函数的代码，都会在编译阶段报错。\n1.5 noexcept 用于指定函数不抛出异常。\n1.6 nullptr nullptr是一个指针常量，表示空指针。\n1.7 explicit 1.7.1 修饰构造函数 explicit用于修饰构造函数是，用于阻止构造函数进行隐式转换。\nexplicit只对拥有一个参数的构造函数有效。 explicit只能在类内部声明构造函数时使用，而且在类外定义该构造函数时不能重复使用该关键字。 explicit声明构造函数时，该构造函数只能安札直接初始化的形式使用。\n1.8 override override关键字用在派生类的函数中，用于明确覆盖基类中的同名函数。\n若要在派生类的函数中使用override关键字，需要基类中有同名函数而且该函数为虚函数(virtual修饰)。【只有虚函数才能被覆盖】。 final和override说明符出现在形参列表(包括任何const或引用修饰符)以及尾置返回类型之后。\n1.9 final final的作用是阻止派生类覆盖该函数。 当函数使用final修饰后，任何尝试覆盖该函数的操作都会报错。\n1.10 auto 1.11 using using可以用来声明类型别名和模板声明别名。\n示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // type alias, identical to // typedef std::ios_base::fmtflags flags; using flags = std::ios_base::fmtflags; // the name \u0026#39;flags\u0026#39; now denotes a type: flags fl = std::ios_base::dec; // type alias, identical to // typedef void (*func)(int, int); using func = void (*) (int, int); // the name \u0026#39;func\u0026#39; now denotes a pointer to function: void example(int, int) {} func f = example; // type alias used to hide a template parameter template\u0026lt;class CharT\u0026gt; using mystring = std::basic_string\u0026lt;CharT, std::char_traits\u0026lt;CharT\u0026gt;\u0026gt;; mystring\u0026lt;char\u0026gt; str; 2 Lambda表达式 2.1 Lambda表达式的几种模式 1 2 3 4 //[ capture-list ] ( params ) mutable(optional) constexpr(optional)(c++17) exception attribute -\u0026gt; ret { body } (1) //[ capture-list ] ( params ) -\u0026gt; ret { body } (2) //[ capture-list ] ( params ) { body } (3) //[ capture-list ] { body } (4) capture-list - a comma-separated list of zero or more captures, optionally beginning with a capture-default. Capture list can be passed as follows (see below for the detailed description):\n[a,\u0026amp;b] where a is captured by copy and b is captured by reference.\n[this] captures the current object (*this) by reference\n[\u0026amp;] captures all automatic variables used in the body of the lambda by reference and current object by reference if exists\n[=] captures all automatic variables used in the body of the lambda by copy and current object by reference if exists [] captures nothing\nparams - The list of parameters, as in named functions, except that default arguments are not allowed (until C++14). If auto is used as a type of a parameter, the lambda is a generic lambda. (since C++14)\nret - Return type. If not present it\u0026rsquo;s implied by the function return statements (or void if it doesn\u0026rsquo;t return any value)\nbody - Function body\n2.2 Lambda表达式的示例程序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include \u0026lt;vector\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;functional\u0026gt; int main() { std::vector\u0026lt;int\u0026gt; c = {1, 2, 3, 4, 5, 6, 7}; int x = 5; c.erase(std::remove_if(c.begin(), c.end(), [x](int n) { return n \u0026lt; x; }), c.end()); std::cout \u0026lt;\u0026lt; \u0026#34;c: \u0026#34;; std::for_each(c.begin(), c.end(), [](int i){ std::cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39; \u0026#39;; }); std::cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // the type of a closure cannot be named, but can be inferred with auto auto func1 = [](int i) { return i + 4; }; std::cout \u0026lt;\u0026lt; \u0026#34;func1: \u0026#34; \u0026lt;\u0026lt; func1(6) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // like all callable objects, closures can be captured in std::function // (this may incur unnecessary overhead) std::function\u0026lt;int(int)\u0026gt; func2 = [](int i) { return i + 4; }; std::cout \u0026lt;\u0026lt; \u0026#34;func2: \u0026#34; \u0026lt;\u0026lt; func2(6) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } 程序执行结果：\nc: 5 6 7\nfunc1: 10\nfunc2: 10\n","date":"2025-01-02T21:06:18+08:00","permalink":"http://www.alvincat.top/post/cpp/cpp_new_features/","tags":[""],"title":"C++新特性(C++11及后续版本)"},{"categories":["Linux"],"contents":"线程介绍相关功能的使用方法。\nlinux获取线程id的方法 通过gettid()获取 1 2 3 4 5 6 #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;syscall.h\u0026gt; inline pid_t gettid(void) { return (pid_t)syscall(__NR_gettid); } 通过pthread_self()获取 1 2 3 4 5 void* func(void *ptr) { printf(\u0026#34;The id of %s is %u\\n\u0026#34;,(char*)ptr,(unsigned int)pthread_self()); return (void*)0; } 两种获取tid方法的差异：\npthread_self()是glibc提供的接口，是由线程库实现的。\ngettid()获取的tid是内核分配的，通过该方法获取到的tid和pid类似。可以通过命令ps -Tp PID获取当前进程中的线程。\n","date":"2025-01-02T10:42:37+08:00","permalink":"http://www.alvincat.top/post/linux/apue/threads/","tags":["线程"],"title":"线程"},{"categories":["操作系统"],"contents":"本文介绍树莓派硬件的一些初始化配置。\n1 安装系统 1.1 下载RaspberryPi OS 在树莓派官网下载树莓派操作系统(OS)。\n树莓派系统下载地址：https://www.raspberrypi.com/software/operating-systems/\n我选择的系统是：Raspberry Pi OS Lite(64)\n对linux系统不太熟悉的可以选择desktop版本。\n1.2 安装操作系统 找一个可用空间大于8GB的micro SD卡,将卡插入读卡器并将读卡器连接至windows系统； 将步骤1.1安装的系统解压到非中文路径下备用。 使用rufus工具，将解压得到的img文件烧到准备好的SD卡中。 待烧写系统完成，操作系统就安装好了。 将安装好操作系统的SD卡插入树莓派的SD插槽中。 将树莓派的电源线连接好，接通电源，系统将自动启动。 2 系统配置 2.1 键盘布局设置 执行命令：sudo raspi-config打开系统配置界面。\n然后按照步骤【Localisation Options】-\u0026gt; 【L3 keybord】的步骤设置键盘布局。选择【Generic 104-key pc】-\u0026gt; 【English(US)】\n2.2 连接WIFI 执行命令：sudo raspi-config打开系统配置界面。\n然后按照步骤【System Options】-\u0026gt; 【S1 Wireless LAN】的步骤设置无线网络。\n2.3 启用ssh功能 启用ssh功能后，就可以在局域网连接到树莓派系统。\n执行命令：sudo raspi-config打开系统配置界面。 然后按照步骤【Interface Options】-\u0026gt; 【I1 SSH】的步骤设置ssh启动开关。\n3 安装Nginx 安装Nginx参考文档： Debian安装Nginx的方法\n4 安装samba 安装samba: sudo apt install samba 创建访问samba共享目录的用户： 1 2 sudo useradd smb # 添加smb用户 sudo passwd smb # 为账户smb设置密码 创建共享目录： mkdir /home/sambashare/ 修改共享目录权限和所有者： 1 2 sudo chmod -R 755 /home/sambashare/ # 设置smb目录的权限 sudo chown -R smb:smb /home/sambashare/ # 设置smb目录的所属用户和组为smb 设置smb用户访问samba的密码：sudo smbpasswd -a smb\n编辑samba配置文件：sudo vim /etc/samba/smb.conf\n1 2 3 4 5 6 7 8 9 [sambaShare] comment = Samba on RespberryPi path = /opt/share/ browsable = yes read only = no guest ok = no write list = smb allow hosts = 192.168.101.103 deny hosts = 192.168.101.0/24 重启samba服务： sudo service smbd restart 设置防火墙：sudo ufw allow samba ","date":"2024-12-28T17:49:22+08:00","permalink":"http://www.alvincat.top/post/operating_system/raspberrypi/raspberrypi_getting_started/","tags":["RaspberryPi"],"title":"树莓派系统的初始化"},{"categories":["CPP"],"contents":"本文总结C++算法库中有关排序相关的库函数的常见用法。\n1 std::sort 1.1 使用默认排序函数 默认排序函数得到的排序结果是升序结果。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 std::array\u0026lt;int, 10\u0026gt; s = {5, 7, 4, 2, 8, 6, 1, 9, 0, 3}; // sort using the default operator\u0026lt; // 0 1 2 3 4 5 6 7 8 9 std::sort(s.begin(), s.end()); for (auto a : s) { std::cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } std::cout \u0026lt;\u0026lt; std::endl; // sort using a standard library compare function object // 9 8 7 6 5 4 3 2 1 0 std::sort(s.begin(), s.end(), std::greater\u0026lt;int\u0026gt;()); for (auto a : s) { std::cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } std::cout \u0026lt;\u0026lt; std::endl; 1.2 使用自定义排序函数 1 2 3 4 5 6 7 8 9 10 11 12 13 // sort using a custom function bool comp(const vector\u0026lt;int\u0026gt;\u0026amp; a, const vector\u0026lt;int\u0026gt;\u0026amp; b) { return *a.cbegin() \u0026lt; *b.cbegin(); } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; vec = {{5,6}, {2, 7}, {6, 9}, {15, 19}}; sort(vec.begin(), vec.end(), comp); for (auto item : vec) { for (auto iter : item) { printf(\u0026#34;%d \u0026#34;, iter); } printf(\u0026#34;\\n\u0026#34;); } ","date":"2024-12-27T11:23:42+08:00","permalink":"http://www.alvincat.top/post/cpp/algorithms_library/sorting_operations/","tags":["C++算法库"],"title":"C++算法库-排序算法"},{"categories":["汇编语言"],"contents":"Introduce the Intel and AT\u0026amp;T Syntax about assembly language\nIntel and AT\u0026amp;T Syntax Intel and AT\u0026amp;T syntax Assembly language are very different from each other in appearance,\nand this will lead to confusion when one first comes across AT\u0026amp;T syntax after having learnt Intel syntax first, or vice versa.\nSo lets start with the basics. Linux use AT\u0026amp;T syntax default.\n1.1 Direction of Operands The direction of the operands in Intel syntax is opposite from that of AT\u0026amp;T syntax.\nIn Intel syntax the first operand is the destination, and the second operand is the source whereas in AT\u0026amp;T syntax the first operand is the source and the second operand is the destination.\nThe advantage of AT\u0026amp;T syntax in this situation is obvious.\nWe read from left to right, we write from left to right, so this way is only natural.\nExample:\nIntel Syntax AT\u0026amp;T Syntax instr dest,source instr source,dest mov eax,[ecx] movl (%ecx),%eax 1.2 Prefixes In Intel syntax there are no register prefixes or immed prefixes.\nIn AT\u0026amp;T however registers are prefixed with a \u0026lsquo;%\u0026rsquo; and immed\u0026rsquo;s are prefixed with a \u0026lsquo;$\u0026rsquo;.\nIntel syntax hexadecimal or binary immed data are suffixed with \u0026lsquo;h\u0026rsquo; and \u0026lsquo;b\u0026rsquo; respectively.\nAlso if the first hexadecimal digit is a letter then the value is prefixed by a \u0026lsquo;0\u0026rsquo;.\nExample:\nIntel Syntax AT\u0026amp;T Syntax mov eax, 1 movl $1, %eax mov ebx, 0ffh movl $0xff, %ebx int 80h int $0x80 1.3 Memory Operands Memory operands as seen above are different also. In Intel syntax the base register is enclosed in \u0026lsquo;[\u0026rsquo; and \u0026lsquo;]\u0026rsquo; whereas in AT\u0026amp;T syntax it is enclosed in \u0026lsquo;(\u0026rsquo; and \u0026lsquo;)\u0026rsquo;.\nExample:\nIntel Syntax AT\u0026amp;T Syntax mov eax, [ebx] movl (%ebx), %eax mov eax, [ebx+3] movl 3(%ebx), %eax The AT\u0026amp;T form for instructions involving complex operations is very obscure compared to Intel syntax. The Intel syntax form of these is segreg:[base+index*scale+disp]. The AT\u0026amp;T syntax form is %segreg: disp(base,index,scale).\nIndex/scale/disp/segreg are all optional and can simply be left out. Scale, if not specified and index is specified, defaults to 1. Segreg depends on the instruction and whether the app is being run in real mode or pmode. In real mode it depends on the instruction whereas in pmode its unnecessary. Immediate data used should not \u0026lsquo;$\u0026rsquo; prefixed in AT\u0026amp;T when used for scale/disp.\nExample:\nIntel Syntax AT\u0026amp;T Syntax instr foo,segreg:[base+index*scale+disp] instr %segreg:disp(base,index,scale), foo mov eax, [ebx+20h] movl 0x20(%ebx), %eax add eax, [ebx+ecx*2h] addl (%ebx,%ecx,0x2), %eax lea eax, [ebx+ecx] leal (%ebx,%ecx), %eax sub eax, [ebx+ecx*4h-20h] subl -0x20(%ebx,%ecx,0x4), %eax As you can see, AT\u0026amp;T is very obscure. [base+index*scale+disp] makes more sense at a glance than disp(base,index,scale).\n1.4 Suffixes As you may have noticed, the AT\u0026amp;T syntax mnemonics have a suffix. The significance of this suffix is that of operand size. \u0026rsquo;l\u0026rsquo; is for long, \u0026lsquo;w\u0026rsquo; is for word, and \u0026lsquo;b\u0026rsquo; is for byte. Intel syntax has similar directives for use with memory operands, i.e. byte ptr, word ptr, dword ptr. \u0026ldquo;dword\u0026rdquo; of course corresponding to \u0026ldquo;long\u0026rdquo;. This is similar to type casting in C but it doesnt seem to be necessary since the size of registers used is the assumed datatype.\nExample:\nIntel Syntax AT\u0026amp;T Syntax mov al,bl movb %bl,%al mov ax,bx movw %bx,%ax mov eax,ebx movl %ebx,%eax mov eax, dword ptr [ebx] movl (%ebx),%eax ","date":"2024-12-23T20:41:51+08:00","permalink":"http://www.alvincat.top/post/assembly/inter_gun_syntax_difference/","tags":[""],"title":"Intel和AT\u0026T汇编语言语法的差异"},{"categories":[""],"contents":"该页面为汇编语言使用的导航页。\n汇编语言 Intel和AT\u0026amp;T汇编语言语法的差异\n","date":"2024-12-23T18:25:40+08:00","permalink":"http://www.alvincat.top/index/content_assembly/","tags":[""],"title":"汇编语言导航页"},{"categories":["数据结构"],"contents":"本文介绍B-Tree的特性，以及代码实现。\n","date":"2024-12-17T20:01:46+08:00","permalink":"http://www.alvincat.top/post/data_structure/tree/b_tree/","tags":["B-Tree"],"title":"B_tree"},{"categories":[""],"contents":"该页面为存储系统的导航页。\n存储系统导航页 存储系统的基本概念\n一致性哈希原理\nraft协议原理介绍\n[Ceph功能简介] [LevelDB原理介绍] [RocksDB原理介绍]\n","date":"2024-12-17T18:25:40+08:00","permalink":"http://www.alvincat.top/index/content_storage/","tags":[""],"title":"存储系统导航页"},{"categories":[""],"contents":"","date":"2024-12-17T17:51:06+08:00","permalink":"http://www.alvincat.top/post/storage_system/leveldb/","tags":[""],"title":"LevelDB"},{"categories":[""],"contents":"","date":"2024-12-17T17:50:40+08:00","permalink":"http://www.alvincat.top/post/storage_system/rocksdb/","tags":[""],"title":"RocksDB"},{"categories":["存储系统"],"contents":"本文介绍Ceph系统的基本组成部分以及一些基本概念。\n","date":"2024-12-17T17:50:30+08:00","permalink":"http://www.alvincat.top/post/storage_system/ceph/","tags":["Ceph"],"title":"Ceph"},{"categories":["storage"],"contents":"本文介绍存储基础知识。\n1 存储的基本概念 副本 EC 重构 扩容 缩容 2 一致性哈希算法","date":"2024-12-17T17:49:33+08:00","permalink":"http://www.alvincat.top/post/storage_system/storage_basic_knowledge/","tags":[""],"title":"存储系统的基本概念"},{"categories":["CPP"],"contents":"本文总结C++中的部分关键字的用法。\n1 C++中的部分关键字的用法 1.1 const的用法 1.1.1 定义常量 使用const修饰的变量的值不可改变。\n1 const double PI = 3.1415; 1.1.2 const与指针 指向常量的指针(point to const)\n定义方法： const int *p; int const *p;\n指向常量的指针的特点：const在*前面，不论它在类型前还是类型后作用相同。\n指向常量的指针的特点： 不能通过指针改变所指向的数据 指针本身的内容可以改变 指针指向的内容可以是常量也可以不是常量 指针所指向的内容若为非常量，也可以改变 示例如下：\n1 2 3 4 5 6 7 int a = 100; int b = 50; const int *point1 = \u0026amp;a; //定义指针常量 //*point1 = 50; //非法操作，不能通过指针变量来改变所指向的数据 a = 50; //改变指针常量所指内容的值 point1 = \u0026amp;b; //改变指针常量的值 常量指针(const pointer)\n定义方法： int *const p;\n常量指针就是该指针为常量。因为该指针为一个常量，因此指针的值不能改变。 常量指针的特点： 常量指针必须初始化 一旦初始化后，指针的内容就不能改变 指针所指向的内容可以改变 示例如下：\n1 2 3 4 5 6 int a = 100; int b = 50; int *const point2 = \u0026amp;b; // 定义常量指针 //point2 = \u0026amp;a; //非法操作，不能更改常量指针的值 b = 100; // 可以改变常量指针所指内容的值 指向常量的常指针\n定义方法： const int *const p;\n指向常量的常指针为前面两种情况的综合。因此既不能通过指针变量来改变所指向的数据，也不能更改指针本身的值。 指向常量的常指针： 指针本身的内容不能改变 不能通过指针改变指针所指向的内容 若指针指向的内容为非常量，则指针指向的内容可以改变 示例：\n1 2 3 4 5 6 int a = 100; int b = 50; int c = 80; const int *const point3 = \u0026amp;c; //定义指向常量的常量指针 *point3 = a; //非法操作，不能通过指针变量来改变所指向的数据 point3 = \u0026amp;b; //非法操作，不能更改常量指针的值 1.1.3 函数形参 const修饰函数形参，函数中不能修改const形参对应的实参。例如：\n1 void func(const vector\u0026lt;int\u0026gt;\u0026amp; vec); 1.1.4 const修饰函数返回值 1.1.5 类相关的const 常量成员变量：常成员变量只能通过列表初始化的方式初始化。此后，其值不可改变。 const修饰成员函数：const修饰的成员函数不能修改类中成员变量的值；不能调用非const修饰的成员函数。 const修饰对象，对象指针(引用)：const修饰的对象只能调用cosnt修饰的成员函数。 1.2 static的用法 1.2.1 静态全局变量 该变量在全局数据区分配内存; 未经初始化的静态全局变量会被程序自动初始化为0; 静态全局变量在声明它的整个文件都是可见的，而在文件之外是不可见的; 1.2.2 静态局部变量 该变量在全局数据区分配内存； 静态局部变量在程序执行到该对象的声明处时,首次进行初始化;以后的函数调用不再进行初始化； 静态局部变量一般在声明处初始化，如果没有显式初始化会被程序自动初始化为0； 它始终驻留在全局数据区，直到程序运行结束。但其作用域为局部作用域，当定义它的函数或语句块结束时，其作用域随之结束； 1.2.3 静态函数 静态函数不能被其它文件所用；其它文件中可以定义相同名字的函数，不会发生冲突\n1.2.4 类内静态成员 1.2.4.1 静态数据成员 类中的静态成员与类本身直接相关。而不是与类的各个对象保持关联。类的静态数据成员是属于整个类，而不与任何对象绑定； static关键字只能出现在类内部声明语句中； 类的静态成员存在于任何对象之外，对象中不包含任何与静态数据有关的数据； 静态成员变量使用前必须先初始化； 静态数据成员不能由类的构造函数初始化； 静态数据成员一般应在类的外部初始化。当静态数据成员为静态常量(const static)时，可以在类内初始化。 静态数据成员只能定义一次。 1.2.4.2 静态成员函数 类的静态成员函数也不与任何对象绑定，也不包含this指针。 静态成员函数不能声明为const,也不能在static函数体内使用this指针。 静态成员函数不能使用非静态成员函数，非静态成员函数可以使用静态成员函数。 ","date":"2024-12-15T22:08:28+08:00","permalink":"http://www.alvincat.top/post/cpp/cpp_some_keywords/","tags":[""],"title":"C++中的部分关键字的用法"},{"categories":["CPP"],"contents":"本文总结C++面向对象的相关理论知识。\n1 面向对象 1.1 面向对象的特征 面向对象的特征：封装、继承、多态。\n封装：把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。（优点：可以隐藏实现细节，使得代码模块化） 继承：可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。（优点：可以扩展已存在的代码模块（类）） 多态：一个类实例的相同方法在不同情形有不同表现形式。多态机制使具有不同内部结构的对象可以共享相同的外部接口。虽然针对不同对象的具体操作不同，但通过一个公共的类，这些操作可以通过相同的方式被调用。\n多态实现的两种方式：父类指针指向子类对象或将一个基类的引用类型赋值为它的派生类实例。（重要：虚函数 + 指针或引用） 1.5 类中的数据成员初始化顺序 一个类中的数据成员初始化的顺序，只与数据成员的定义时的顺序有关，而与初始化列表中数据成员的出现次序无关。\n1.7 构造函数的性质 构造函数的名字和类名相同 构造函数没有返回类型 构造函数不能被声明为const 构造函数可以重载，一般包含默认构造函数，拷贝构造函数。 默认构造函数不需要任何参数 构造函数不能为虚函数 1.7.1 构造函数初始化列表 注意: 如果成员是const、引用或者属于某种未提供默认构造函数的类类型。我们必须通过构造函数初始化列表为这些成员提供初值。\n数据成员初始化的顺序 数据成员初始化的顺序与它们在类中定义时出现的顺序一致，而与它们初始化的顺序无关。一般来说，初始化类成员没有严格的顺序要求。但是如果用一个成员初始化另一个成员时，顺序就很关键。例如：\n1 2 3 4 5 6 7 class X{ int i; int j; public: //未定义的：i在j之前被初始化 X(int val):j(val), i(j){} }; 上例中，从构造函数初始值的形式上看，好像是先用val初始化j，然后再用j初始化i。但实际上，i先被初始化，因此这个初始值的效果是试图使用未定义的j初始化i。\n提示：最好令构造函数初始值的顺序与成员声明的顺序保持一致。而且尽量避免使用某些成员初始化其他成员。\n默认实参和构造函数： 如果一个构造函数为所有参数都提供了默认实参，则它实际上也定义了默认构造函数。\n1.7.2 构造函数初始化时必须采用列表初始化的情形： const修饰的成员变量 引用成员变量 数据成员是某种未提供默认构造函数的类类型 1.7.3 默认构造函数 当对象默认初始化或者值初始化时，会自动调用默认构造函数。\n默认初始化的情况：\n在块作用域内不使用任何初始值定义一个非静态变量或者数组时 当一个类本身包含类类型的成员且使用合成的默认构造函数时 当类类型的成员没有在构造函数初始值列表中显示初始化时 值初始化的情形：\n在数组初始化的过程中若提供的初始值少于数组的大小时 不使用初始值顶一个局部静态变量时 通过形式T()的表达式请求值初始化时，其中T为类型名 温馨提示\n如果在一个类中定义构造函数，最好提供一个默认构造函数。\n1.8 析构函数的性质 析构函数不能重载 析构函数可以为虚函数，基类的析构函数建议定义为虚函数。 基类析构函数使用虚函数的好处：当使用基类的指针保存派生类的对象时，我们在释放基类的指针时不仅会释放基类的成员，还会释放派生的的成员，避免造成内存泄露。例如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class ClxBase { public: ClxBase() {}; virtual ~ClxBase() { cout \u0026lt;\u0026lt; \u0026#34;Output from the destructor of class ClxBase!\u0026#34; \u0026lt;\u0026lt; endl;}; virtual void DoSomething() { cout \u0026lt;\u0026lt; \u0026#34;Do something in class ClxBase!\u0026#34; \u0026lt;\u0026lt; endl; }; }; class ClxDerived : public ClxBase { public: ClxDerived() {}; ~ClxDerived() { cout \u0026lt;\u0026lt; \u0026#34;Output from the destructor of class ClxDerived!\u0026#34; \u0026lt;\u0026lt; endl; }; void DoSomething() override { cout \u0026lt;\u0026lt; \u0026#34;Do something in class ClxDerived!\u0026#34; \u0026lt;\u0026lt; endl; } }; int main() { ClxBase *p = new ClxDerived; p-\u0026gt;DoSomething(); delete p; return 0; } 温馨提示：\n绝不在构造和析构过程中调用virtual函数\n1.9 拷贝初始化发生的情形 用等号(=)定义类类型的对象 将一个对象作为实参传递给一个非引用类型的形参 从一个返回类型为非引用类型的函数返回一个对象 用花括号列表初始化一个数组中的元素或一个聚合类(struct)中的成员 1.10 拷贝构造和拷贝赋值运算符 拷贝构造函数的作用：使用一个存在的对象初始化一个未被初始化的对象。\n拷贝赋值运算符的作用：使用一个存在对象去替换一个已经初始化的对象。\n1.11 深拷贝与浅拷贝 浅拷贝，指的是在对象复制时，只对对象中的数据成员进行简单的赋值，默认拷贝构造函数执行的也是浅拷贝。大多情况下“浅拷贝”已经能很好地工作了，但是一旦对象存在动态成员，那么浅拷贝就会出问题。 “深拷贝”的情况下，对于对象中动态成员，就不能仅仅简单地赋值了，而应该重新动态分配空间。\n在某些状况下，类内成员变量需要动态开辟堆内存，如果实行位拷贝，也就是把对象里的值完全复制给另一个对象，如A=B。这时，如果B中有一个成员变量指针已经申请了内存，那A中的那个成员变量也指向同一块内存。这就出现了问题：当B把内存释放了（如：析构），这时A内的指针就是野指针了，出现运行错误。 深拷贝和浅拷贝可以简单理解为：如果一个类拥有资源，当这个类的对象发生复制过程的时候，资源重新分配，这个过程就是深拷贝，反之，没有重新分配资源，就是浅拷贝。\n1.12 基类和派生类 1.12.1 基类 温馨提示\n基类通常都应该定义一个虚析构函数，即使该函数不执行任何实际操作也是如此。\n派生类可以继承其基类的成员，然而当遇到与类型相关的操作时，派生类必须对其重新定义。即派生类需要对这些操作提供自己的新定义以覆盖(override)从基类继承而来的旧定义。 基类通过在其成员函数的声明语句之前加上关键字virtual使得该函数执行动态绑定。任何构造函数之外的非静态函数都可以是虚函数 。关键字virtual只能出现在类内部的声明语句之前而不能用于类外部的函数定义。 成员函数如果没被声明为虚函数，则其解析过程发生在编译时。\n1.12.2 定义派生类 派生类必须通过使用类派生列表明确指出它是从哪个基类继承而来的。\n派生类必须将其继承而来的成员函数中需要覆盖的那些重新声明。\n1.12.2.1 派生类的声明 派生类的声明与其它类差别不大，声明中包含类名但是不包含它的派生列表：\n1 2 class Bulk_quote : public Quote;\t//错误：派生列表不能出现在这里 class Bulk_quote;\t//正确：声明派生类的正确方式 1.12.2.2 派生类构造函数 尽管在派生类对象中包含有基类继承而来的成员，但是派生类并不能直接初始化这些成员。\n派生类也必须使用基类的构造函数来初始化它的基类部分。\n除非特别指出，否则派生类对象的基类部分会像数据成员一样执行默认初始化。 如果想使用其他的基类构造函数，我们需要一类名加圆括号内的实参列表的形式为构造函数提供初始值。 这些实参将帮助编译器决定应该选用那个构造函数来初始化派生类对象的基础部分。例如：\n1 2 3 //Bluk_quote的基类为Quote，在Bluk_quoute初始化时使用Quote的构造函数 Bluk_quote(const std::string\u0026amp; book, double p, std::size_t qty, double disc): Quoute(book, p), min_qty(qty), discount(disc){} 温馨提示\n首先初始化基类部分，然后按照声明的顺序依次初始化派生类的成员。\n1.12.2.3 派生类初始化的顺序 首先调用虚基类的构造函数 然后调用基类的构造函数。若有多个基类，基类构造函数的初始化顺序与派生类的派生列表一致 然后调用成员对象的构造函数 最后调用对象的本身的构造函数。 1.12.2.4 派生类中的虚函数 派生类经常覆盖它继承的虚函数。如果派生类没有覆盖其基类中的某个虚函数，则该虚函数的行为类似于其他的普通成员，派生类会直接继承其在基类中的版本。\n因为在派生类对象中含有与其基类对应的组成部分，所以我们能把派生类的对象当成基类对象使用。而且我们也能将基类的指针或引用绑定到派生类对象的中的基类部分上。这种转换称为派生类到基类的类型转换。编译器会隐式地执行派生类到基类的转换。 这种隐式特性意味着可以把派生类对象或者派生类对象的引用用在需要基类引用的地方。同样，我们也可以把派生类对象的指针用在需要基类指针的地方。\n1.12.2.5 继承和静态成员 如果基类定义了一个静态成员，则在整个继承体系中只存在该成员的唯一定义。不论从基类中派生出来多少个派生类，对于每个静态成员都只存在唯一的实例。\n静态成员遵循通用的访问控制规则，如果基类中的成员是private，则派生类无权访问它。假设静态成员是可访问的，则我们既能通过基类使用它也能通过派生类使用它。\n1.12.2.6 被用作基类的类 如果我们想使用某个类作为基类，这该类必须已经定义而非仅仅声明。\n1 2 3 class Quote;\t//声明但未定义 //错误：Quote必须已经定义 class Bluk_quote : public Quote{...}; 这一规定的原因显而易见：派生类中包含基类并且可以使用它从基类继承而来的成员，为了使用这些成员，派生类当然要知道它们是什么。因此，一个类不能派生它本身。\n1.12.2.7 防止继承的发生 有时我们定义这样的类，不希望其他类继承它。C++11提供了一种防止继承发生的方法，即在类名后跟一个关键字final：\n1 class NoDerived final{}; //NoDerived不能作为基类 1.13 C++多态特性 C++的多态性实现方式有：编译时多态(静态绑定)和运行时多态(动态绑定)。\n静态绑定：绑定的是对象的静态类型，依赖于对象的静态类型，发生在编译期。函数重载和模板实现的是静态绑定。 动态绑定：绑定的是对象的动态类型，依赖于对象的动态类型，发生在运行期。虚函数实现的是动态绑定。\nvirtual函数是动态绑定，non-virtual函数是静态绑定，缺省参数值也是静态绑定的。 1.13.1 多态性(polymorphism) 引用或指针的静态类型与动态类型不同这一事实是C++语言支持动态性的根本所在。\n当我们使用基类的引用或指针调用基类中定义的一个函数时，我们并不知道该函数真正作用的对象是什么类型。\n因为它可能是一个基类的对象也可能是一个派生类的对象。如果该函数是虚函数，则直到运行时才会决定到底执行哪个版本。\n判断的依据是引用或指针所绑定的对象的真实类型。\n另一方面，对非虚函数的调用在编译时进行绑定。类似的，通过对象进行的函数(虚函数或非虚函数)调用也在编译时绑定。\n对象的类型是确定不变的。通过对象进行的函数调用将在编译时绑定到该对象所属类中的函数版本上。\n1.13.2 动态绑定 只有在我们使用基类的引用或者指针调用基类的虚函数是才会发生动态绑定。\n必须使用基类的指针或者引用； 基类中必须存在这个调用的虚函数。 参见1.5.4的示例程序。 1.13.3 静态绑定 当我们通过一个具有普通类型(非引用非指针)的表达式调用虚函数时，在编译时就会将调用的版本确定下来，称为静态绑定。\n除了动态绑定外，其它情况均为静态绑定。\n例如如下程序的输出结果为：B-\u0026gt;1\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 class A{ public: virtual void func(int val = 1) { std::cout\u0026lt;\u0026lt;\u0026#34;A-\u0026gt;\u0026#34;\u0026lt;\u0026lt;val \u0026lt;\u0026lt;std::endl;} virtual void test(){ func();} }; class B : public A{ public: void func(int val=0){std::cout\u0026lt;\u0026lt;\u0026#34;B-\u0026gt;\u0026#34;\u0026lt;\u0026lt;val \u0026lt;\u0026lt;std::endl;} }; int main(int argc ,char* argv[]){ B* p = new B; p-\u0026gt;test(); return 0; } 上述程序的执行过程是：首先执行new B，调用类B的默认构造函数创建类B的对象。然后类B类型的指针指向以上新建的对象。 而后指针p调用test()函数。因为类B继承至类A，而且类B没有test()函数。因此此时的test()函数是类A的test()函数。 又因为类B拥有与类A形参列表相同的函数func()，而且类A的func()函数为虚函数。因此类B的func()函数会覆盖类A的函数。 因此类B在执行test()函数时，调用的是类B的func()函数。但是因为缺省参数是静态绑定的，因此val的值是基类A中的默认参数。因此就有： “绝不重新定义继承而来的缺省参数（Never redefine function’s inherited default parameters value.）”\n在构造函数中不要调用虚函数。在基类构造的时候，虚函数是非虚函数，不会走到派生类中，既是采用的静态绑定。 当我们构造一个子类的对象时，先调用基类的构造函数，构造子类中基类部分，子类还没有构造，还没有初始化，如果在基类的构造中调用虚函数，如果可以的话就是调用一个还没有被初始化的对象，那是很危险的。 在析构函数中也不要调用虚函数。在析构的时候会首先调用子类的析构函数，析构掉对象中的子类部分，然后在调用基类的析构函数析构基类部分。\n1.13.4 虚函数的性质 类中除了构造函数，静态函数以外的函数都可以为虚函数。 派生类要想覆盖(override)基类的虚函数，必须与基类的虚函数拥有相同的函数参数列表。\n在C++语言中，当我们使用基类的引用或指针调用一个虚成员函数时会执行动态绑定。因为我们知道运行时才知道调用了哪个版本的虚函数，所以所有虚函数都必须有定义。因此，我们必须为每一个虚函数都提供定义，而不管它是否被用到。只是因为，编译器也无法确定到底会使用哪个虚函数。\n对虚函数的调用可能在运行时才能被解析\n当某个虚函数通过指针或引用调用时，编译器产生的代码直到运行时才能确定应该调用哪个版本的函数。被调用的函数是与绑定到指针或引用上的对象的动态类型相匹配的哪一个。\n1 2 3 4 Quoute base(\u0026#34;0-201-82470-1\u0026#34;, 50); print_total(cout, base, 10);\t//调用Quote::net_price Bulk_quote derived(\u0026#34;0-201-82470-1\u0026#34;, 50, 5, 0.19); print_total(cout, derived, 10);\t//调用Bulk_quote:net_price 1.13.4.1 派生类中的虚函数 当我们在派生类中覆盖了某个虚函数时，可以再一次使用virtual关键字指出该函数的性质。\n然而这么做并非必须，因为一旦某个函数被声明为虚函数，则在所有派生类中它都是虚函数。\n一个派生类的函数如果覆盖了某个继承而来的虚函数，则它的形参类型必须与被它覆盖的基类函数完全一致。\n同样，派生类中虚函数的返回类型也必须与基类函数匹配。该规则存在一个例外, 当类的虚函数返回类型是类本身的指针或引用时，可以不遵循上述规则。例如，如果D由B派生得到，则基类的虚函数可以返回B*而派生类的对应函数可以返回D*。只不过这样的返回类型要求从D到B的类型转换是可访问的。\n温馨提示\n基类中的虚函数在派生类中隐含地也是一个虚函数。当派生类覆盖了某个虚函数时，该函数在基类中的形参必须与派生类中的形参严格匹配。\n1 2 3 4 5 6 7 8 9 10 11 struct B{ virtual void f1(int) const; virtual void f2(); void f3(); }; struct D1 : B{ void f1(int) const override; //正确：f1与基类中的f1匹配 void f2(int) override; //错误：B没有形如f2(int)的函数 void f3() override; //错误：B中f3不是虚函数 void f4() override; //错误：B中没有名为f4的函数 } 因为只有虚函数才能被覆盖。所以编译器会拒绝D1的f3。\n该函数不是B中的虚函数，因此它不能被覆盖。类似的，f4的声明也会发生错误，因为B中根本就没有名为f4的函数。\n我们还能把某个函数指定为final，如果我们已经把函数定义为final，则之后任何尝试覆盖该函数的操作都将引发错误：\n1 2 3 4 5 6 7 8 struct D2 : B{ //从B继承f2()和f3(),覆盖f1(int) void f1(int) const final; }; struct D3 : D2{ void f2();\t//正确：覆盖从间接基类B继承而来的f2 void f1(int) const;\t//错误：D2已经将f2声明为final }; 1.13.4.2 虚函数与默认实参 和其他函数一样，虚函数也可以拥有默认实参。如果某次函数调用使用了默认实参，则该实参值由本次调用的静态类型决定。 换句话说，如果我们通过基类的引用或指针 调用函数，则使用基类中定义的默认实参，即使实际运行的派生类中的函数版本也是如此。此时，传入派生类函数的将是基类函数定义的默认实参。如果派生类函数依赖不同的实参，则程序结果将与我们的与其不符。\n1.13.4.3 回避虚函数的机制 在某些情况下，我们希望对虚函数的调用不要进行动态绑定，而是强迫其执行虚函数的某个特定版本。使用作用域运算符可以实现这一目的。例如：\n1 2 //强行调用基类中定义的函数版本而不管baseP的动态类型到底是什么 double undiscounted = baseP-\u0026gt;Quote::net_price(42); 1.13.4.4 虚函数表 C++中虚函数使用虚函数表和虚函数表指针实现。\n虚函数表(vtabel,virtual function table):虚函数表是编译器在编译阶段生成的。虚函数表中存放的是虚函数的指针。\n编译器在每个含有虚函数的类中包含了一个虚函数表指针*__vptr。当创建一个该类的实例时，虚函数表指针将指向虚函数表。虚函数表存放在只读区(.rodata区)。\n1.14 访问控制与继承 继承类成员的访问级别\n成员权限(下)/ 继承权限(右) public protected private public public protected private protected protected protected private private 不可访问 不可访问 不可访问 ","date":"2024-12-15T22:08:07+08:00","permalink":"http://www.alvincat.top/post/cpp/cpp_oop/","tags":["OOP"],"title":"C++面向对象理论知识"},{"categories":["Tools"],"contents":"1 Qt下载与安装 QT5.9下载地址\n2 QT经典示例程序 简单计算器示例代码\n3 QT视频教程 传智播客《QT从入门到实战完整版》 \u0026ndash;\u0026gt; 视频配套代码\n","date":"2024-12-15T14:40:46+08:00","permalink":"http://www.alvincat.top/post/tools/qt_usful_tips/","tags":["QT"],"title":"QT入门"},{"categories":[""],"contents":"GCC总结常用编译命令和常用内置函数。\n1 GCC编译选项 1.1 GCC常用编译选项 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 file.c\tC语言源代码 file.i\t预处理后的C语言源文件 file.s\tGUN汇编代码 file.o\t链接文件 .a 归档库文件(Archive file) -o file\t指定生成的可执行文件的文件名为file -c\t编译或者汇编源代码，但是不执行链接操作；生成file.o文件 -E\t对源文件进行预处理,得到的信息显示在stdin;一般重定位到某个文件中，例如： gcc -E main.c \u0026gt; main.i -g\t在目标程序中加入调试信息，用于debug -I\t指定头文件所在的文件夹 -L\t指定函数库所在的文件夹 -O 对编译代码进行优化，后跟优化级别。例如-O3 -S\t将源代码编译为汇编代码；生成file.s文件 -std=standard standard,其中standard为C/C++的标准，例如c89,c99,c++0x,c++11 -Wall\t打开所有警告信息 1.2 GCC的attribute功能 1.2.1 aligned 功能说明：该属性指定结构体变量或者变量的最小对齐长度，单位是字节。\n示例：\n1 int x __attribute__ ((aligned (16))) = 0; 1.2.2 packed 功能说明：该属性指定结构体变量或者变量的最小对齐长度：变量最小对齐长度为1字节，结构体变量的最少为1位，除非通过aligned属性执行最大值。\n使用示例：\n1 2 3 4 struct foo { char a; int x[2] __attribute__ ((packed)); }; 1.2.3 section attribute((section(\u0026ldquo;name\u0026rdquo;)))实现在编译时把某个函数/数据放到指定的内存区域。以下两种格式都是可以的。\n1 2 __attribute__((__section__(\u0026#34;section_name\u0026#34;))) __attribute__((section(\u0026#34;section_name\u0026#34;))) 使用示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 struct duart a __attribute__ ((section (\u0026#34;DUART_A\u0026#34;))) = { 0 }; struct duart b __attribute__ ((section (\u0026#34;DUART_B\u0026#34;))) = { 0 }; char stack[10000] __attribute__ ((section (\u0026#34;STACK\u0026#34;))) = { 0 }; int init_data __attribute__ ((section (\u0026#34;INITDATA\u0026#34;))) = 0; int main() { /* Initialize stack pointer */ init_sp(stack + sizeof(stack)); /* Initialize initialized data */ memcpy(\u0026amp;init_data, \u0026amp;data, \u0026amp;edata - \u0026amp;data); /* Turn on the serial ports */ init_duart(\u0026amp;a); init_duart(\u0026amp;b); } 参考文献：\nGCC Specifying Attributes of Variables\n2 gcc编译时使用asan的方法 环境安装和gcc版本对应的libasan版本。 编译代码时添加-fsanitize=address参数。 例如：\n1 gcc -Wall -g -std=c99 -fsanitize=address lru.c -o lru 备注：ubuntu系统中不同asan版本和gcc的对应关系。\nlibasan0: gcc-4.8 libasan2: gcc-5 libasan3: gcc-6 libasan4: gcc-7 libasan5: gcc-8 3 GCC的","date":"2024-12-14T19:44:49+08:00","permalink":"http://www.alvincat.top/post/tools/gcc_usful_tips/","tags":[""],"title":"GCC常用编译命令和常用内置函数"},{"categories":["CPP"],"contents":"本文总结vector的原理和使用方法。\n1 vector的实现原理 1.2 vector保存在栈上还是堆上？ 示例代码1: 1 2 3 4 5 6 7 8 9 10 11 12 13 vector\u0026lt;int\u0026gt;* test_vec(void) { vector\u0026lt;int\u0026gt; vec; vec.push_back(1); vec.push_back(2); return \u0026amp;vec; } int main() { vector\u0026lt;int\u0026gt;* o_vec = test_vec(); printf(\u0026#34;%d\\n\u0026#34;, (*o_vec)[0]); return 0; } 在编译时会有如下提示：warning: reference to local variable 'vec' returned [-Wreturn-local-addr]。 而忽略该告警直接编译运行，进程会coredump。\n示例代码2 1 2 3 4 5 6 7 8 9 10 11 12 13 vector\u0026lt;int\u0026gt; test_vec(void) { vector\u0026lt;int\u0026gt; vec; vec.push_back(1); vec.push_back(2); return vec; } int main() { vector\u0026lt;int\u0026gt; o_vec = test_vec(); printf(\u0026#34;%d\\n\u0026#34;, o_vec[0]); return 0; } 该段代码可以正常编译运行，无任何报错。\n示例代码3 1 2 3 4 5 6 7 8 9 10 11 12 13 vector\u0026lt;int\u0026gt;* test_vec(void) { vector\u0026lt;int\u0026gt;* vec = new vector\u0026lt;int\u0026gt;; vec-\u0026gt;push_back(1); vec-\u0026gt;push_back(2); return vec; } int main() { vector\u0026lt;int\u0026gt;* o_vec = test_vec(); printf(\u0026#34;%d\\n\u0026#34;, (*o_vec)[0]); return 0; } 这段代码可以正常运行。\n原因分析：\n为什么示例代码1和实例代码2中的函数test_vec()相同，为啥返回vector变量的地址会coredump，而直接将vector的名字返回却可以正常运行呢？ 答：因为C++ 11新特性中支持直接返回容器名会默认调用move()函数,参考1.3.1和1.3.2的内容。 1.3 C++中返回一个vector的方法 1.3.1 通过value返回 1 2 3 4 5 6 #include \u0026lt;vector\u0026gt; std::vector\u0026lt;int\u0026gt; createVector() { std::vector\u0026lt;int\u0026gt; vec = {1, 2, 3, 4, 5}; return vec; // Move semantics will be applied here } 1.3.2 通过move()函数 1 2 3 4 std::vector\u0026lt;int\u0026gt; createVector() { std::vector\u0026lt;int\u0026gt; vec = {1, 2, 3, 4, 5}; return std::move(vec); // Explicitly moving the vector } 1.3.3 返回静态引用 1 2 3 4 std::vector\u0026lt;int\u0026gt;\u0026amp; getGlobalVector() { static std::vector\u0026lt;int\u0026gt; vec = {1, 2, 3, 4, 5}; return vec; // Return a reference to a static vector } 1.3.4 通过传入引用实现 1 2 3 void fillVector(std::vector\u0026lt;int\u0026gt;\u0026amp; vec) { vec = {1, 2, 3, 4, 5}; // Modify the existing vector } 1.3.5 使用std::optional 1 2 3 4 5 6 7 8 9 #include \u0026lt;optional\u0026gt; #include \u0026lt;vector\u0026gt; std::optional\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; createVector(bool shouldCreate) { if (shouldCreate) { return std::vector\u0026lt;int\u0026gt;{1, 2, 3, 4, 5}; } return std::nullopt; // No vector created } 相关参考文档：\nIs there a way to return a vector more efficiently\n一文带你详细介绍c++中的std::move函数\n【Modern C++】深入理解左值、右值\n2 vector的使用方法 2.1 vector初始化的方法 1 2 3 4 5 6 7 std::vector\u0026lt;int\u0026gt; first; // empty vector of ints std::vector\u0026lt;int\u0026gt; second(4, 100); // four ints with value 100 std::vector\u0026lt;int\u0026gt; third(second.begin(),second.end()); // iterating through second std::vector\u0026lt;int\u0026gt; fourth(third); // a copy of third int tmp[] = { 10, 20, 30 }; std::vector\u0026lt;int\u0026gt; v(tmp, tmp + 3 ); // use some utility to avoid hardcoding the size here 2.2 vector容量相关 1 2 3 std::vector\u0026lt;int\u0026gt; vec(3, 235); vec.size(); // return the number of elements vec.empty(); // checks whether the container is empty 2.3 vector数据修改 1 2 3 std::vector\u0026lt;int\u0026gt; vec(3, 235); // init vector vec.push_back(12); // adds an element to the end vec.pop_back(); // removes the last element ","date":"2024-12-13T22:45:13+08:00","permalink":"http://www.alvincat.top/post/cpp/stl/vector/","tags":["STL","vector"],"title":"Vector"},{"categories":["CPP"],"contents":"1 C++数据处理 1.1 获取浮点型数的小数部分 1 2 float value; float rear = value - (int)value; //获取浮点数的小数部分 1.2 double保留指定位数的小数 1 2 3 4 5 6 double round(double number, unsigned int bits) { stringstream ss; ss \u0026lt;\u0026lt; fixed \u0026lt;\u0026lt; setprecision(bits) \u0026lt;\u0026lt; number; ss \u0026gt;\u0026gt; number; return number; } 2 动态数组初始化方法 1 2 3 4 5 int size = 50; int *p=new int[size]; //申请动态数组 delete [] p; //释放动态数组 ","date":"2024-12-13T22:39:33+08:00","permalink":"http://www.alvincat.top/post/cpp/cpp_common_tips/","tags":[""],"title":"C++编码中常用的基础知识"},{"categories":["Tools"],"contents":"1 本文的gdb脚本的使用方法 将步骤2中的脚本拷贝到文件.gdbinit文件中； 然后就可以在gdb中使用对应的命令，查看c++容器中的内容。 2 GDB打印C++中容器内容的gdb脚本 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 # # STL GDB evaluators/views/utilities - 1.03 # # The new GDB commands: # are entirely non instrumental # do not depend on any \u0026#34;inline\u0026#34;(s) - e.g. size(), [], etc # are extremely tolerant to debugger settings # # This file should be \u0026#34;included\u0026#34; in .gdbinit as following: # source stl-views.gdb or just paste it into your .gdbinit file # # The following STL containers are currently supported: # # std::vector\u0026lt;T\u0026gt; -- via pvector command # std::list\u0026lt;T\u0026gt; -- via plist or plist_member command # std::map\u0026lt;T,T\u0026gt; -- via pmap or pmap_member command # std::multimap\u0026lt;T,T\u0026gt; -- via pmap or pmap_member command # std::set\u0026lt;T\u0026gt; -- via pset command # std::multiset\u0026lt;T\u0026gt; -- via pset command # std::deque\u0026lt;T\u0026gt; -- via pdequeue command # std::stack\u0026lt;T\u0026gt; -- via pstack command # std::queue\u0026lt;T\u0026gt; -- via pqueue command # std::priority_queue\u0026lt;T\u0026gt; -- via ppqueue command # std::bitset\u0026lt;n\u0026gt; -- via pbitset command # std::string -- via pstring command # std::widestring -- via pwstring command # # The end of this file contains (optional) C++ beautifiers # Make sure your debugger supports $argc # # Simple GDB Macros writen by Dan Marinescu (H-PhD) - License GPL # Inspired by intial work of Tom Malnar, # Tony Novac (PhD) / Cornell / Stanford, # Gilad Mishne (PhD) and Many Many Others. # Contact: dan_c_marinescu@yahoo.com (Subject: STL) # # Modified to work with g++ 4.3 by Anders Elton # Also added _member functions, that instead of printing the entire class in map, prints a member. # # std::vector\u0026lt;\u0026gt; # define pvector if $argc == 0 help pvector else set $size = $arg0._M_impl._M_finish - $arg0._M_impl._M_start set $capacity = $arg0._M_impl._M_end_of_storage - $arg0._M_impl._M_start set $size_max = $size - 1 end if $argc == 1 set $i = 0 while $i \u0026lt; $size printf \u0026#34;elem[%u]: \u0026#34;, $i p *($arg0._M_impl._M_start + $i) set $i++ end end if $argc == 2 set $idx = $arg1 if $idx \u0026lt; 0 || $idx \u0026gt; $size_max printf \u0026#34;idx1, idx2 are not in acceptable range: [0..%u].\\n\u0026#34;, $size_max else printf \u0026#34;elem[%u]: \u0026#34;, $idx p *($arg0._M_impl._M_start + $idx) end end if $argc == 3 set $start_idx = $arg1 set $stop_idx = $arg2 if $start_idx \u0026gt; $stop_idx set $tmp_idx = $start_idx set $start_idx = $stop_idx set $stop_idx = $tmp_idx end if $start_idx \u0026lt; 0 || $stop_idx \u0026lt; 0 || $start_idx \u0026gt; $size_max || $stop_idx \u0026gt; $size_max printf \u0026#34;idx1, idx2 are not in acceptable range: [0..%u].\\n\u0026#34;, $size_max else set $i = $start_idx while $i \u0026lt;= $stop_idx printf \u0026#34;elem[%u]: \u0026#34;, $i p *($arg0._M_impl._M_start + $i) set $i++ end end end if $argc \u0026gt; 0 printf \u0026#34;Vector size = %u\\n\u0026#34;, $size printf \u0026#34;Vector capacity = %u\\n\u0026#34;, $capacity printf \u0026#34;Element \u0026#34; whatis $arg0._M_impl._M_start end end document pvector Prints std::vector\u0026lt;T\u0026gt; information. Syntax: pvector \u0026lt;vector\u0026gt; \u0026lt;idx1\u0026gt; \u0026lt;idx2\u0026gt; Note: idx, idx1 and idx2 must be in acceptable range [0..\u0026lt;vector\u0026gt;.size()-1]. Examples: pvector v - Prints vector content, size, capacity and T typedef pvector v 0 - Prints element[idx] from vector pvector v 1 2 - Prints elements in range [idx1..idx2] from vector end # # std::list\u0026lt;\u0026gt; # define plist if $argc == 0 help plist else set $head = \u0026amp;$arg0._M_impl._M_node set $current = $arg0._M_impl._M_node._M_next set $size = 0 while $current != $head if $argc == 2 printf \u0026#34;elem[%u]: \u0026#34;, $size p *($arg1*)($current + 1) end if $argc == 3 if $size == $arg2 printf \u0026#34;elem[%u]: \u0026#34;, $size p *($arg1*)($current + 1) end end set $current = $current._M_next set $size++ end printf \u0026#34;List size = %u \\n\u0026#34;, $size if $argc == 1 printf \u0026#34;List \u0026#34; whatis $arg0 printf \u0026#34;Use plist \u0026lt;variable_name\u0026gt; \u0026lt;element_type\u0026gt; to see the elements in the list.\\n\u0026#34; end end end document plist Prints std::list\u0026lt;T\u0026gt; information. Syntax: plist \u0026lt;list\u0026gt; \u0026lt;T\u0026gt; \u0026lt;idx\u0026gt;: Prints list size, if T defined all elements or just element at idx Examples: plist l - prints list size and definition plist l int - prints all elements and list size plist l int 2 - prints the third element in the list (if exists) and list size end define plist_member if $argc == 0 help plist_member else set $head = \u0026amp;$arg0._M_impl._M_node set $current = $arg0._M_impl._M_node._M_next set $size = 0 while $current != $head if $argc == 3 printf \u0026#34;elem[%u]: \u0026#34;, $size p (*($arg1*)($current + 1)).$arg2 end if $argc == 4 if $size == $arg3 printf \u0026#34;elem[%u]: \u0026#34;, $size p (*($arg1*)($current + 1)).$arg2 end end set $current = $current._M_next set $size++ end printf \u0026#34;List size = %u \\n\u0026#34;, $size if $argc == 1 printf \u0026#34;List \u0026#34; whatis $arg0 printf \u0026#34;Use plist_member \u0026lt;variable_name\u0026gt; \u0026lt;element_type\u0026gt; \u0026lt;member\u0026gt; to see the elements in the list.\\n\u0026#34; end end end document plist_member Prints std::list\u0026lt;T\u0026gt; information. Syntax: plist \u0026lt;list\u0026gt; \u0026lt;T\u0026gt; \u0026lt;idx\u0026gt;: Prints list size, if T defined all elements or just element at idx Examples: plist_member l int member - prints all elements and list size plist_member l int member 2 - prints the third element in the list (if exists) and list size end # # std::map and std::multimap # define pmap if $argc == 0 help pmap else set $tree = $arg0 set $i = 0 set $node = $tree._M_t._M_impl._M_header._M_left set $end = $tree._M_t._M_impl._M_header set $tree_size = $tree._M_t._M_impl._M_node_count if $argc == 1 printf \u0026#34;Map \u0026#34; whatis $tree printf \u0026#34;Use pmap \u0026lt;variable_name\u0026gt; \u0026lt;left_element_type\u0026gt; \u0026lt;right_element_type\u0026gt; to see the elements in the map.\\n\u0026#34; end if $argc == 3 while $i \u0026lt; $tree_size set $value = (void *)($node + 1) printf \u0026#34;elem[%u].left: \u0026#34;, $i p *($arg1*)$value set $value = $value + sizeof($arg1) printf \u0026#34;elem[%u].right: \u0026#34;, $i p *($arg2*)$value if $node._M_right != 0 set $node = $node._M_right while $node._M_left != 0 set $node = $node._M_left end else set $tmp_node = $node._M_parent while $node == $tmp_node._M_right set $node = $tmp_node set $tmp_node = $tmp_node._M_parent end if $node._M_right != $tmp_node set $node = $tmp_node end end set $i++ end end if $argc == 4 set $idx = $arg3 set $ElementsFound = 0 while $i \u0026lt; $tree_size set $value = (void *)($node + 1) if *($arg1*)$value == $idx printf \u0026#34;elem[%u].left: \u0026#34;, $i p *($arg1*)$value set $value = $value + sizeof($arg1) printf \u0026#34;elem[%u].right: \u0026#34;, $i p *($arg2*)$value set $ElementsFound++ end if $node._M_right != 0 set $node = $node._M_right while $node._M_left != 0 set $node = $node._M_left end else set $tmp_node = $node._M_parent while $node == $tmp_node._M_right set $node = $tmp_node set $tmp_node = $tmp_node._M_parent end if $node._M_right != $tmp_node set $node = $tmp_node end end set $i++ end printf \u0026#34;Number of elements found = %u\\n\u0026#34;, $ElementsFound end if $argc == 5 set $idx1 = $arg3 set $idx2 = $arg4 set $ElementsFound = 0 while $i \u0026lt; $tree_size set $value = (void *)($node + 1) set $valueLeft = *($arg1*)$value set $valueRight = *($arg2*)($value + sizeof($arg1)) if $valueLeft == $idx1 \u0026amp;\u0026amp; $valueRight == $idx2 printf \u0026#34;elem[%u].left: \u0026#34;, $i p $valueLeft printf \u0026#34;elem[%u].right: \u0026#34;, $i p $valueRight set $ElementsFound++ end if $node._M_right != 0 set $node = $node._M_right while $node._M_left != 0 set $node = $node._M_left end else set $tmp_node = $node._M_parent while $node == $tmp_node._M_right set $node = $tmp_node set $tmp_node = $tmp_node._M_parent end if $node._M_right != $tmp_node set $node = $tmp_node end end set $i++ end printf \u0026#34;Number of elements found = %u\\n\u0026#34;, $ElementsFound end printf \u0026#34;Map size = %u\\n\u0026#34;, $tree_size end end document pmap Prints std::map\u0026lt;TLeft and TRight\u0026gt; or std::multimap\u0026lt;TLeft and TRight\u0026gt; information. Works for std::multimap as well. Syntax: pmap \u0026lt;map\u0026gt; \u0026lt;TtypeLeft\u0026gt; \u0026lt;TypeRight\u0026gt; \u0026lt;valLeft\u0026gt; \u0026lt;valRight\u0026gt;: Prints map size, if T defined all elements or just element(s) with val(s) Examples: pmap m - prints map size and definition pmap m int int - prints all elements and map size pmap m int int 20 - prints the element(s) with left-value = 20 (if any) and map size pmap m int int 20 200 - prints the element(s) with left-value = 20 and right-value = 200 (if any) and map size end define pmap_member if $argc == 0 help pmap_member else set $tree = $arg0 set $i = 0 set $node = $tree._M_t._M_impl._M_header._M_left set $end = $tree._M_t._M_impl._M_header set $tree_size = $tree._M_t._M_impl._M_node_count if $argc == 1 printf \u0026#34;Map \u0026#34; whatis $tree printf \u0026#34;Use pmap \u0026lt;variable_name\u0026gt; \u0026lt;left_element_type\u0026gt; \u0026lt;right_element_type\u0026gt; to see the elements in the map.\\n\u0026#34; end if $argc == 5 while $i \u0026lt; $tree_size set $value = (void *)($node + 1) printf \u0026#34;elem[%u].left: \u0026#34;, $i p (*($arg1*)$value).$arg2 set $value = $value + sizeof($arg1) printf \u0026#34;elem[%u].right: \u0026#34;, $i p (*($arg3*)$value).$arg4 if $node._M_right != 0 set $node = $node._M_right while $node._M_left != 0 set $node = $node._M_left end else set $tmp_node = $node._M_parent while $node == $tmp_node._M_right set $node = $tmp_node set $tmp_node = $tmp_node._M_parent end if $node._M_right != $tmp_node set $node = $tmp_node end end set $i++ end end if $argc == 6 set $idx = $arg5 set $ElementsFound = 0 while $i \u0026lt; $tree_size set $value = (void *)($node + 1) if *($arg1*)$value == $idx printf \u0026#34;elem[%u].left: \u0026#34;, $i p (*($arg1*)$value).$arg2 set $value = $value + sizeof($arg1) printf \u0026#34;elem[%u].right: \u0026#34;, $i p (*($arg3*)$value).$arg4 set $ElementsFound++ end if $node._M_right != 0 set $node = $node._M_right while $node._M_left != 0 set $node = $node._M_left end else set $tmp_node = $node._M_parent while $node == $tmp_node._M_right set $node = $tmp_node set $tmp_node = $tmp_node._M_parent end if $node._M_right != $tmp_node set $node = $tmp_node end end set $i++ end printf \u0026#34;Number of elements found = %u\\n\u0026#34;, $ElementsFound end printf \u0026#34;Map size = %u\\n\u0026#34;, $tree_size end end document pmap_member Prints std::map\u0026lt;TLeft and TRight\u0026gt; or std::multimap\u0026lt;TLeft and TRight\u0026gt; information. Works for std::multimap as well. Syntax: pmap \u0026lt;map\u0026gt; \u0026lt;TtypeLeft\u0026gt; \u0026lt;TypeRight\u0026gt; \u0026lt;valLeft\u0026gt; \u0026lt;valRight\u0026gt;: Prints map size, if T defined all elements or just element(s) with val(s) Examples: pmap_member m class1 member1 class2 member2 - prints class1.member1 : class2.member2 pmap_member m class1 member1 class2 member2 lvalue - prints class1.member1 : class2.member2 where class1 == lvalue end # # std::set and std::multiset # define pset if $argc == 0 help pset else set $tree = $arg0 set $i = 0 set $node = $tree._M_t._M_impl._M_header._M_left set $end = $tree._M_t._M_impl._M_header set $tree_size = $tree._M_t._M_impl._M_node_count if $argc == 1 printf \u0026#34;Set \u0026#34; whatis $tree printf \u0026#34;Use pset \u0026lt;variable_name\u0026gt; \u0026lt;element_type\u0026gt; to see the elements in the set.\\n\u0026#34; end if $argc == 2 while $i \u0026lt; $tree_size set $value = (void *)($node + 1) printf \u0026#34;elem[%u]: \u0026#34;, $i p *($arg1*)$value if $node._M_right != 0 set $node = $node._M_right while $node._M_left != 0 set $node = $node._M_left end else set $tmp_node = $node._M_parent while $node == $tmp_node._M_right set $node = $tmp_node set $tmp_node = $tmp_node._M_parent end if $node._M_right != $tmp_node set $node = $tmp_node end end set $i++ end end if $argc == 3 set $idx = $arg2 set $ElementsFound = 0 while $i \u0026lt; $tree_size set $value = (void *)($node + 1) if *($arg1*)$value == $idx printf \u0026#34;elem[%u]: \u0026#34;, $i p *($arg1*)$value set $ElementsFound++ end if $node._M_right != 0 set $node = $node._M_right while $node._M_left != 0 set $node = $node._M_left end else set $tmp_node = $node._M_parent while $node == $tmp_node._M_right set $node = $tmp_node set $tmp_node = $tmp_node._M_parent end if $node._M_right != $tmp_node set $node = $tmp_node end end set $i++ end printf \u0026#34;Number of elements found = %u\\n\u0026#34;, $ElementsFound end printf \u0026#34;Set size = %u\\n\u0026#34;, $tree_size end end document pset Prints std::set\u0026lt;T\u0026gt; or std::multiset\u0026lt;T\u0026gt; information. Works for std::multiset as well. Syntax: pset \u0026lt;set\u0026gt; \u0026lt;T\u0026gt; \u0026lt;val\u0026gt;: Prints set size, if T defined all elements or just element(s) having val Examples: pset s - prints set size and definition pset s int - prints all elements and the size of s pset s int 20 - prints the element(s) with value = 20 (if any) and the size of s end # # std::dequeue # define pdequeue if $argc == 0 help pdequeue else set $vec = ($arg0) # size of one data element set $datasize = sizeof(**$vec._M_impl._M_map) # bufsize is the number of nodes per memory page set $bufsize = $datasize \u0026lt; 512 ? 512/$datasize : 1 set $iter = $vec._M_impl._M_start set $enditer = $vec._M_impl._M_finish set $mnode = $iter._M_node set $mfirst = $iter._M_first set $mlast = $iter._M_last set $mcur = $iter._M_cur set $size = 0 while ($mcur != $enditer._M_cur) if $argc == 2 printf \u0026#34;elem[%u]: \u0026#34;, $size p *($arg1*)($mcur) end if $argc == 3 if $size == $arg2 printf \u0026#34;elem[%u]: \u0026#34;, $size p *($arg1*)($mcur) end end if $argc == 1 printf \u0026#34;elem[%u]: \u0026#34;, $size p *$mcur end # now imitate iter.operator++ set $mcur++ if ($mcur == $mlast) set $mnode++ set $mfirst = *$mnode set $mlast = $mfirst + $bufsize set $mcur = $mfirst end set $size++ end printf \u0026#34;Dequeue size = %u\\n\u0026#34;, $size end end document pdequeue Prints std::dequeue\u0026lt;T\u0026gt; information. Syntax: pdequeue \u0026lt;dequeue\u0026gt;: Prints dequeue size, if T defined all elements Deque elements are listed \u0026#34;left to right\u0026#34; (left-most stands for front and right-most stands for back) Example: pdequeue d - prints all elements and size of d end # # std::stack # define pstack if $argc == 0 help pstack else set $start_cur = $arg0.c._M_impl._M_start._M_cur set $finish_cur = $arg0.c._M_impl._M_finish._M_cur set $size = $finish_cur - $start_cur set $i = $size - 1 while $i \u0026gt;= 0 p *($start_cur + $i) set $i-- end printf \u0026#34;Stack size = %u\\n\u0026#34;, $size end end document pstack Prints std::stack\u0026lt;T\u0026gt; information. Syntax: pstack \u0026lt;stack\u0026gt;: Prints all elements and size of the stack Stack elements are listed \u0026#34;top to buttom\u0026#34; (top-most element is the first to come on pop) Example: pstack s - prints all elements and the size of s end # # std::queue # define pqueue if $argc == 0 help pqueue else set $start_cur = $arg0.c._M_impl._M_start._M_cur set $finish_cur = $arg0.c._M_impl._M_finish._M_cur set $size = $finish_cur - $start_cur set $i = 0 while $i \u0026lt; $size p *($start_cur + $i) set $i++ end printf \u0026#34;Queue size = %u\\n\u0026#34;, $size end end document pqueue Prints std::queue\u0026lt;T\u0026gt; information. Syntax: pqueue \u0026lt;queue\u0026gt;: Prints all elements and the size of the queue Queue elements are listed \u0026#34;top to bottom\u0026#34; (top-most element is the first to come on pop) Example: pqueue q - prints all elements and the size of q end # # std::priority_queue # define ppqueue if $argc == 0 help ppqueue else set $size = $arg0.c._M_impl._M_finish - $arg0.c._M_impl._M_start set $capacity = $arg0.c._M_impl._M_end_of_storage - $arg0.c._M_impl._M_start set $i = $size - 1 while $i \u0026gt;= 0 p *($arg0.c._M_impl._M_start + $i) set $i-- end printf \u0026#34;Priority queue size = %u\\n\u0026#34;, $size printf \u0026#34;Priority queue capacity = %u\\n\u0026#34;, $capacity end end document ppqueue Prints std::priority_queue\u0026lt;T\u0026gt; information. Syntax: ppqueue \u0026lt;priority_queue\u0026gt;: Prints all elements, size and capacity of the priority_queue Priority_queue elements are listed \u0026#34;top to buttom\u0026#34; (top-most element is the first to come on pop) Example: ppqueue pq - prints all elements, size and capacity of pq end # # std::bitset # define pbitset if $argc == 0 help pbitset else p /t $arg0._M_w end end document pbitset Prints std::bitset\u0026lt;n\u0026gt; information. Syntax: pbitset \u0026lt;bitset\u0026gt;: Prints all bits in bitset Example: pbitset b - prints all bits in b end # # std::string # define pstring if $argc == 0 help pstring else printf \u0026#34;String \\t\\t\\t= \\\u0026#34;%s\\\u0026#34;\\n\u0026#34;, $arg0._M_data() printf \u0026#34;String size/length \\t= %u\\n\u0026#34;, $arg0._M_rep()._M_length printf \u0026#34;String capacity \\t= %u\\n\u0026#34;, $arg0._M_rep()._M_capacity printf \u0026#34;String ref-count \\t= %d\\n\u0026#34;, $arg0._M_rep()._M_refcount end end document pstring Prints std::string information. Syntax: pstring \u0026lt;string\u0026gt; Example: pstring s - Prints content, size/length, capacity and ref-count of string s end # # std::wstring # define pwstring if $argc == 0 help pwstring else call printf(\u0026#34;WString \\t\\t= \\\u0026#34;%ls\\\u0026#34;\\n\u0026#34;, $arg0._M_data()) printf \u0026#34;WString size/length \\t= %u\\n\u0026#34;, $arg0._M_rep()._M_length printf \u0026#34;WString capacity \\t= %u\\n\u0026#34;, $arg0._M_rep()._M_capacity printf \u0026#34;WString ref-count \\t= %d\\n\u0026#34;, $arg0._M_rep()._M_refcount end end document pwstring Prints std::wstring information. Syntax: pwstring \u0026lt;wstring\u0026gt; Example: pwstring s - Prints content, size/length, capacity and ref-count of wstring s end # # C++ related beautifiers (optional) # set print pretty on set print object on set print static-members on set print vtbl on set print demangle on set demangle-style gnu-v3 set print sevenbit-strings off set follow-fork-mode child set detach-on-fork off ","date":"2024-12-13T22:15:25+08:00","permalink":"http://www.alvincat.top/post/tools/gdb_print_stl_tool/","tags":["GDB"],"title":"GDB打印C++ STL容器中的内容的方法"},{"categories":["Linux"],"contents":"本文介绍Linux系统中各种钩子的使用方法以及使用场景。\n1 用户态钩子 2 内核态钩子","date":"2024-12-13T15:49:45+08:00","permalink":"http://www.alvincat.top/post/linux/linux_hook/","tags":["hook"],"title":"Linux系统中钩子的使用方法"},{"categories":["算法"],"contents":"本文介绍拓扑排序的原理和代码实现。\n1 拓扑排序的基本原理 能够使用拓扑排序的图一定是一个有向无环图(DAG, Directed Acyclic Graph)。若是一个有向有环图，则任务无法完成，存在循环依赖问题。\n2 拓扑排序的代码实现 2.1 使用深度优先遍历 2.2 使用广度优先遍历 2.3 课程表 课程表相关的LeetCode题目:\n207. 课程表\n210. 课程表 II\n2050. 并行课程 III\n2.3.1 207. 课程表 保存每个结点的入度数量； 保存每个结点的出度结点； 每次将入度为0的结点添加至队列，出队列时，将其关联的出度结点的入度减1； 当遍历完所有结点时，若存在入度不为0的结点，说明这个图存在环，任务无法完成；否则任务可以完成； 实际上该算法是用于判断这个有向图是否存在环。拓扑排序要求图为有向图无环。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class Solution { public: bool canFinish(int numCourses, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; prerequisites) { vector\u0026lt;int\u0026gt; indegree(numCourses, 0); unordered_map\u0026lt;int, vector\u0026lt;int\u0026gt;\u0026gt; outdegreeNode; // init indegree and outdegreeNode for (int i = 0; i \u0026lt; prerequisites.size(); ++i) { int out = prerequisites[i][0]; int in = prerequisites[i][1]; indegree[out]++; outdegreeNode[in].push_back(out); } queue\u0026lt;int\u0026gt; que; int count = numCourses; // node count for (int i = 0; i \u0026lt; numCourses; ++i) { if (indegree[i] == 0) { indegree[i] = -1; que.push(i); --count; } } while (!que.empty() \u0026amp;\u0026amp; count != 0) { int front = que.front(); que.pop(); for (int item : outdegreeNode[front]) { if (indegree[item] \u0026gt; 0) { --indegree[item]; if (indegree[item] == 0) { indegree[item] = -1; que.push(item); --count; } } } } return count == 0; } }; 2.3.2 210. 课程表 II 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 bool canFinish(int numCourses, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; prerequisites) { vector\u0026lt;int\u0026gt; indegree(numCourses, 0); unordered_map\u0026lt;int, vector\u0026lt;int\u0026gt;\u0026gt; outdegreeNode; // init indegree and outdegreeNode for (int i = 0; i \u0026lt; prerequisites.size(); ++i) { int out = prerequisites[i][0]; int in = prerequisites[i][1]; indegree[out]++; outdegreeNode[in].push_back(out); } queue\u0026lt;int\u0026gt; que; int count = numCourses; // node count for (int i = 0; i \u0026lt; numCourses; ++i) { if (indegree[i] == 0) { indegree[i] = -1; que.push(i); --count; } } while (!que.empty() \u0026amp;\u0026amp; count \u0026gt;= 0) { int front = que.front(); que.pop(); for (int item : outdegreeNode[front]) { if (indegree[item] \u0026gt; 0) { --indegree[item]; if (indegree[item] == 0) { indegree[item] = -1; que.push(item); --count; } } } } if (count == 0) { return res; } return {}; } 2.3.3 2050. 并行课程 III 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 int minimumTime(int n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; relations, vector\u0026lt;int\u0026gt;\u0026amp; time) { vector\u0026lt;int\u0026gt; indegree(n+1, 0); vector\u0026lt;int\u0026gt; indegreeMaxTime(n+1, 0); // 记录每个结点的入度结点中的最大值 unordered_map\u0026lt;int, vector\u0026lt;int\u0026gt;\u0026gt; outdegreeNode; vector\u0026lt;int\u0026gt; node_time(time.begin(), time.end()); // init indegree and outdegreeNode for (int i = 0; i \u0026lt; relations.size(); ++i) { int in = relations[i][0]; int out = relations[i][1]; indegree[out]++; indegreeMaxTime[out] = max(indegreeMaxTime[out], node_time[in-1]); outdegreeNode[in].push_back(out); } queue\u0026lt;int\u0026gt; que; for (int i = 1; i \u0026lt;= n; ++i) { if (indegree[i] == 0) { indegree[i] = -1; que.push(i); } } while (!que.empty()) { int front = que.front(); que.pop(); node_time[front-1] = indegreeMaxTime[front] + node_time[front-1]; for (int item : outdegreeNode[front]) { if (indegree[item] \u0026gt; 0) { --indegree[item]; indegreeMaxTime[item] = max(indegreeMaxTime[item], node_time[front-1]); if (indegree[item] == 0) { indegree[item] = -1; que.push(item); } } } } return *max_element(node_time.begin(), node_time.end()); } ","date":"2024-12-13T12:07:28+08:00","permalink":"http://www.alvincat.top/post/data_structure/graph/topological_sorting/","tags":["有向图","拓扑排序"],"title":"拓扑排序"},{"categories":["CPP"],"contents":"本文总结C++中容易混淆的概念。\n1 常见易混淆知识点 1.1 内存控制 1.1.1 malloc/free, new/delete的区别 malloc和free是C/C++语言的标准库函数,而new/delete是C++的运算符。它们都可以用于动态申请和释放内存。 new/delete运算符不仅可以申请/释放内存，还可以对申请的对象进行初始化和销毁操作。 C++既可以使用new/delete，也可以调用malloc/free。而C语言只能用malloc/free管理动态内存。 1.1.2 new/delete new/delete就是C++的运算符。new的全称为new operator, delete的全称为delete operator。其作用是为分配并初始化一个对象数组。\nC++执行new操作实际上后台执行了以下3步操作： 调用operate new或者operate new []的标准库函数。该函数分配一块原始的、足够大的、未命名的存储特定类型对象的空间； 编译器运行相应的构造函数以构造这些特定对象(或对象数组)； 对象被构造完成并分配的空间，返回一个指向该对象的指针。 C++执行delete操作实际上后台执行了以下2步操作：\n对所指向的对象或者对象数组执行对应的析构函数； 编译器调用operate delete(或者operate delete[])的标准库函数释放内存空间。 使用示例：\n1 2 3 4 5 int* p = new int; delete p; int* pa = new int[10]; delete [] pa; 1.1.3 operate new/delete operate new/delte是C++的标准函数。用于用于为特定类型的对象分配或者释放内存空间。operate new/delete的函数原型定义如下： 1 2 3 4 5 6 7 8 9 10 void* operate new(size_t); // 分配一个对象 void* operate new[](size_t); // 分配一个对象数组 void* operate delete(void*) noexpect; // 释放一个对象 void* operate delete[](void*) noexpect; // 释放一个对象数组 // 不会抛出异常的函数，功能同上 void* operate new(size_t, nothrow_t\u0026amp;) noexpect; void* operate new[](size_t, nothrow_t\u0026amp;) noexpect; void* operate delete(void*, nothrow_t\u0026amp;) noexpect; void* operate delete[](void*, nothrow_t\u0026amp;) noexpect; 如果应用程序希望自己控制内存的分配和释放，就需要自己定义operate new和operate delete函数，从而让编译器使用自定义的版本替换标准库中定义的版本。 应用程序可以在全局作用域中定义oprerate new/delete函数或者定义为类的成员函数。\n如果分配或者释放的的对象是类对象，则首先在类中查找是否有自定义的oprerate new/delete函数。若没查找到，再到全局作用域中查找。\n我们也可以直接指定查找全局作用域的函数：使用::new ::delete可以指定查找全局作用域的函数。 因为operate new用在构造函数之前而operate delete用在对象销毁之后，所以这两个成员函数必须是静态函数，而且不能操作类的任何数据成员。\n例外：不能重载以下形式的operate new函数：\n1 void* operate new(size_t, void*); 这种形式只供标准库使用，不能被用户重新定义。\n温馨提示：\n实际上C++也有和operate new/delete功能相似的标准库allocator类，用于为指定类型的对象分配内存。它非配的内存是原始、未构造的。\n1.1.4 placement new placement new用于对使用operate new的方式申请的内存上构造对象。placement new的几种形式：\n1 2 3 4 new (place_address) type new (place_address) type (initializers) new (place_address) type [size] new (place_address) type [size] {braced initializer list} 其中place_address必须是一个指针，同时在initializers中提供一个(可能为空)的逗号分隔的初始化列表，该初始值列表用于构造新分配的对象。\n1.1.5 智能指针 1.1.5.1 shared_ptr 1.1.5.2 unique_ptr 1.1.5.3 weak_ptr 1.2 指针与引用的区别 指针本身就是一个对象，其内容是某个内存单元的地址，允许对指针赋值和拷贝；而引用并非对象，它只是一个已经存在的对象的一个别名。 指针在它的生命周期内可以指向不同的对象；而引用一旦初始化完成，将和它的初始值始终绑定在一起。 指针无须在定义时赋初值；而引用必须初始化，绑定到一个已经存在的对象。指针可以为空，但引用不可以。 sizeof操作指针和引用的结果不同；sizeof操作引用得到的是引用所绑定的对象的大小；而sizeof操作指针得到的是指针本身的大小。 引用是类型安全的，而指针不是。 1.3 struct和class的区别 struct的成员(成员函数和数据成员)的访问控制属性默认是共有的；而class的成员默认是私有的。 struct的继承默认是共有继承，而class的默认继承方式是私有的。 1.4 const修饰常量与define的区别 const定义的常量在编译阶段进行处理；#define定义的常量在预处理阶段进行处理； const定义的常量要进行类型检查；#define定义的常量只是简单的文本替换，没有类型，不进行类型检查； const定义的常量要分配内存；#define定义的常量为宏定义，不需要分配内存； const定义的常量存放在数据区，只有一份拷贝；#define定义的常量不分配存储空间，使用过程中只是简单的执行文本替换； 1.5 重载覆盖隐藏的区别 1.5.1 重载 重载的特点：\n相同的范围（在同一个类中） 函数名字相同 参数不同 virtual 关键字可有可无 1.5.2 覆盖 覆盖是指派生类函数覆盖基类虚函数。其特征为：\n不同的范围（分别位于派生类与基类）； 函数名字相同 参数相同 基类函数必须有virtual 关键字 1.5.3 隐藏 “隐藏”是指派生类的函数屏蔽了与其同名的基类函数，规则如下：\n如果派生类的函数与基类的函数同名，但是参数不同。此时，不论有无virtual关键字，基类的函数将被隐藏（注意别与重载混淆）。 如果派生类的函数与基类的函数同名，并且参数也相同而且基类函数没有virtual 关键字。此时，基类的函数被隐藏（注意别与覆盖混淆） 1.5.4 覆盖隐藏的示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 class Base { public: virtual void fcn() { cout \u0026lt;\u0026lt; \u0026#34;This is Base fcn().\u0026#34; \u0026lt;\u0026lt; endl; } }; class FristDerived : public Base { public: // FristDerived继承Base中的虚函数fcn() // 形参与Base::fcn()中的不一致，隐藏基类的fcn() void fcn(int) { cout \u0026lt;\u0026lt; \u0026#34;This is FristDerived fcn().\u0026#34; \u0026lt;\u0026lt; endl; } // 新增一个虚函数，在Base中不存在 virtual void display() { cout \u0026lt;\u0026lt; \u0026#34;This is FristDerived display().\u0026#34; \u0026lt;\u0026lt; endl; } }; class SecondDerived : public FristDerived { public: // 隐藏FristDerived::fcn(int) void fcn(int a) { cout \u0026lt;\u0026lt; \u0026#34;This is SecondDerived fcn(\u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34;).\u0026#34; \u0026lt;\u0026lt; endl; } void fcn() { // 覆盖Base中的虚函数fcn() cout \u0026lt;\u0026lt; \u0026#34;This is SecondDerived fcn().\u0026#34; \u0026lt;\u0026lt; endl; } void display() { // 覆盖FristDerived中的虚函数display()函数 cout \u0026lt;\u0026lt; \u0026#34;This is SecondDerived display().\u0026#34; \u0026lt;\u0026lt; endl; } }; int main() { Base base_obj; FristDerived fd_obj; SecondDerived sd_obj; Base* bp1 = \u0026amp;base_obj; Base* bp2 = \u0026amp;fd_obj; Base* bp3 = \u0026amp;sd_obj; bp1-\u0026gt;fcn(); // Base::fcn() bp2-\u0026gt;fcn(); // Base::fcn() bp3-\u0026gt;fcn(); // SecondDerived::fcn() cout \u0026lt;\u0026lt; \u0026#34;----------\u0026#34; \u0026lt;\u0026lt; endl; FristDerived* fd = \u0026amp;fd_obj; SecondDerived* sd = \u0026amp;sd_obj; // bp2-\u0026gt;display(); // 错误，Base没有display()函数 fd-\u0026gt;display(); // FristDerived::display() sd-\u0026gt;display(); // SecondDerived::display() return 0; } ","date":"2024-12-13T12:06:32+08:00","permalink":"http://www.alvincat.top/post/cpp/cpp_interview_knowledge/","tags":[""],"title":"C++中一些易混淆的基础知识"},{"categories":["Linux"],"contents":"本文介绍进程打印堆栈的原理。\n1.1 涉及结构体 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 struct dl_phdr_info { ElfW(Addr) dlpi_addr; /* Base address of object */ const char *dlpi_name; /* (Null-terminated) name of object */ const ElfW(Phdr) *dlpi_phdr; /* Pointer to array of ELF program headers for this object */ ElfW(Half) dlpi_phnum; /* # of items in dlpi_phdr */ /* The following fields were added in glibc 2.4, after the first version of this structure was available. Check the size argument passed to the dl_iterate_phdr callback to determine whether or not each later member is available. */ unsigned long long dlpi_adds; /* Incremented when a new object may have been added */ unsigned long long dlpi_subs; /* Incremented when an object may have been removed */ size_t dlpi_tls_modid; /* If there is a PT_TLS segment, its module ID as used in TLS relocations, else zero */ void *dlpi_tls_data; /* The address of the calling thread\u0026#39;s instance of this module\u0026#39;s PT_TLS segment, if it has one and it has been allocated in the calling thread, otherwise a null pointer */ }; typedef struct { Elf32_Word p_type; /* Segment type */ Elf32_Off p_offset; /* Segment file offset */ Elf32_Addr p_vaddr; /* Segment virtual address */ Elf32_Addr p_paddr; /* Segment physical address */ Elf32_Word p_filesz; /* Segment size in file */ Elf32_Word p_memsz; /* Segment size in memory */ Elf32_Word p_flags; /* Segment flags */ Elf32_Word p_align; /* Segment alignment */ } Elf32_Phdr; typedef struct { Elf64_Word st_name; /* Symbol name */ unsigned char st_info; /* Symbol type and binding */ unsigned char st_other; /* Symbol visibility */ Elf64_Section st_shndx; /* Section index */ Elf64_Addr st_value; /* Symbol value */ Elf64_Xword st_size; /* Symbol size */ } Elf64_Sym; typedef struct { const char *dli_fname; /* Pathname of shared object that contains address */ void *dli_fbase; /* Base address at which shared object is loaded */ const char *dli_sname; /* Name of symbol whose definition overlaps addr */ void *dli_saddr; /* Exact address of symbol named in dli_sname */ } Dl_info; typedef struct { size_t dls_size; /* Size in bytes of the whole buffer */ unsigned int dls_cnt; /* Number of elements in \u0026#39;dls_serpath\u0026#39; */ Dl_serpath dls_serpath[1]; /* Actually longer, \u0026#39;dls_cnt\u0026#39; elements */ } Dl_serinfo; typedef struct { char *dls_name; /* Name of library search path directory */ unsigned int dls_flags; /* Indicates where this directory came from */ } Dl_serpath; struct link_map { ElfW(Addr) l_addr; /* Difference between the address in the ELF file and the address in memory */ char *l_name; /* Absolute pathname where object was found */ ElfW(Dyn) *l_ld; /* Dynamic section of the shared object */ struct link_map *l_next, *l_prev; /* Chain of loaded objects */ /* Plus additional fields private to the implementation */ }; 1.2 涉及接口 1 2 3 4 5 6 7 8 #include \u0026lt;dlfcn.h\u0026gt; int dl_iterate_phdr(int (*callback)(struct dl_phdr_info *info, size_t size, void *data), void *data); void *dlopen(const char *filename, int flags); void *dlsym(void *restrict handle, const char *restrict symbol); int dlclose(void *handle); int dladdr(const void *addr, Dl_info *info); int dlinfo(void *restrict handle, int request, void *restrict info); char *dlerror(void); ","date":"2024-12-12T16:48:23+08:00","permalink":"http://www.alvincat.top/post/linux/backtrace/","tags":["ELF","backtrace"],"title":"Linux系统中进程打印堆栈的原理"},{"categories":["Linux"],"contents":"本文介绍并发程序中经常遇到的几个经典问题以及解决方法。\n1 Thundering herd problem(惊群效应) 解决方法：\nEvent Multiplexing: Use event-driven programming models (e.g., select, poll, epoll in Linux) that allow a single thread or process to handle multiple events.\nLoad Distribution: Distribute the load more evenly among multiple processes or threads using techniques like load balancers. Load balancing involves distributing incoming requests across multiple servers to prevent any one server from becoming overwhelmed. By distributing the load across multiple servers, the likelihood of a thundering herd problem occurring can be reduced.\nSerialized Access: Implement locking mechanisms or use queueing to serialize access to the shared resource, ensuring that only one process or thread handles the event at a time. Queuing: Queuing involves placing incoming requests in a queue and processing them in a controlled and orderly manner. By queuing requests, the load on the resource can be controlled, and the likelihood of a thundering herd problem occurring can be minimized.\nRate Limiting: Introduce rate limits to control the frequency at which processes or threads are woken up. Throttling involves limiting the rate at which requests are processed. By limiting the rate at which requests are processed, the load on the resource can be controlled, and the likelihood of a thundering herd problem occurring can be minimized.\nConnection pooling: Connection pooling involves reusing existing connections to a resource rather than creating a new connection for each request. By reusing existing connections, the load on the resource can be reduced, and the likelihood of a thundering herd problem occurring can be minimized.\n2 lock problem 2.1 deadlock(死锁) 2.2 livelock(活锁) 活锁产生的背景是：若获取多个锁时，若无法获取全部的锁时，会释放已经持有的锁，防止死锁。\n下面考虑这种场景：\n线程1(t1)需要获取lock1和lock2才能工作。线程2(t2)也需要获取lock1和lock2才能工作。\nt1先拿到lock1,尝试去获取lock2；t2先拿到lock2,尝试获取lock1;如果t1获取lock1和t2获取到lock2是同时发生的，他们在尝试获取另外一个锁时都会失败，然后同时释放自己的锁后重新按照原流程进程尝试。这样就会导致两个线程一直重试而无法继续进行。\n活锁类似于生活中两个有礼貌的人让路的场景：两个人都很客气的让路给对方，但是两人同时移动到同一侧，又继续冲突，再移动回来又冲突，一直这样持续下去，那么就会发生活锁。\n2.3 Starvation(饿死) 2.3 Lock convoy 2.5 Pessimistic Concurrency Control(悲观锁) 悲观锁策略：认为修改读写数据是不安全的，需要在操作数据前加锁，操作完数据后再解锁。也就是传统意义上的加锁动作。\n2.6 Optimistic Concurrency Control(乐观锁) 乐观锁的策略：乐观锁在更新数据前先获暂存数据，然后执行修改数据的操作。\n在将数据写回时，确认数据是否被修改，若数据被修改，就放弃更新的动作。\n乐观锁，一般用在数据冲突比较小的场景。\n2.7 False Sharing(伪共享) 2.4 Non-blocking algorithm 2.4.1 ring buffer FIFO a single-reader single-writer\n2.4.2 disruptor 2.4.2.1 disruptor 的原理介绍 How the Disruptor works and how to use it\ndisruptor的原理中文翻译\n2.4.2.2 disruptor的ringbuffer结构 内部结构为数组实现的环状队列，大小一般设置为$2^n$个，这样可以通过使用\u0026amp;运算替代%运算，加快计算速度。例如对于有8($2^3$)个数据的环状队列。 只需要将数字编号n\u0026amp;7(8-1)即可得访问对应的内容。 其中的数据的编号从0开始，不断增长。随着你不停地填充这个buffer（可能也会有相应的读取），这个序号会一直增长，直到绕过这个环。 2.4.2.3 从ring Buffer中读数据的原理 假设Ring Buffer中已经写入了一些数据，如下图所示，怎样从Ring Buffer读出这些数据呢？ 这里增加几个基本概念：\n消费者(Consumer)：消费者(Consumer)是一个想从Ring Buffer里读取数据的线程。就像Ring Buffer需要一个序号才能找到下一个可用节点一样，消费者也需要知道它将要处理的序号——每个消费者都需要找到下一个它要访问的序号。　ConsumerBarrier对象： ConsumerBarrier是消费者和Ring Buffer沟通的桥梁，用于两者之间的通信。 这个对象由RingBuffer创建并且代表消费者与RingBuffer进行交互。\n消费者可以调用ConsumerBarrier对象的waitFor()方法，传递它所需要的下一个序号.\n1 final long availableSeq = consumerBarrier.waitFor(nextSequence); 在上面的例子中，消费者处理完了Ring Buffer里序号8之前（包括8）的所有数据，那么它期待访问的下一个序号是9。 但是ConsumerBarrier从RingBuffer获取到的最大可访问序号是12。如下图所示： 注意：\n对于这个环状队列，其中的编号要经过对环的大小取余，才是其实际的编号。\n针对该示例，RingBuffer返回的最大可访问序列号是12（实际对应的数组编号是2），而消费者期望访问的编号是9。 所以消费者需要等待数据填充到9以及已有的区域时才可以访问。（实际分析问题是，可以认为只能按照顺时针去访问数据，不能逆时针访问。）\nConsumerBarrier有一个WaitStrategy方法来决定它如何等待这个序号\n接下来怎么做？\n接下来消费者会一直原地停留，等待更多数据被写入Ring Buffer。并且一旦数据写入后消费者会收到通知——节点9，10，11和12 已写入。现在序号12到了，消费者可以让ConsumerBarrier去拿这些序号节点里的数据了。如下图所示：\n2.4.2.4 向ringbuffer中写数据的原理","date":"2024-12-11T16:11:22+08:00","permalink":"http://www.alvincat.top/post/linux/linux_some_typical_problem/","tags":[""],"title":"并发编程中常见的问题"},{"categories":["数据结构"],"contents":"本文描述如何使用C语言实现一个队列的功能，展示如何使用数组、链表结构实现队列的方法。\n1 队列的基本功能 队列的基本功能包括：创建队列、销毁队列、判断队列是否为空、进队列、出队列、获取队列中的元素个数、获取队列头部元素、获取队列尾部元素。\n2 使用单链表实现队列 实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 struct Node { int val; struct Node* next; }; typedef struct Node Node; typedef struct { Node* head; Node* tail; int size; } myQueue; myQueue* initQueue(void) { // init head Node* node = (Node*)malloc(sizeof(Node)); if (!node) { printf(\u0026#34;Init que head node failed, not mem.\\n\u0026#34;); return NULL; } node-\u0026gt;val = -1; node-\u0026gt;next = NULL; // init queue myQueue* queue = (myQueue*)malloc(sizeof(myQueue)); if (!queue) { printf(\u0026#34;Init que failed, not mem.\\n\u0026#34;); return NULL; } queue-\u0026gt;head = node; queue-\u0026gt;tail = node; queue-\u0026gt;size = 0; return queue; } void destroyLinklist(Node* head) { while (head) { Node* next = head-\u0026gt;next; free(head); head = next; } } void destroyQueue(myQueue* que) { if (que) { destroyLinklist(que-\u0026gt;head); que-\u0026gt;size = 0; free(que); } } int isQueueEmpty(myQueue* que) { return que-\u0026gt;size == 0; } int getQueueSize(myQueue* que) { return que-\u0026gt;size; } void pushQueue(myQueue* que, int value) { Node* node = (Node*)malloc(sizeof(Node)); if (!node) { return; } node-\u0026gt;val = value; node-\u0026gt;next = NULL; que-\u0026gt;tail-\u0026gt;next = node; que-\u0026gt;tail = node; ++(que-\u0026gt;size); } void popQueue(myQueue* que) { if (isQueueEmpty(que)) { return; } Node* cur = que-\u0026gt;head-\u0026gt;next; que-\u0026gt;head-\u0026gt;next = cur-\u0026gt;next; if (que-\u0026gt;tail == cur) { que-\u0026gt;tail = que-\u0026gt;head; } free(cur); --(que-\u0026gt;size); } int getQueueFront(myQueue* que) { if (isQueueEmpty(que)) { return -1; } return que-\u0026gt;head-\u0026gt;next-\u0026gt;val; } int getQueueTail(myQueue* que) { if (isQueueEmpty(que)) { return -1; } return que-\u0026gt;tail-\u0026gt;val; } void printQueue(myQueue* que) { Node* head = que-\u0026gt;head-\u0026gt;next; printf(\u0026#34;que:\u0026#34;); while (head != que-\u0026gt;tail) { printf(\u0026#34;[%d|-]-\u0026gt;\u0026#34;, head-\u0026gt;val); head = head-\u0026gt;next; } printf(\u0026#34;[%d|^].\\n\u0026#34;, que-\u0026gt;tail-\u0026gt;val); } void reverseQueue(myQueue* que) { if (isQueueEmpty(que)) { return; } Node* front = que-\u0026gt;head-\u0026gt;next; if (front != que-\u0026gt;tail) { que-\u0026gt;head-\u0026gt;next = front-\u0026gt;next; front-\u0026gt;next = NULL; que-\u0026gt;tail-\u0026gt;next = front; que-\u0026gt;tail = front; } } 3 使用数组实现队列(环形队列) 实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 #define QUE_LEN 100 typedef struct { int arr[QUE_LEN]; int front; int tail; int size; int capacity; } myQueue; myQueue* initQueue(void) { // init queue myQueue* queue = (myQueue*)malloc(sizeof(myQueue)); if (!queue) { printf(\u0026#34;Init que failed, not mem.\\n\u0026#34;); return NULL; } queue-\u0026gt;front = 0; queue-\u0026gt;tail = 0; queue-\u0026gt;size = 0; queue-\u0026gt;capacity = QUE_LEN; return queue; } void destroyQueue(myQueue* que) { if (que) { que-\u0026gt;size = 0; free(que); } } int isQueueEmpty(myQueue* que) { return (que-\u0026gt;size == 0 \u0026amp;\u0026amp; que-\u0026gt;front == que-\u0026gt;tail); } int isQueueFull(myQueue* que) { return (que-\u0026gt;size == que-\u0026gt;capacity \u0026amp;\u0026amp; que-\u0026gt;front == que-\u0026gt;tail); } int getQueueSize(myQueue* que) { return que-\u0026gt;size; } void pushQueue(myQueue* que, int value) { if (isQueueFull(que)) { return; } int capacity = que-\u0026gt;capacity; int tail = que-\u0026gt;tail; que-\u0026gt;arr[tail] = value; que-\u0026gt;tail = (tail + 1) % capacity; ++(que-\u0026gt;size); } void popQueue(myQueue* que) { if (isQueueEmpty(que)) { return; } int front = que-\u0026gt;front; que-\u0026gt;front = (front + 1) % que-\u0026gt;capacity; --(que-\u0026gt;size); } int getQueueFront(myQueue* que) { if (isQueueEmpty(que)) { return -1; } int front = que-\u0026gt;front; return que-\u0026gt;arr[front]; } int getQueueTail(myQueue* que) { if (isQueueEmpty(que)) { return -1; } int tail = (que-\u0026gt;tail + que-\u0026gt;capacity - 1) % que-\u0026gt;capacity; return que-\u0026gt;arr[tail]; } void printQueue(myQueue* que) { if (isQueueEmpty(que)) { printf(\u0026#34;que is empty().\\n\u0026#34;); return; } printf(\u0026#34;queue:\u0026#34;); for (int i = 0; i \u0026lt; que-\u0026gt;size; ++i) { int front = (que-\u0026gt;front + i) % que-\u0026gt;capacity; printf(\u0026#34;|%d\u0026#34;, que-\u0026gt;arr[front]); } printf(\u0026#34;|.\\n\u0026#34;); } void reverseQueue(myQueue* que) { if (isQueueEmpty(que)) { return; } if (isQueueFull(que)) { que-\u0026gt;front = (que-\u0026gt;front + 1) % que-\u0026gt;capacity; que-\u0026gt;tail = (que-\u0026gt;tail + 1)% que-\u0026gt;capacity; return; } int front = getQueueFront(que); popQueue(que); pushQueue(que, front); } ","date":"2024-12-10T10:39:32+08:00","permalink":"http://www.alvincat.top/post/data_structure/queue/implement_a_queue/","tags":["队列","环形队列"],"title":"C语言实现一个队列的功能"},{"categories":["数据结构"],"contents":"本文描述如何使用C语言实现一个栈的功能。\n1 栈的基本功能 栈的基本功能包括：创建栈、销毁栈、判断栈是否为空、进栈、出栈、获取栈中的元素个数、获取栈顶元素。\n2 使用数组实现一个固定大小的栈 实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 #define SIZE 101 typedef struct { int arr[SIZE]; int size; } myStack; myStack* stack_init(void) { myStack* stk = (myStack*)malloc(sizeof(myStack)); if (stk == NULL) { return NULL; } memset(stk, 0, sizeof(myStack)); return stk; } int stack_is_empty(myStack* stk) { return (stk-\u0026gt;size == 0); } int get_stack_size(myStack* stk) { return stk-\u0026gt;size(); } void push_stack(myStack* stk, int val) { int idx = stk-\u0026gt;size; stk-\u0026gt;arr[idx] = val; ++(stk-\u0026gt;size); } void pop_stack(myStack* stk) { if (stack_is_empty(stk)) { return; } --(stk-\u0026gt;size); } int get_stack_top(myStack* stk) { if (stack_is_empty) { return -1; } int idx = stk-\u0026gt;size; return stk-\u0026gt;arr[idx-1]; } void destroy_stack(myStack* stk) { if (stk) { stk-\u0026gt;size = 0; free(stk); stk = NULL; } } ","date":"2024-12-10T10:39:32+08:00","permalink":"http://www.alvincat.top/post/data_structure/stack/implement_a_stack/","tags":["栈"],"title":"C语言实现一个栈的功能"},{"categories":["算法"],"contents":"本文总结动态规划算法的原理和使用场景。\n1 动态规划问题的特征 具有最优子结构 子结构之间存在依赖关系。 是用来求解最优解的问题的，因此符合上面两条，然后存在最大(多/少)等字眼的，可以尝试用动态规划求解。 2 动态规划问题的求解步骤 定义子问题 写出状态转移方程 确定计算顺序(top-down/down-top)：大多数都是采用自底向上的方法。 ","date":"2024-12-08T16:05:29+08:00","permalink":"http://www.alvincat.top/post/algorithm/dynamic_programming/","tags":["动态规划"],"title":"动态规划"},{"categories":["Linux"],"contents":"本文介绍进程间同步的3种方法，分别是文件锁，信号量和互斥量。 并且介绍它们是如何实现进程间同步的。\n1.1 文件锁（记录锁） 文件锁，在APUE中称为记录锁（record locking)，是保证某一时刻只有一个进程修改文件中的一个指定区域的锁。\n1.1.1 fcntl() fcntl()函数原型：int fcntl(int fd, int cmd, struct flock* fllockptr)。\n对于函数fcntl()来说，记录锁是通过cmd来控制的。记录锁的对应的cmd有：F_GETLK，F_SETLK和F_SETLKW。\nflock结构体的定义如下：\n1 2 3 4 5 6 7 struct flock { short l_type; /* F_RDLCK, F_WRLCK, F_UNLCK */ short l_whence; /* SEEK_SET, SEEK_CUR, SEEK_END */ short l_start; /* offset in bytes, relative to l_whence */ short l_len; /* length, in byte, 0 means lock of EOF */ short l_pid; /* returned with F_GETLK */ } flock结构中各个成员的含义说明：\nl_type表示文件锁的类型：F_RDLCK表示共享读锁, F_WRLCK为独占写锁, F_UNLCK为解锁指定文件区域\nl_whence, l_start和lseek()中的whence、offset功能相同；\n1.1.2 文件锁的使用方法 对整个文件加锁的方法：将l_start和l_len都设置为0, l_whece设置为SEEK_SET。\n如果一个进程对一个文件区域已经加了锁，后续如果该进程再次对同一区域再次加锁。则新锁将替换已持有的锁。\n加读锁时，该文件描述符必须是读打开的。加写锁时，该描述符必须是写打开的。\nfcntl函数中，文件锁三种参数的的说明：\nF_GETLK：判断对flockptr指定的文件区域加锁是否可以会被阻塞。\nF_SETLK：尝试获取一把锁，若无法获取锁，则返回错误码EACCES，EAGAIN。\nF_SETLKW：这个命令是F_SETLK的阻塞版本（w表示wait)。锁所设置的文件区域已经加锁而我们又无法获取该锁时，那么当前进程会被阻塞。只有等请求的锁可用或者休眠被信号中断，该进程才会被唤醒。\n1.1.3 文件锁的继承和释放 文件锁和进程、文件关联。以下几种场景都会关闭文件锁。\n进程退出：当一个进程退出时，它所建立的锁全部关闭。 文件关闭：文件描述符关闭，则该文件关联的锁全部关闭。 由fork创建的子进程不继承父进程设置的锁。\n在执行exec后，新程序可以继承原执行程序的锁。但是，如果文件设置了(O_CLOEXEC)。\n1.2 信号量 信号量的使用方法见进程间通信文章中的相关内容。\n1.3 互斥量 使用互斥量在多个进程之间实现同步，需要做如下处理：\n多个进程之间需要使用共享内存。\n互斥量需要在共享内存中中初始化；\n互斥量的属性需要设置为PTHREAD_PROCESS_SHARED。\n进程间使用互斥量的示例如下：\n","date":"2024-12-07T17:59:12+08:00","permalink":"http://www.alvincat.top/post/linux/apue/process_synchronization/","tags":["APUE","进程同步"],"title":"进程同步的方法"},{"categories":["Linux"],"contents":"本文说明UNIX系统中常见的几种标准，以及它们之间的关系。\n1.1 ISO C ISO C是C语言的标准。 ISO C标准现在有ISO/IEC的C程序设计语言国际标准工作组开发和维护。\nISO C标准的目的是提供C程序的可移植性，使其能适合于大量不同的操作系统，而不仅仅是UNIX系统。\n1.2 POSIX POSIX最初是由IEEE指定的标准。该标准的目的是提升应用程序在各种UNIX系统环境之间的可移植性。POSIX标准经过不断演进，发展出很多后续版本。本书统称为POSIX.1。\n1.2.1 XSI POSIX中的XSI(X/Open System Interface)选项描述了POSXI.1中可选接口和定义，以及它们要实现的内容。\n1.3 SUS SUS(Single UNIX Specification)。可以认为POSIX是SUS的子集。它定义了一些附加接口用于扩展POSIX.1规范的功能。POSIX.1相当于SUS中的基本规范。\n1.4 专业术语 ANSI: American National Standards Institute BSD: Berkeley Softwar eDistribution CAE: Common Application Environment COSE: Common Open Software Environment IEC: International Electrotechnical Commission IEEE: Institute of Electrical and Electronics Engineers ISO: International Organization for Standardization OSF: Open Softwar eFoundation POSIX: Portable Operating System Interface SUS: Single UNIX Specification SVID: System V Interface Definition SVR4: UNIX System V Release 4 USL: UNIX System Laboratories XSI: X/Open System Interface ","date":"2024-12-07T17:41:42+08:00","permalink":"http://www.alvincat.top/post/linux/apue/unix_standardization/","tags":["APUE","UNIX标准"],"title":"UNIX标准说明"},{"categories":["算法"],"contents":"本文介绍贪心算法的原理和实际应用，以及解决贪心算法的常见思路。\n1.3 贪心算法的典型应用 1.3.1 找零钱问题 1.3.1 背包问题 1.3.1 0-1背包问题 1.3.2 完全背包问题 1.3.2 Dijkstra’s algorithm 1.3.3 Kruskal’s algorithm 1.3.4 Huffman coding 1.3.5 Prim’s Algorithm","date":"2024-12-06T09:48:43+08:00","permalink":"http://www.alvincat.top/post/algorithm/greedy_algorithm/","tags":["贪心算法"],"title":"贪心算法"},{"categories":["Linux"],"contents":"本文总结UNIX环境中一个进程是如何启动和终止的，如何向进程传递参数表和环境变量。\n还介绍了进程内部的存储空间布局方式。\n1.1 main函数 1.2 进程退出的方式 1.3 C程序的内存空间布局 UNIX系统中C程序的内存布局如下图所示:\n程序中各部分的内容说明如下：\n正文段(Text Segment): 该部分包含了CPU执行的机器指令。通常这个段的内容是可共享、在内存中频繁被执行的单副本程序。通常正文段是只读的，以防止被修改。 已初始化数据段(Initialized Data Segment): 它包含了程序中已明确初始化的变量。例如，明确初始化的全局变量。 未初始化数据段(Uninitialized Data segment): 通常称为bss(block started by symbol)段。在程序开始执行前，内核将此段中的变量数据初始化为0或者空指针。例如，未初始化的全局变量。 栈(stack): 存放函数中的临时变量，函数的参数以及函数返回地址等。 堆(heap): 动态分配的内存存放在堆区。堆区在未初始化数据段的上方。 只有正文段和已初始化的数据段是存放在磁盘中。\n通过size命令可以查看二进制各个区域占用的大小。例如查看bash二进制的各个区域大小：size /usr/bin/bash\n1.4 存储空间分配 1.5 共享库","date":"2024-12-05T22:37:40+08:00","permalink":"http://www.alvincat.top/post/linux/apue/process_environment/","tags":["APUE","存储空间布局","环境变量"],"title":"进程环境"},{"categories":["Linux"],"contents":"本文总结Linux环境中的信号相关知识以及和信号相关的接口的使用方法。\n1.1 信号的基本概念 信号是软中断的一种，是典型的异步事件处理机制之一。因为产生信号的时间时随机出现的，没有任何规律。\n当某个信号出现时，可以告诉内核按照如下3种方式处理，称为信号处理：\n忽略信号\n大多数信号可以采用这种方式。但是SIGKILL(9)和SIGSTOP(19)这两个信号不能忽略。\n捕捉信号 为了捕捉信号，需要通知内核在某种信号发生时，调用一个用户函数。在用户函数中，用户事先定制了该信号发生时要执行的操作。\n执行系统的默认动作\n操作系统为每种信号设置默认的操作。但是大多数信号的系统默认操作都是终止进程。\n1.2 异步信号安全函数(可重入) 不可重入函数的特征：\n使用了静态数据结构的函数 调用malloc()或free()的函数 标准IO函数 1.2.1 Linux系统异步信号安全函数 abort faccessat linkat select socketpair accept fchmod listen sem_post stat access fchmodat lseek send symlink aio_error fchown lstat sendmsg symlinkat aio_return fchownat mkdir sendto tcdrain aio_suspend fcntl mkdirat setgid tcflow alarm fdatasync mkfifo setpgid tcflush bind fexecve mkfifoat setsid tcgetattr cfgetispeed fork mknod setsockopt tcgetpgrp cfgetospeed fstat mknodat setuid tcsendbreak cfsetispeed fstatat open shutdown tcsetattr cfsetospeed fsync openat sigaction tcsetpgrp chdir ftruncate pause sigaddset time chmod futimens pipe sigdelset timer_getoverrun chown getegid poll sigemptyset timer_gettime clock_gettime geteuid posix_trace_event sigfillset timer_settime close getgid pselect sigismember times connect getgroups raise signal umask creat getpeername read sigpause uname dup getpgrp readlink sigpending unlink dup2 getpid readlinkat sigprocmask unlinkat execl getppid recv sigqueue utime execle getsockname recvfrom sigset utimensat execv getsockopt recvmsg sigsuspend utimes execve getuid rename sleep wait _Exit kill renameat sockatmark waitpid _exit link rmdir socket write 1.3 信号相关函数 1.4 自定义信号处理函数","date":"2024-12-05T21:58:39+08:00","permalink":"http://www.alvincat.top/post/linux/apue/signals/","tags":["APUE","信号"],"title":"信号"},{"categories":["Linux"],"contents":"本文总结内存映射相关接口的用法和注意事项。\n1.1 内存映射IO的实现方法 内存映射IO(memory-mapped I/O)将一个磁盘中的文件映射到内存的一个缓冲区中，从而可以通过操作内存中的缓冲区达到操作文件的目的。例如读取映射在内存中的缓冲区，就等同于读取对应的磁盘文件。\n1.1.1 内存映射IO的优缺点 优点：\n读写文件直接编程操作缓冲区，更加简单； 对于两个文件之间的读写操作而言，直接进行文件读写操作的话，read需要先将内核缓冲区中的内容读到应用缓冲区(read_buffer),然后write再将应用缓冲区(write_buffer)的数据拷贝到内核缓冲区。若使用内存映射IO，则直接将数据从内核的一个缓冲区拷贝到另外一个缓冲区即可,开销很小(开销来自于可能发生缺页中断)。 1.2 内存映射IO相关的接口 1.2.1 内存映射IO相关的函数声明 1 2 3 4 5 #include \u0026lt;sys/mman.h\u0026gt; void* mmap(void* addr, size_t length, int prot, int flag, int fd, off_t offset); int mprotect(void *addr, size_t len, int prot); int msync(void *addr, size_t length, int flags); int munmap(void *addr, size_t length); 1.2.2 mmap函数 mmap函数参数说明：\naddr参数用于指定映射内存区的起始地址。通常设置为NULL，表示由系统选择该映射区的首地址。 length参数用于指定要映射的内存区域的长度。length必须是虚拟内存页面的整数倍。 prot用于指定内存映射区域的保护方式： PROT_READ：映射区可读 PROT_WRITE：映射区可写 PROT_EXEC：映射区可执行 PROT_NONE：映射区不可访问 prot可以设置为PROT_NONE，也可以设置为PROT_READ,PROT_WRITE, PROT_EXEC一个或者多个组合按位或。 对指定内存映射区的保护不能超过被映射文件打开时的访问权限。例如文件是只读打开的，那么对映射内存区就不能指定PROT_WRITE属性。 当prot设置为PROT_NONE时：这块映射的缓冲区不可读写，读写时会触发SIGSEGV。 用于实现对特定区域的保护，例如可以检测内存越界。典型应用：pthread_attr_setguardsize/pthread_attr_getguardsize. prot的属性PROT_EXEC的作用是：将内存映射区域的内容当作CPU可以执行的的机器指令进行执行。 flag参数：用于设置映射区域的属性。\nMAP_SHARED：该属性表示共享当前映射的内存区。映射区域的更新对其它映射了同一文件区域的进程可见。更新映射区域就会更新对应的映射文件。 MAP_PRIVATE: 该属性表示创建一个私有的映射副本。映射区域的更新对其它映射了同一文件区域的进程不可见。更新映射区域也不会更新对应的映射文件。任何修改都只影响映射文件的副本，而不影响源文件。 必须指定MAP_SHARED或者MAP_PRIVATE其中的一个，但是不能同时指定。 fd参数：指定要被映射的文件描述符。注意，在进行文件映射之前，文件必须先打开。但是关闭文件描述符并不会解除映射区。\noffset参数：offset为被映射的文件中偏移，offset必须是虚拟内存页面的整数倍。虚拟内存页面的大小通过sysconf(_SC_PAGE_SIZE)获取。\n若offset或者length不是内存页面大小的整数倍，操作系统如何处理？例如文件长度96字节，系统页面大小4096字节，则系统会提供4096字节的内存映射区，其中4000字节会被设置为0。虽然可以在映射区中修改4000字节区域，但是修改不会影响到被映射的文件。 1.2.3 mprotect()函数 函数参数说明：\naddr必须是内存页面的整数倍。 mprotect()函数用于修改调用它的进程的访问指定页面中数据的访问权限。如果调用mprotect()函数的进程尝试违反设置的保护方式访问指定的内存区域，则操作系统会给进程返回一个SIGSEGV。利用这特性，我们可以用来定位踩内存问题。 可以通过mprotect()函数来修改内存映射区的保护属性。prot参数和mmap中的参数相同。 1.2.4 msync()函数 函数参数和功能说明：\naddr必须是内存页面的整数倍。 flags参数说明： MS_ASYNC: 函数执行更新操作后立刻返回。 MS_SYNC: 函数需要等待写操作完成才返回。函数必须指定M_ASYNC或M_SYNC中的一个。 MS_INVALIDATE: msync()函数的用途说明：\n如果是用MAP_SHARED标识进行的内存映射，当映射区更新后，修改并不会立刻写会到被映射文件中。而何时将修改的脏页写会磁盘取决于操作系统内核的策略。 脏页写回的策略是：只要某个页面有一个字节被修改，整个页面都会被写回。 如果内存映射区被修改，可以调用msync()函数将脏页下刷到被映射的文件中。 1.2.5 munmap()函数 函数功能说明： munmap()用于解除内存和文件的映射关系。\n相关特性说明：\n当进程退出时会自动解除内存映射。 关闭内存映射时的文件描述符并不能解除和文件的内存映射关系。 调用munmap()函数并不会将内存映射区的内容更新到被映射的文件呢中。 当内存映射区解除映射后，映射时设置为MAP_PRIVATE的内存区的修改会被丢弃。 1.2.6 映射区的一些特性 与映射区相关的信号\nSIGSEGV：信号SIGSEGV通常在进程访问到它不可用的内存区时产生。例如映射区被设置为只读时，进程若尝试修改这个映射区是就会触发SIGSEGV。或者试图访问设置了PROT_NONE的映射区域。\nSIGBUS：如果映射区的某部分在访问时不存在，会触发SIGBUS信号。\n子进程可以通过fork基础父进程的内存映射区。但是不能通过exec继承映射区。\n1.3 内存映射IO的使用示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;sys/mman.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #define COPYINCR (4*1024) int main(int argc, char** argv) { int fdin; int fdout; void* src; void* dst; size_t copysz; struct stat sbuf; off_t fsz = 0; if (argc != 3) { printf(\u0026#34;input argv invalid(%d).\\n\u0026#34;, argc); exit(1); } if ((fdin = open(argv[1], O_RDONLY)) \u0026lt; 0) { printf(\u0026#34;open file(%s) failed, errno(%d).\\n\u0026#34;, argv[1], errno); exit(1); } if (fstat(fdin, \u0026amp;sbuf) \u0026lt; 0) { printf(\u0026#34;get file(%s) stat failed, errno(%d).\\n\u0026#34;, argv[1], errno); exit(1); } if ((fdout = open(argv[2], O_CREAT | O_RDWR | O_TRUNC)) \u0026lt; 0) { printf(\u0026#34;open file(%s) failed, errno(%d).\\n\u0026#34;, argv[2], errno); exit(1); } if (ftruncate(fdout, sbuf.st_size) \u0026lt; 0) { printf(\u0026#34;change file(%s) size failed, errno(%d).\\n\u0026#34;, argv[2], errno); exit(1); } while (fsz \u0026lt; sbuf.st_size) { if (sbuf.st_size - fsz \u0026gt; COPYINCR) { copysz = COPYINCR; } else { copysz = sbuf.st_size - fsz; } src = mmap(NULL, copysz, PROT_READ, MAP_PRIVATE, fdin, fsz); if (src == MAP_FAILED) { printf(\u0026#34;mmap file(%s) offset(%ld)len(%ld) size failed, errno(%d).\\n\u0026#34;, argv[1], fsz, copysz, errno); exit(1); } dst = mmap(NULL, copysz, PROT_WRITE, MAP_SHARED, fdout, fsz); if (src == MAP_FAILED) { printf(\u0026#34;mmap file(%s) offset(%ld)len(%ld) size failed, errno(%d).\\n\u0026#34;, argv[2], fsz, copysz, errno); exit(1); } memcpy(dst, src, copysz); munmap(src, copysz); munmap(dst, copysz); fsz += copysz; } return 0; } ","date":"2024-12-05T11:39:06+08:00","permalink":"http://www.alvincat.top/post/linux/apue/memory_mapped_io/","tags":["APUE","内存映射"],"title":"内存映射IO"},{"categories":["Linux"],"contents":"本文总结进程间通信的方法和各种方法的差异，以及注意事项。\n1 Linux支持的进程间通信方式 IPC类型 进程关系 半双工管道(匿名) 主机内的进程 FIFO(命名管道) 主机内的进程 消息队列 主机内的进程 信号量 主机内的进程 共享内存 主机内的进程 socket(套接字) 主机内或者主机间的进程 2 管道 3 FIFO 4 消息队列 5 共享内存 共享内存和内存映射IO的不同之处在于，共享内存不需要关联文件，使用的是虚拟内存中的匿名段。\n体现在用法上，就是共享内存不需要关联文件，通过shm_open()创建一个共享内存(虚拟的文件)，所有的进程就可以使用mmap来进行共享了。\n5.1 XSI共享内存 XSI共享内存相关接口：\n1 2 3 4 5 6 7 8 9 10 11 12 #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;sys/ipc.h\u0026gt; #include \u0026lt;sys/shm.h\u0026gt; key_t ftok(const char *pathname, int proj_id); int shmget(key_t key, size_t size, int shmflg); // get or create a shared memory int shmctl(int shmid, int cmd, struct shmid_ds *buf); void *shmat(int shmid, const void *shmaddr, int shmflg); // attach shared memory int shmdt(const void *shmaddr); void *shmat(int shmid, const void *shmaddr, int shmflg); // detach shard memory int shmdt(const void *shmaddr); XSI共享内存的用法见APUE第三版的15.9节。\n5.2 POSIX共享内存 POSIX共享内存接口最早出现在Linux kernel 2.4和glibc 2.2版本。通过man 7 shm_overview可以查看详细说明。POSIX共享内存接口使用更方便，通用性更强。\nPOSIX共享内存相关接口：\n1 2 3 4 5 6 7 8 9 10 11 12 #include \u0026lt;sys/mman.h\u0026gt; int shm_open(const char *name, int oflag, mode_t mode); int shm_unlink(const char *name); void* mmap(void* addr, size_t length, int prot, int flag, int fd, off_t offset); int munmap(void *addr, size_t length); // Set the size of the shared memory object. (A newly created shared memory object has a length of zero.) int ftruncate(int fd, off_t length); // Close the file descriptor allocated by shm_open(3) when it is no longer needed. int close(int fd); 链接时需要增加链接选项-lrt。\nshm_open()：shm_open接口和open接口作用类似。只不过shm_open是为了创建一个用于共享内存的文件而已。因此shm_open()创建的文件描述符同样用close()关闭。\nname：为了具有更好的可移植性，最好将name命名为以/开头的字符串。除了开头的/外不包含其他字符串。而name的长度也要符合当前系统的文件名长度的要求。\noflag：为了确保创建一个新的共享内存，可以将oflag参数设置为O_CREAT | O_EXEL。这样当name已经存在时，就会返回错误，保证只有不存在才会创建。\nshm_unlink()：shm_unlink()删除shm_open创建的共享内存。\n而要实现不同的进程共同使用同一片共享内存，只需要其中约定某个进程创建一个共享内存，然后将该共享内存的名字提供出来。其他进程就可以使用mmap来使用这个共享内存了。\n6 信号量 6.1 XSI信号量 SUS提供的信号量机制，提供了相当全面的功能。但是和POSIX信号量相比，使用更加复杂，而且性能也不如POSIX信号量。\n因此linux环境中一般使用POSIX信号量。感兴趣的可以阅读APUE第三版15.8节了解它的使用细节。\nXSI 信号量相关接口：\n1 2 3 4 #include \u0026lt;sys/sem.h\u0026gt; int semget(key_t key, int nsems, int semflg); int semctl(int semid, int semnum, int cmd, ...); int semop(int semid, struct sembuf *sops, size_t nsops); 6.2 POSIX信号量 信号量相关接口：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;semaphore.h\u0026gt; typedef union { char __size[__SIZEOF_SEM_T]; long int __align; } sem_t; int sem_init(sem_t *sem, int pshared, unsigned int value); int sem_destroy(sem_t *sem); sem_t *sem_open(const char *name, int oflag); sem_t *sem_open(const char *name, int oflag, mode_t mode, unsigned int value); int sem_unlink(const char *name); int sem_close(sem_t *sem); int sem_wait(sem_t *sem); int sem_trywait(sem_t *sem); int sem_timedwait(sem_t *sem, const struct timespec *abs_timeout); int sem_post(sem_t *sem); int sem_getvalue(sem_t *sem, int *sval); // POSIX信号量有两种：匿名型号量和命名信号量。它们的除了创建和销毁方式不同，其它没什么区别。\n匿名信号量只存在于内存中，只有可以访问对应内存的进程才可以使用。这意味着只有同一个进程中的线程可以使用或者已经映射相同内存内容到它们的地址空间的不同进程中的线程。 命名信号量可以通过名字访问，因此知道它们的名字的进程都可以使用。 6.2.1 信号量通用接口 sem_wait()：该函数用来实现信号量的减1操作。也可以理解为申请1个资源。调用该函数时，若信号量为0就会被阻塞。直到成功将信号量减1或者被一个信号中断。\nsem_try_wait()：该函数功能和sem_wait相同，都是用来对信号减1的。但是该函数在遇到信号量为0时不会被阻塞，而是返回-1并且将errno设置为EAGAIN。\nsem_timedwait()：该函数也是用于对信号量进行减1操作的。不同之处在于，它可以设置一个超时时间，当遇到信号量为0时，等待一个指定时间后仍然未能对信号量减1，就返回-1并将errno设置为ETIMEDOUT。\nsem_post()：该函数用来实现信号量的加1操作。也可以理解为释放1个资源。在调用sem_post()时，存在被信号量阻塞的进程，那么被阻塞的线程会被唤醒。而且被sem_post()加1的信号量会再次被sem_wait()或者sem_timedwait()函数减1。\nsem_getvalue()：获取当前信号量的值。该函数的操作不是原子的，即该函数返回是这个值可能已经改变，若需要获取准确的值，需要自行保证获取value的原子性。\n6.2.2 匿名信号量 如果信号量只在某个进程内部使用，使用匿名信号量更方便。\nsem_init()：创建匿名信号量。\nsem：sem用于保存新创建的匿名信号量的地址，需要事先定义好。\n若只在进程内部使用，需要对使用该信号量的线程均可见。例如全局变量或者在堆内存中申请内存的变量。\n若需要在两个进程之间使用，则变量需要在两个进程共享内存区域中。\npshared：pshared参数用于指定当前信号量的共享方式。若只在进程内使用，则将值设置为0；若在进程间使用，将值设置为非0值，例如1。\nvalue：value用于设置信号量的初始值。\nsem_destroy()：销毁匿名信号量。调用sem_destroy()后，不能再使用任何带有sem的函数了。\n6.2.3 命名信号量 sem_open()：sem_open()可以用来创建一个新的命名信号量或者使用一个已经存在的命名信号量。\n创建一个新的信号量的方法：如果要确保创建一个新的信号量，可以将oflag设置为O_CREAT|O_EXCL。当指定name的信号量已经存在时，会返回sem_open失败。\n使用已经存在的信号量的方法：使用只包含name和flag参数的sem_open函数，而且oflag设置为0。\nname：name参数用于指定信号量的名字。为了增加可移植性，建议名字以/开头。而且除了开头的/外，不能有其他的/存在。信号量的名字有最大长度限制，其长度不应该超过_POSIX_NAME_MAX。\noflag：oflag用于控制创建信号量的行为，参见前面两条说明。\nmode：mode为创建的信号量的文件访问权限，同open()函数的mode。\nvalue：value为创建的信号量的初始值。\n返回值：sem_open()函数的返回值为sem_t类型的指针，作为只用这个变量对该信号量执行其他操作。\nsem_close()：sem_close()用于释放进程申请的所有和该命名信号量相关的资源。\n如果进程在退出前，没有主动关闭命名信号量，那么内核会自动关闭该进程打开所有信号量。\n命名信号量关闭后，不会影响信号量的值。进程退出后由内核自动关闭的信号量也是一样的。\nsem_unlink()：sem_unlink()删除命名信号量的名字。调用该函数后信号量的名字会被立刻删除。但是只有当所有的信号量的使用者均关闭了该信号量，信号量才会被销毁。\n6.2.3 二进制信号量 二值信号量和计数信号量的差异在于初始化和使用信号量。如果信号量的值只有0和1，那它就是二值信号量。\n当二值信号量为1时，表示它处于\u0026quot;解锁状态\u0026quot;；当信号量的值为\u0026quot;0\u0026quot;时，表示他处于”加锁“状态。\n7 sockek socket相关的内容比较多，单独作为一篇文章介绍。\n","date":"2024-12-05T11:37:06+08:00","permalink":"http://www.alvincat.top/post/linux/apue/interprocess_communication/","tags":["APUE","IPC","进程间通信"],"title":"进程间通信的方法"},{"categories":["Linux"],"contents":"本文总结多线程的特性和同步方法。\n多线程 多线程的复杂性来源：\nCPU任务可抢占 多核并发 线程让渡 1 线程数据 1.1 线程私有数据 线程有如下私有数据：\n线程ID，线程ID在进程内部唯一。 一组寄存器 栈 调度优先级和调度策略 信号屏蔽字 errno变量 线程私有数据 1.2 线程共享数据 一个进程中的所有信息对该进程中的所有线程都是共享的。包含如下信息：\n可执行程序的代码\n程序的全局变量\n堆内存\n栈\n文件描述符\n1 线程同步方法 原子操作相关的接口由GCC自身提供，使用时无需包含其他头文件。pthread相关接口由glibc提供，使用时需要包含pthread.h头文件。\n1.1 原子操作 原子操作主要用于对整数进行简单的取值、加减、交换操作。由GCC提供的原子操作：\nn++类 1 2 3 4 5 6 7 8 type __sync_fetch_and_add(type *ptr, type value, ...); // m+n type __sync_fetch_and_sub(type *ptr, type value, ...); // m-n type __sync_fetch_and_or(type *ptr, type value, ...); // m|n type __sync_fetch_and_and(type *ptr, type value, ...); // m\u0026amp;n type __sync_fetch_and_xor(type *ptr, type value, ...); // m^n type __sync_fetch_and_nand(type *ptr, type value, ...); // (~m)\u0026amp;n /* 对应的伪代码 */ { tmp = *ptr; *ptr op= value; return tmp; }{ tmp = *ptr; *ptr = (~tmp) \u0026amp; value; return tmp; } // nand ++n类 1 2 3 4 5 6 7 8 type __sync_add_and_fetch(type *ptr, type value, ...); // m+n type __sync_sub_and_fetch(type *ptr, type value, ...); // m-n type __sync_or_and_fetch(type *ptr, type value, ...); // m|n type __sync_and_and_fetch(type *ptr, type value, ...); // m\u0026amp;n type __sync_xor_and_fetch(type *ptr, type value, ...); // m^n type __sync_nand_and_fetch(type *ptr, type value, ...); // (~m)\u0026amp;n /* 对应的伪代码 */ { *ptr op= value; return *ptr; }{ *ptr = (~*ptr) \u0026amp; value; return *ptr; } // nand 3.CAS类\n1 2 3 4 bool __sync_bool_compare_and_swap (type *ptr, type oldval, type newval, ...); type __sync_val_compare_and_swap (type *ptr, type oldval, type newval, ...); /* 对应的伪代码 */ { if (*ptr == oldval) { *ptr = newval; return true; } else { return false; } }{ if (*ptr == oldval) { *ptr = newval; } return oldval; } 1.2 自旋锁(spinklock) 自旋锁使用场景：执行时间短的任务。\n等待自旋锁的过程中，不会让渡CPU资源，盲等。\n1.2.1 pthread自旋锁接口 1 2 3 4 5 6 #include \u0026lt;pthread.h\u0026gt; int pthread_spin_init(pthread_spinlock_t* lock, int pshared); // init spink lock int pthread_spin_destroy(pthread_spinlock_t* lock); // destroy spin lock int pthread_spin_lock(pthread_spinlock_t* lock); int pthread_spin_unlock(pthread_spinlock_t* lock); int pthread_spin_trylock(pthread_spinlock_t* lock); 1.2.2 pthread_spin_lock实现 以x86系统为例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 int pthread_spin_lock ( pthread_spinlock_t *lock) { asm (\u0026#34;\\n\u0026#34; \u0026#34;1:\\t\u0026#34; LOCK_PREFIX \u0026#34;decl %0\\n\\t\u0026#34; \u0026#34;jne 2f\\n\\t\u0026#34; \u0026#34;.subsection 1\\n\\t\u0026#34; \u0026#34;.align 16\\n\u0026#34; \u0026#34;2:\\trep; nop\\n\\t\u0026#34; \u0026#34;cmpl $0, %0\\n\\t\u0026#34; \u0026#34;jg 1b\\n\\t\u0026#34; \u0026#34;jmp 2b\\n\\t\u0026#34; \u0026#34;.previous\u0026#34; : \u0026#34;=m\u0026#34; (*lock) : \u0026#34;m\u0026#34; (*lock)); return 0; } 1.2.2 pthread_spin_unlock实现 1 2 3 4 5 6 7 8 9 10 11 12 13 .globl pthread_spin_unlock .type pthread_spin_unlock,@function .align 16 pthread_spin_unlock: movl 4(%esp), %eax movl $1, (%eax) xorl %eax, %eax ret .size pthread_spin_unlock,.-pthread_spin_unlock /* The implementation of pthread_spin_init is identical. */ .globl pthread_spin_init pthread_spin_init = pthread_spin_unlock 1.3 互斥量(mutex) 对互斥量进行加锁以后，任何其它试图再次对互斥量加锁的线程都会被阻塞，直到当前你线程释放该互斥锁。如果释放互斥锁时有一个以上的线程阻塞，那么所有阻塞在该互斥量上的线程都会变为可运行状态。但是只有第一个可运行状态的线程可以获取互斥锁而得以继续运行，其他线程仍然需要继续等待。\n1.3.1 pthread mutex接口 1 2 3 4 5 6 7 8 9 10 // pthread_mutex_t结构定义： // nptl\\sysdeps\\unix\\sysv\\linux\\x86_64\\bits\\pthreadtypes.h #include \u0026lt;pthread.h\u0026gt; int pthread_mutex_init(pthread_mutex_t* mutex, const pthread_mutexattr_t* attr); int pthread_mutex_destroy(pthread_mutex_t* mutex); int pthread_mutex_lock(pthread_mutex_t* mutex); int pthread_mutex_trylock(pthread_mutex_t* mutex); int phtread_mutex_unlock(pthread_mutex_t* mutex); 1.3.2 pthread_mutex结构 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // x86_64结构 typedef union { struct __pthread_mutex_s { int __lock; unsigned int __count; int __owner; unsigned int __nusers; int __kind; int __spins; __pthread_list_t __list; # define __PTHREAD_MUTEX_HAVE_PREV 1 } __data; char __size[__SIZEOF_PTHREAD_MUTEX_T]; long int __align; } pthread_mutex_t; 1.4 读写锁(rw_lock) 1.4.1 读写锁特性 读写锁可以有3种状态：读模式下加锁状态，写模式下加锁状态和不加锁状态。一次只有一个线程可以占有写模式的读写锁，但是多个线程可以同时占有读模式的读写锁。\n当读写锁是写加锁状态时，在这个锁被解锁前，所有试图对这个锁加锁的线程都会被阻塞。当读写锁在读加锁状态时，所有试图以读模式对它进行加锁的线程都可以的到访问权。但是任何希望以写模式对此锁进行加锁的线程都会阻塞，直到所有的线程释放它们的读锁为止。该模式为读锁优先模式，存在申请写锁的线程饥饿问题。\n优化方案：当读写锁处于读模式锁住的状态，而这时有一个线程试图以写模式获取锁时，读写锁通常会阻塞随后的读模式锁请求。这样可以避免读模式锁长期占用，写模式锁一直等待的问题。\n1.4.2 读写锁接口 1 2 3 4 5 6 7 8 #include \u0026lt;pthread.h\u0026gt; int pthread_rwlock_init(phread_rwlock_t* rwlock, pthread_rwlockattr_t* attr); //init int pthread_rwlock_destroy(pthread_rwlok_t* rwlock); // destroy int pthread_rwlock_rdlock(pthread_rwlock_t* rwlock); // set read lock int pthread_rwlock_wrlock(pthread_rwlock_t* rwlock); // set write lock int pthread_rwlock_unlock(pthread_rwlock_t* unlock); // unlock read/write lock 1.5 条件变量(condition variable) 1.5.1 条件变量相关接口 1 2 3 4 5 6 7 8 9 10 int pthread_cond_init(pthread_cond_t* cond, const pthread_condattr_t* attr); int pthread_cond_destroy(pthread_cond_t* cond); int pthread_cond_wait(pthread_cond_t* cond, pthread_mutex_t* mutex); int pthread_cond_timedwait(pthread_cond_t* cond, pthread_mutex_t* mutex, const struct timespec* tsptr); int pthread_cond_signal(pthread_cond_t* cond); int pthread_cond_broadcast(pthread_cond_t* cond); 1.5.2 条件变量实例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 1 #include \u0026lt;stdio.h\u0026gt; 2 #include \u0026lt;unistd.h\u0026gt; 3 #include \u0026lt;pthread.h\u0026gt; 4 #include \u0026lt;errno.h\u0026gt; 5 6 int done = 0; 7 pthread_mutex_t m_lock = PTHREAD_MUTEX_INITIALIZER; 8 pthread_cond_t c_lock = PTHREAD_COND_INITIALIZER; 9 10 void thread_join(void) 11 { 12 pthread_mutex_lock(\u0026amp;m_lock); 13 while (done == 0) { 14 pthread_cond_wait(\u0026amp;c_lock, \u0026amp;m_lock); 15 } 16 pthread_mutex_unlock(\u0026amp;m_lock); 17 } 18 19 void thread_exit(void) 20 { 21 pthread_mutex_lock(\u0026amp;m_lock); 22 done = 1; 23 printf(\u0026#34;thread end.\\n\u0026#34;); 24 pthread_cond_signal(\u0026amp;c_lock); 25 pthread_mutex_unlock(\u0026amp;m_lock); 26 } 28 void* t_func(void* arg) 29 { 30 printf(\u0026#34;thread is start.\\n\u0026#34;); 31 thread_exit(); 32 return NULL; 33 } 34 35 int main(void) 36 { 37 printf(\u0026#34;parent start.\\n\u0026#34;); 38 pthread_t tid; 39 int ret = pthread_create(\u0026amp;tid, NULL, t_func, NULL); 40 if (ret != 0) { 41 printf(\u0026#34;create pthread failed, errno(%d).\\n\u0026#34;, errno); 42 } 43 thread_join(); 44 45 printf(\u0026#34;parent end.\\n\u0026#34;); 46 return 0; 47 } 1.6 二进制信号量 二进制信号量也可以用来实现互斥。二进制信号量的作用类似于互斥锁。详细使用方法见进程通信文章中的信号量部分。\n2 死锁 2.1 死锁的产生 2.2 死锁检测 2.2 常见死锁 3 线程安全函数 如果一个函数在相同的时间点可以被多个线程安全的调用，则称该函数是线程安全的。\n如果一个函数对多个线程来说是可重入的，就说这个函数是线程安全的。\n最典型的场景是：使用了静态变量的函数就是线程不安全的函数。因为多个线程调用时，都可以修改该静态变量。\n解决方法是： 将静态变量替换为调用者传入，各个线程自己管理自己的变量。\n","date":"2024-12-05T11:29:06+08:00","permalink":"http://www.alvincat.top/post/linux/apue/thread_synchronization/","tags":["APUE","多线程","线程同步"],"title":"多线程的特性和同步方法"},{"categories":["算法"],"contents":"本文讲解回溯算法的原理和具体实现。\n1 回溯算法 1.1 回溯算法的原理 回溯算法是暴力搜索法中的一种。回溯法是一种可以找出所有（或一部分）解的一般性算法，尤其适用于约束满足问题。\n在实际实现时采用DFS搜索的方式进行遍历，然后再遍历过程中采用剪枝的策略去掉不满足条件的解。\n对于具体代码实现而言，实际上就是DFS的一种实际应用。 和DFS遍历二叉树不同之处在于，回溯中使用DFS需要有前进和回退的过程，这也是为啥叫做回溯的原因。 一般在回溯算法中，使用递归的方式来进行DFS。\n1.2 解决回溯问题思路 解决回溯问题时，一定要画出遍历路径的多叉树。搞清楚横向遍历的是什么，和纵向遍历的路径是啥？ 例如： 如下图所示，为leetcode 电话号码组合问题中\u0026quot;23\u0026quot;的遍历示意图。其中2对应字符串\u0026quot;abc\u0026quot;, 3对应字符串\u0026quot;def\u0026quot;。\n我们可以看到，横向展开的是每个字符串内的每个字母，纵向是展开的字符串\u0026quot;23\u0026quot;。\n而回溯的递归函数中的for循环内部实现，就是横向展开的体现。\n因此在这个问题中，需要先根据索引获取数字对应的字符串。\n而针对问题39-组合总和问题，可以按照下图所示的思路去分析解决：\n1.1.1 回溯代码的基本框架 1 2 3 4 5 6 7 8 9 10 path = [] def backtrack(path, 选择列表): if 满足结束条件: result.add(item) return for item in 选择列表: path.push(item) // 添加 backtrack(path, 选择列表) path.pop() // 删除 1.2 回溯算法的应用 1.2.1 排列组合问题 问题1: 全排列 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; permute(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int len = nums.size(); if (len == 0) { return res; } vector\u0026lt;int\u0026gt; path; vector\u0026lt;bool\u0026gt; used(len, false); dfs(nums, path, 0, used); return res; } void dfs(vector\u0026lt;int\u0026gt;\u0026amp; nums, vector\u0026lt;int\u0026gt; path, int depth, vector\u0026lt;bool\u0026gt;\u0026amp; used) { int len = nums.size(); if (len == depth) { res.push_back(path); return; } for (int i = 0; i \u0026lt; len; ++i) { if (!used[i]) { path.push_back(nums[i]); used[i] = 1; dfs(nums, path, depth + 1, used); used[i] = 0; path.pop_back(); } } } private: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res; }; 问题2：电话号码的字母组合 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public: vector\u0026lt;string\u0026gt; letterCombinations(string digits) { int len = digits.size(); if (len == 0) { return {}; } string path; backtrack(digits, 0, path); return res; } void backtrack(string digits, int index, string\u0026amp; path) { if (index == digits.size()) { res.push_back(path); return; } char ch = digits[index]; string str = num_map[ch - \u0026#39;0\u0026#39;]; for (int i = 0; i \u0026lt; str.size(); ++i) { path.push_back(str[i]); backtrack(digits, index + 1, path); path.pop_back(); } } private: string num_map[10] = {\u0026#34;\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;abc\u0026#34;, \u0026#34;def\u0026#34;, \u0026#34;ghi\u0026#34;, \u0026#34;jkl\u0026#34;, \u0026#34;mno\u0026#34;, \u0026#34;pqrs\u0026#34;, \u0026#34;tuv\u0026#34;, \u0026#34;wxyz\u0026#34;}; vector\u0026lt;string\u0026gt; res; }; 问题3：组合总和(39) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; combinationSum(vector\u0026lt;int\u0026gt;\u0026amp; candidates, int target) { int size = candidates.size(); if (candidates.size() == 0) { return {}; } sort(candidates.begin(), candidates.end()); vector\u0026lt;int\u0026gt; path; backtrack(candidates, 0, path, target); return res; } void backtrack(vector\u0026lt;int\u0026gt;\u0026amp; cand, int idx, vector\u0026lt;int\u0026gt;\u0026amp; path, int target) { if (target == 0) { res.push_back(path); return; } for (int i = idx; i \u0026lt; cand.size(); ++i) { if (target \u0026lt; cand[i]) { return; } path.push_back(cand[i]); backtrack(cand, i, path, target - cand[i]); path.pop_back(); } } private: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res; }; 1.2.2 N皇后问题 1.3 Leetcode相关题目 17 Letter Combinations of a Phone Number\n22 Generate Parentheses\n39 Combination Sum\n46 Permutations\n51 N-Queens\n52 N-Queens II\n77 Combinations\n78 Subsets\n89 Gray Code\n93 Restore IP Addresses\n111 Minimum Depth of Binary Tree\n112 Path Sum\n113 Path Sum II\n131 Palindrome Partitioning\n140 Word Break II\n","date":"2024-12-02T15:39:46+08:00","permalink":"http://www.alvincat.top/post/algorithm/backtracking_algorithm/","tags":["排序"],"title":"回溯算法"},{"categories":["算法"],"contents":"本文主要是讲解堆排序的原理和具体实现方法。\n1 堆排序 1.1 堆排序的原理 1.2 堆排序的应用：topk问题 堆排序：堆排序最典型的场景就是topK问题\n使用堆实现top-k问题的技巧：\n获取最大的K个元素，使用小顶堆(优先剔除较小的元素)。\n获取最小的K个元素，使用大顶堆(优先剔除较大的元素)。\nTopK 示例，来源【前 K 个高频元素(LCR060)】，实现原理：\n先使用K个元素构建一个小顶堆。 然后将堆顶元素从堆中删除，然后将新元素插入堆中。 重复这个过程，直到遍历完所有元素。 当遍历完所有元素以后，留在堆中的元素就是最大K个元素。（因为较小的元素都被剔除了。） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 static bool cmp(pair\u0026lt;int, int\u0026gt; left, pair\u0026lt;int, int\u0026gt; right) { return left.second \u0026gt; right.second; } vector\u0026lt;int\u0026gt; topKFrequent(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k) { unordered_map\u0026lt;int, int\u0026gt; num_cnt; for (auto\u0026amp; item : nums) { num_cnt[item]++; } // init priority_queue priority_queue\u0026lt;pair\u0026lt;int, int\u0026gt;, vector\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt;, decltype(\u0026amp;cmp)\u0026gt; little_heap(cmp); for (auto\u0026amp; [num, cnt] : num_cnt) { if (little_heap.size() \u0026lt; k) { little_heap.emplace(num, cnt); } else { if (little_heap.top().second \u0026lt; cnt) { little_heap.pop(); little_heap.emplace(num, cnt); } } } vector\u0026lt;int\u0026gt; res; while (!little_heap.empty()) { res.emplace_back(little_heap.top().first); little_heap.pop(); } reverse(res.begin(), res.end()); return res; } 1.3 大顶堆实现降序序列 使用优先级队列实现大顶堆,默认就是大顶堆。\n大顶堆也可以用来排序：大顶堆排序的结果为降序序列，\n堆出列时，先弹出顶部的元素，而顶部的元素最大，所以的得到序列就是降序的。\n1 2 3 4 5 6 7 8 9 vector\u0026lt;int\u0026gt; vec = {1,8,5,6,3,4,0,9,7,2}; std::priority_queue\u0026lt;int\u0026gt; pri_que; for (int val : vec) { pri_que.push(val); } // 或者自定义比较函数实现 std::vector\u0026lt;int\u0026gt; vec = {3, 1, 4, 1, 5}; std::priority_queue\u0026lt;int\u0026gt; big_heap(std::less\u0026lt;int\u0026gt;(), vec); 1.4 小顶堆实现升序序列 使用优先级队列实现小顶堆需要自定义比较函数。小顶堆的排序结果为升序序列。\n优先级队列中的比较函数的含义：顶部元素和尾部元素的比较结果。\n例如：小顶堆中比较函数是greater的原因是，只有顶部元素比尾部元素大，才需要交换。\n1 2 3 // 使用优先级队列实现小顶堆的方法 std::vector\u0026lt;int\u0026gt; vec = {3, 1, 4, 1, 5}; std::priority_queue\u0026lt;int\u0026gt; little_heap(vec, std::greater\u0026lt;int\u0026gt;()); ","date":"2024-12-02T15:38:46+08:00","permalink":"http://www.alvincat.top/post/algorithm/heap_sort/","tags":["堆排序","排序"],"title":"堆排序的原理与实现"},{"categories":["算法"],"contents":"本文主要针对各种排序算法之间的特性进行比较。\n1.2 排序总结 排序算法按照排序的种类、稳定性、时间复杂度和空间复杂度进行总结。\n名称 排序类型 排序方式 时间复杂度(平均) 时间复杂度(最好) 时间复杂度(最坏) 空间复杂度 稳定性 冒泡排序 比较 交换排序 $O(n^2)$ $O(n)$ $O(n^2)$ O(1) 稳定 快速排序 比较 交换排序 $O(nlogn)$ $O(nlogn)$ $O(n^2)$ $O(logn)$ 不稳定 插入排序 比较 插入排序 $O(n^2)$ $O(n)$ $O(n^2)$ $O(1)$ 稳定 希尔排序 比较 插入排序 $O(n^{4/3})$ $O(nlogn)$ $O(n^{3/2})$ $O(1)$ 不稳定 选择排序 比较 选择排序 $O(n^2)$ $O(n^2)$ $O(n^2)$ $O(1)$ 不稳定 堆排序 比较 选择排序 $O(nlogn)$ $O(nlogn)$ $O(nlogn)$ O(1) 不稳定 归并排序 比较 归并排序 $O(nlogn)$ $O(nlogn)$ $O(nlogn)$ $O(n)$ 稳定 计数排序 非比较 计数 $O(n+r)$ $O(n+r)$ $O(n+r)$ $O(n)$ 稳定 基数排序 非比较 - $O(n*\\frac{k}{d})$ $O(n)$ $O(n*\\frac{k}{d})$ $O(n+2^d)$ 稳定 桶排序 非比较 - $O(n+r)$ - $O(n+r)$ $O(n+r)$ 稳定 ","date":"2024-12-02T15:38:46+08:00","permalink":"http://www.alvincat.top/post/algorithm/sort_summary/","tags":["排序"],"title":"排序算法的比较"},{"categories":["cpp"],"contents":"C++中的STL用法总结\nC++中的STL用法总结 2 queue 3 priority_queue 优先队列（Priority Queue）是一种容器适配器，是在容器queue的基础上实现的。它能够在常数时间内查找最大（默认情况下）元素，插入和删除操作的时间复杂度为$O(logn)$。\n3.1 优先级队列常用成员函数 push(): top(): 获取队列顶部元素； pop(): 删除队列顶部元素； size(): 获取优先级队列中元素个数； empty():判断优先级队列是否为空。 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // 遍历优先级队列 template\u0026lt;typename T\u0026gt; void print_queue(T\u0026amp; q) { while(!q.empty()) { std::cout \u0026lt;\u0026lt; q.top() \u0026lt;\u0026lt; \u0026#34; \u0026#34;; q.pop(); } std::cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } std::priority_queue\u0026lt;int\u0026gt; q; for(int n : {1,8,5,6,3,4,0,9,7,2}) { q.push(n); } std::priority_queue\u0026lt;int, std::vector\u0026lt;int\u0026gt;, std::greater\u0026lt;int\u0026gt; \u0026gt; q2; for(int n : {1,8,5,6,3,4,0,9,7,2}) { q2.push(n); } 4 stack 4.1 常用成员函数 top(): accesses the top element\nempty(): checks whether the underlying container is empty\npush(): inserts element at the top\nemplace: constructs element in-place at the top\npop()：removes the top element\n5 deque 6 array 7 list 8 forward_list 9 map系列 9.1 map 9.1.1 map功能说明 C++中的容器map是存放key,value键-值对的数据结构。内部的key唯一且会按照比较函数进行排序。特性如下：\nkey唯一 内部数据有序 内存数据结构：红黑树（平衡二叉树） 迭代器按照key的升序顺序遍历数据 9.2 multimap 9.2.1 multimap功能说明 数据结构和map相同，区别在于内部的key可以重复。特性如下：\nkey可以重复 内部数据有序 内存数据结构：红黑树（平衡二叉树） 迭代器按照key的升序顺序遍历数据，对于相同的键，按照插入顺序排列； 9.3 unordered_map 9.3.1 unordered_map功能说明 C++中的容器map是存放key,value键-值对的数据结构。内部的key唯一，但是不会对键值对进行排序；特性如下：\nkey唯一 内部数据无序 内部数据结构：哈希表 9.3.2 unordered_map常用接口函数 9.3.2.1 迭代方法 1 2 3 4 5 6 7 8 9 10 // 方法1 std::unordered_map\u0026lt;int, std::string\u0026gt; mag = {{1, \u0026#34;foo\u0026#34;}, {3, \u0026#34;bar\u0026#34;}, {2, \u0026#34;baz\u0026#34;}}; for(auto iter = mag.begin(); iter != mag.end(); ++iter) { std::cout \u0026lt;\u0026lt; \u0026#34;fisrt:\u0026#34; \u0026lt;\u0026lt; item-\u0026gt;first \u0026lt;\u0026lt; \u0026#34;, second: \u0026#34; \u0026lt;\u0026lt; item-\u0026gt;second \u0026lt;\u0026lt; std::endl; } // 方法2 for(auto item : mag) { std::cout \u0026lt;\u0026lt; \u0026#34;fisrt:\u0026#34; \u0026lt;\u0026lt; item-\u0026gt;first \u0026lt;\u0026lt; \u0026#34;, second: \u0026#34; \u0026lt;\u0026lt; item-\u0026gt;second \u0026lt;\u0026lt; std::endl; } 9.3.2.1 查找元素：find() 1 2 3 4 5 6 7 8 9 10 11 // find() // insert() std::unordered_map\u0026lt;int,int\u0026gt; example; auto item = example.find(2); // Finds an element with key equivalent to 2 if(item != example.end()) { std::cout \u0026lt;\u0026lt; \u0026#34;Found element, fisrt:\u0026#34; \u0026lt;\u0026lt; item-\u0026gt;first \u0026lt;\u0026lt; \u0026#34;, second: \u0026#34; \u0026lt;\u0026lt; item-\u0026gt;second \u0026lt;\u0026lt; std::endl; item-\u0026gt;second++; } else { std::cout \u0026lt;\u0026lt; \u0026#34;Not found element!\u0026#34; \u0026lt;\u0026lt; std::endl; example[2] = 1; } 9.3.2.2 更新map 1 2 3 4 std::unordered_map\u0026lt;std::string, size_t\u0026gt; word_map; for (const auto \u0026amp;w : { \u0026#34;this\u0026#34;, \u0026#34;sentence\u0026#34;, \u0026#34;is\u0026#34;, \u0026#34;not\u0026#34;, \u0026#34;a\u0026#34;, \u0026#34;sentence\u0026#34;, \u0026#34;this\u0026#34;, \u0026#34;sentence\u0026#34;, \u0026#34;is\u0026#34;, \u0026#34;a\u0026#34;, \u0026#34;hoax\u0026#34;}) { ++word_map[w]; } 9.4 unordered_multimap 9.4.1 unordered_multimap功能说明 数据结构和unordered_map相同，区别在于内部的key可以重复。特性如下：\nkey不唯一，但每个键关联的值可以不同。 内部数据无序 内部数据结构：哈希表 10 set系列 在C++标准模板库（STL）中，set、multiset、unordered_set和unordered_multiset是四种常用的关联容器。\n10.1 set功能说明 C++中的set容器是一种关联容器，内部存储的是有序唯一的key。特性如下：\nkey唯一 内部数据有序 内部数据结构：红黑树（平衡二叉树） 10.2 multiset 10.2.1 multiset功能说明 C++中的multiset容器是一种关联容器，特性和set类似，唯一区别是可以存在重复的key。特性如下：\nkey不唯一 内部数据有序 内部数据结构：红黑树（平衡二叉树） 10.3 unordered_set 10.3.1 unordered_set功能说明 C++中的unordered_set容器是一种关联容器，内部存储的key唯一。特性如下：\nkey唯一 内部数据无序 内部数据结构：哈希表 10.3.2 unordered_set常用成员函数 empty()\nsize():\ninsert(): Inserts element(s) into the container, if the container doesn\u0026rsquo;t already contain an element with an equivalent key.\nemplace(): Inserts a new element into the container constructed in-place with the given args if there is no element with the key in the container.\nerase(): erases elements\nfind(): finds element with specific key\n10.4 unordered_multiset 10.4.1 unordered_multiset功能说明 C++中的unordered_multiset容器是一种关联容器，内部存储的key唯一。特性如下：\nkey不唯一 内部数据无序 内部数据结构：哈希表 ","date":"2024-12-02T15:29:46+08:00","permalink":"http://www.alvincat.top/post/cpp/stl/cpp_stl/","tags":["STL"],"title":"C++ STL用法总结"},{"categories":["CPP"],"contents":"本文主要是记录c++ string的常用成员函数。\n1 string的常用成员函数 1.1 string的构造方法 1 2 3 4 5 6 7 8 9 10 11 12 std::string s(\u0026#34;Exemplar\u0026#34;); std::string const other(\u0026#34;Exemplar\u0026#34;); std::string s(other); std::string const other(\u0026#34;Exemplary\u0026#34;); std::string s(other, 0, other.length()-1); std::string s(4, \u0026#39;a\u0026#39;); // \u0026#34;aaaa\u0026#34; char mutable_c_str[] = \u0026#34;another C-style string\u0026#34;; std::string s(std::begin(mutable_c_str)+8, std::end(mutable_c_str)-1); 1.2 获取字符串长度:size(), length() 1 2 3 std::string s(\u0026#34;Exemplar\u0026#34;); assert(8 == s.size()); assert(s.size() == s.length()); 1.3 字符串查找:find() 1 2 3 4 5 6 7 8 9 // find(): Finds the first substring equal to the given character sequence. // rfind(): Finds the last substring equal to the given character sequence. string src = \u0026#34;This is a test.\u0026#34; string::size_type index = src.find(\u0026#34;is\u0026#34;); if (index != string::npos) { cout \u0026lt;\u0026lt; \u0026#34;Found, index:\u0026#34; \u0026lt;\u0026lt; index \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;Not found.\u0026#34; \u0026lt;\u0026lt; endl; } 1.4 字符串连接 1.4.1 使用string::append() 示例：\n1 2 3 4 5 6 7 string str1(\u0026#34;foo\u0026#34;); string str2(\u0026#34; bar\u0026#34;); str1.append(str2); cout \u0026lt;\u0026lt; str1 \u0026lt;\u0026lt; endl; // print \u0026#34;foo bar\u0026#34; return 0; 1.4.2 使用连接运算符(+) 1 2 3 4 5 6 7 string str1(\u0026#34;foo\u0026#34;); string str2(\u0026#34; bar\u0026#34;); str1 = str1 + str2; cout \u0026lt;\u0026lt; str1 \u0026lt;\u0026lt; endl; // print \u0026#34;foo bar\u0026#34; return 0; 1.4.3 使用库函数：strcat() 1 2 3 4 5 6 7 string str1(\u0026#34;foo\u0026#34;); string str2(\u0026#34; bar\u0026#34;); strcat(str1, str2); cout \u0026lt;\u0026lt; str1 \u0026lt;\u0026lt; endl; // print \u0026#34;foo bar\u0026#34; return 0; 1.4.3 使用循环 1 2 3 4 5 6 7 8 string str1(\u0026#34;foo\u0026#34;); string str2(\u0026#34; bar\u0026#34;); for (auto i : str2) { str1 += i; } cout \u0026lt;\u0026lt; str1 \u0026lt;\u0026lt; endl; // print \u0026#34;foo bar\u0026#34; return 0; 1.5 C++ string与C字符串互转 1 2 3 4 5 6 7 8 9 10 //string转换为C字符串 string str = \u0026#34;abc\u0026#34;; char arr[100]; strncpy(arr, str.c_str(), str.size()); //c字符串转换为string char cStr[] = \u0026#34;hello\u0026#34;; string str(cStr); 1.6 分割字符串：substr() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 vector\u0026lt;string\u0026gt; SplitString(const string\u0026amp; sourceStr, const string\u0026amp; delimiter) { string tmp = sourceStr; vector\u0026lt;string\u0026gt; output; size_t pos = 0; string token; while ((pos = tmp.find(delimiter)) != string::npos) { token = tmp.substr(0, pos); cout \u0026lt;\u0026lt; token \u0026lt;\u0026lt; endl; output.push_back(token); tmp.erase(0, pos + delimiter.length()); } cout \u0026lt;\u0026lt; tmp \u0026lt;\u0026lt; endl; output.push_back(tmp); return output; } ","date":"2024-12-02T15:28:46+08:00","permalink":"http://www.alvincat.top/post/cpp/cpp_string/","tags":["string"],"title":"c++ string的常用方法"},{"categories":["cpp"],"contents":"C++中常用库函数\nC++中常用库函数 1 字符串处理 1.1 字符串查找: strstr 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; void find_str(char const* str, char const* substr) { char* pos = strstr(str, substr); if(pos) { printf(\u0026#34;found the string \u0026#39;%s\u0026#39; in \u0026#39;%s\u0026#39; at position: %ld\\n\u0026#34;, substr, str, pos - str); } else { printf(\u0026#34;the string \u0026#39;%s\u0026#39; was not found in \u0026#39;%s\u0026#39;\\n\u0026#34;, substr, str); } } int main(void) { char* str = \u0026#34;one two three\u0026#34;; find_str(str, \u0026#34;two\u0026#34;); find_str(str, \u0026#34;\u0026#34;); find_str(str, \u0026#34;nine\u0026#34;); find_str(str, \u0026#34;n\u0026#34;); return 0; } 2 algorithm库 2.1 排序 2.1.1 sort Sorts the elements in the range [first, last) in ascending order. The order of equal elements is not guaranteed to be preserved.\n说明：sort函数默认将数据按照升序排列。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 // template\u0026lt; class RandomIt \u0026gt; // void sort( RandomIt first, RandomIt last ); std::array\u0026lt;int, 10\u0026gt; s = {5, 7, 4, 2, 8, 6, 1, 9, 0, 3}; // sort using the default operator\u0026lt; std::sort(s.begin(), s.end()); // 自定义比较函数，实现降序排序 // sort using a custom function object struct { bool operator()(int a, int b) { return a \u0026lt; b; } } customLess; std::sort(s.begin(), s.end(), customLess); for (auto a : s) { std::cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } std::cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // sort using a lambda expression std::sort(s.begin(), s.end(), [](int a, int b) { return b \u0026lt; a; }); for (auto a : s) { std::cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } std::cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; 2.1.2 stable_sort() 说明：Sorts the elements in the range [first, last) in ascending order. The order of equal elements is guaranteed to be preserved.\n2.1.3 partial_sort() Rearranges elements such that the range [first, middle) contains the sorted middle - first smallest elements in the range [first, last).\nThe order of equal elements is not guaranteed to be preserved. The order of the remaining elements in the range [middle, last) is unspecified.\n1 2 3 4 5 6 std::array\u0026lt;int, 10\u0026gt; s{5, 7, 4, 2, 8, 6, 1, 9, 0, 3}; std::partial_sort(s.begin(), s.begin() + 3, s.end()); for (int a : s) { std::cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } 2.2 二分查找 2.2.1 binary_search() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // template\u0026lt; class ForwardIt, class T\u0026gt; // bool binary_search( ForwardIt first, ForwardIt last, const T\u0026amp; value ); (1) // template\u0026lt; class ForwardIt, class T, class Compare \u0026gt; // bool binary_search( ForwardIt first, ForwardIt last, const T\u0026amp; value, Compare comp ); (2) // 示例 std::vector\u0026lt;int\u0026gt; haystack {1, 3, 4, 5, 9}; std::vector\u0026lt;int\u0026gt; needles {1, 2, 3}; for (auto needle : needles) { std::cout \u0026lt;\u0026lt; \u0026#34;Searching for \u0026#34; \u0026lt;\u0026lt; needle \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; if (std::binary_search(haystack.begin(), haystack.end(), needle)) { std::cout \u0026lt;\u0026lt; \u0026#34;Found \u0026#34; \u0026lt;\u0026lt; needle \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } else { std::cout \u0026lt;\u0026lt; \u0026#34;no dice!\\n\u0026#34;; } } 2.2.2 lower_bound() 功能说明：Returns an iterator pointing to the first element in the range [first, last) that is not less than (i.e. greater or equal to) value.\n1 2 3 4 5 6 7 8 9 10 11 12 // template\u0026lt; class ForwardIt, class T \u0026gt; // ForwardIt lower_bound( ForwardIt first, ForwardIt last, const T\u0026amp; value ); // template\u0026lt; class ForwardIt, class T, class Compare \u0026gt; // ForwardIt lower_bound( ForwardIt first, ForwardIt last, const T\u0026amp; value, Compare comp ); std::vector\u0026lt;int\u0026gt; data = { 1, 1, 2, 3, 3, 3, 3, 4, 4, 4, 5, 5, 6 }; auto lower = std::lower_bound(data.begin(), data.end(), 4); auto upper = std::upper_bound(data.begin(), data.end(), 4); std::copy(lower, upper, std::ostream_iterator\u0026lt;int\u0026gt;(std::cout, \u0026#34; \u0026#34;)); // 4 4 4 2.2.3 upper_bound() Returns an iterator pointing to the first element in the range [first, last) that is greater than value.\n2.3 revert() 接口定义：\n1 template\u0026lt; class BidirIt \u0026gt; void reverse( BidirIt first, BidirIt last ); 示例：\n1 2 3 std::vector\u0026lt;int\u0026gt; v({1,2,3}); std::reverse(std::begin(v), std::end(v)); std::cout \u0026lt;\u0026lt; v[0] \u0026lt;\u0026lt; v[1] \u0026lt;\u0026lt; v[2] \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; 2.4 heap 2.4.1 make_heap() 接口定义：\n1 2 template\u0026lt; class RandomIt\u0026gt; void make_heap(RandomIt first, RandomIt last); template\u0026lt; class RandomIt, class Compare\u0026gt; void make_heap(RandomIt first, RandomIt last, Compare comp); 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 std::vector\u0026lt;int\u0026gt; v = {3, 1, 4, 1, 5, 9}; std::make_heap(v.begin(), v.end()); // heap: 9 4 5 1 1 3 std::cout \u0026lt;\u0026lt; \u0026#34;heap:\\t\u0026#34;; for (const auto \u0026amp;i : v) { std::cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } std::sort_heap(v.begin(), v.end()); // sorted: 1 1 3 4 5 9 std::cout \u0026lt;\u0026lt; \u0026#34;\\nsorted:\\t\u0026#34;; for (const auto \u0026amp;i : v) { std::cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } std::cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; 2.4.2 sort_heap() 接口定义：\n1 2 template\u0026lt; class RandomIt \u0026gt; void sort_heap( RandomIt first, RandomIt last); template\u0026lt; class RandomIt, class Compare \u0026gt; void sort_heap( RandomIt first, RandomIt last, Compare comp); 2.4.3 push_heap() 接口定义：\n1 2 3 4 template\u0026lt; class RandomIt \u0026gt; void push_heap( RandomIt first, RandomIt last ); template\u0026lt; class RandomIt, class Compare\u0026gt; void push_heap(RandomIt first, RandomIt last, Compare comp ); 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 std::vector\u0026lt;int\u0026gt; v { 3, 1, 4, 1, 5, 9 }; std::make_heap(v.begin(), v.end()); std::cout \u0026lt;\u0026lt; \u0026#34;v: \u0026#34;; // v: 9 5 4 1 1 3 for (auto i : v) std::cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39; \u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; v.push_back(6); std::cout \u0026lt;\u0026lt; \u0026#34;before push_heap: \u0026#34;; // before push_heap: 9 5 4 1 1 3 6 for (auto i : v) std::cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39; \u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::push_heap(v.begin(), v.end()); std::cout \u0026lt;\u0026lt; \u0026#34;after push_heap: \u0026#34;; // after push_heap: 9 5 6 1 1 3 4 for (auto i : v) std::cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39; \u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; 2.4.4 pop_heap() 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 std::vector\u0026lt;int\u0026gt; v { 3, 1, 4, 1, 5, 9 }; std::make_heap(v.begin(), v.end()); std::cout \u0026lt;\u0026lt; \u0026#34;v: \u0026#34;; // v: 9 5 4 1 1 3 for (auto i : v) std::cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39; \u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::pop_heap(v.begin(), v.end()); // moves the largest to the end std::cout \u0026lt;\u0026lt; \u0026#34;after pop_heap: \u0026#34;; // after pop_heap: 5 3 4 1 1 9 for (auto i : v) std::cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39; \u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; int largest = v.back(); v.pop_back(); // actually removes the largest element std::cout \u0026lt;\u0026lt; \u0026#34;largest element: \u0026#34; \u0026lt;\u0026lt; largest \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // largest element: 9 std::cout \u0026lt;\u0026lt; \u0026#34;heap without largest: \u0026#34;; // heap without largest: 5 3 4 1 1 for (auto i : v) std::cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39; \u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; ","date":"2024-12-02T15:26:46+08:00","permalink":"http://www.alvincat.top/post/cpp/cpp_common_function/","tags":[""],"title":"C++常用库函数的用法"},{"categories":["Tools"],"contents":"本文主要是一些针对程序员入门的一些资料。\n1 一些基础知识 The Missing Semester of Your CS Education\n2 新手如何提问 How-To-Ask-Questions-The-Smart-Way.\n中文版本：提问的智慧\n经典的关键字：\nSTFW\n如果你收到STFW（Search The Fucking Web）的回应，回答者认为你应该到他妈的网上搜索。那人多半也是对的，去搜索一下吧。（更温和一点的说法是 Google 是你的朋友！）\nRTFM\n有一个古老而神圣的传统：如果你收到RTFM（Read The Fucking Manual）的回应，回答者认为你应该去读他妈的手册。当然，基本上他是对的，你应该去读一读。\nRTFSC\nLinux的鼻祖Linus Torvalds在回答有人提出的Minix的一个问题时，所说的第一句话就是\u0026quot;Read The Fucking Source Code\u0026quot;，这就是RTFSC的来由。\n3 理解(讲解)复杂问题的方法 why: 为什么产生的？背景是啥？ what: 是什么？ 解决什么问题的？优缺点？ how: 怎么实现的？ 4 编程的一些经验 机器的结果一定是正确的。当代码结果不符合预期时，可能存在以下几种情况： 代码存在bug? 使用的库函数、系统调用等存在bug? 硬件(CPU/内存/磁盘)异常 总之，不论是什么情况，都是因为存在软件或者硬件异常导致结果不符合预期的。\n没有测试的代码都是不可靠的\n一切外部输入都是不可靠的\n编写代码一定要采用滚雪球的方式进行\n切记贪多求全，全部写完后再进行测试，问题隐藏的更深，更难被发现。 编写代码时，按照功能进行模块化。已经完成的模块都要进行接口测试。 测试阶段多使用assert(), 提前发现不符合预期的bug。 5 一些有用的学习编程资源 南京大学计算机基础实验\n蒋炎岩操作系统课程视频\n蒋炎岩操作系统课程配套课件和代码\n调试理论与实践 (Fault; Failure; Error; 调试一切) [南京大学2023操作系统-P8] (蒋炎岩)\nmusl-libc-精简易读的类glibc库，适合学习glibc内部实现细节\n6 经典的书籍 Computer Systems: A Programmer\u0026rsquo;s Perspective【深入理解计算机系统】(CSAPP) Operating Systems: Three Easy Pieces(OSTEP) Advanced Programming in the UNIX Environment (3rd Edition)【UNIX环境高级编程】 (APUE) TCP-IP Illustrated Volunme 1-The Protocols 7 实用工具 7.1 windows实用工具 本地文件搜索：everyting\n解压工具：7Zip\n剪贴板：ditto\n截图工具：Snipaste\n图片简单编辑工具：GreenShot\n远程连接客户端(开源免费的类Xshell工具)：WindTerm\n7.2 绘图工具 ProcessOn:在线绘图网站\nDrawio Graphviz：开源图形可视化软件\nXMind: 思维导图工具\nExcalidraw: 开源手绘画风绘图工具\nPlantUML：绘制UML的工具\nMatplotlib【配合python使用】 官网\n7.3 indent工具格式化代码 1 2 # indent工具格式化c/c++代码： indent -kr -i8 hello.c #将源代码格式化为内核编码风格 7.4 ImageMagick给图片添加水印的方法 下载ImageMagick: ImageMagick下载地址 添加ImageMagick的环境变量：将ImageMagick的安装完成后的二进制目录添加到系统path路径中。 制作水印文件watermark.png，可以使用windows自带的mspaint制作。 执行命令composite -dissolve 30% -gravity south watermark.jpg input-file.jpg output-file.jpg制作水印。 也可以批量制作水印。例如下面shell脚本可以将当前目录下所有的jpg文件添加水印。 1 2 3 for pic in *.png; do composite -dissolve 30% watermark.png $pic ${pic//.png}-marked.png done 7.5 7-zip用法 7-zip制作tar.gz压缩包的方法：\n先将待压缩的目录或者文件压缩为tar格式的压缩包 然后再将tar包使用gzip进行压缩即可 8 实用网站 c语言编程书籍推荐\nC++书籍推荐\n操作系统相关知识库\nArchWiki: Arch Linux documentation\n在线LaTeX编辑网站\n计算机自学指南：涵盖计算机相关的网站、书籍等，内容丰富\n开源编程书籍\n计算机相关书籍推荐\n","date":"2024-11-30T19:06:41+08:00","permalink":"http://www.alvincat.top/post/tools/some_usful_tips/","tags":[""],"title":"程序员入门必读"},{"categories":["Tools"],"contents":"本文介绍markdown的语法和一些实用技巧。\n1 Markdown语法 Markdown语法在线文档\n2 Markdown使用说明 2.1 使用emoji表情符的方法 若markdown支持emoji表情符，直接将对应的表情符添加在文本中即可显示。例如：\n今天天气很好!:sunny:\n显示的结果为：今天天气很好! \u0026#x2600;\u0026#xfe0f;\nemoji表情符在线查询: https://github.com/ikatyang/emoji-cheat-sheet/blob/master/README.md\n2.2 Markdown表格单元格中输入多行内容的方法 方法1：在需要换行的地方添加\u0026lt;br\u0026gt;即可。示例： 动物 猫\n狗\n兔 方法2：在markdown中使用html的表格,转换为html后即可支持显示表格。\nPerson 1\rPerson 2\rPerson 3\rEmil\rTobias\rLinus\r16\n17\n18\r14\r10\r2.3 markdown中设置图片大小的方法 直接使用html中设置图片大小的方法即可，这样转换为html就可以符合预期了。\n1 \u0026lt;img src=\u0026#34;/web_image/about/badminton.svg\u0026#34; width=\u0026#34;30\u0026#34;\u0026gt; ","date":"2024-11-30T10:48:47+08:00","permalink":"http://www.alvincat.top/post/tools/markdown_usful_tips/","tags":["Markdown"],"title":"Markdown使用技巧"},{"categories":["Tools"],"contents":"本文介绍gdb一些常用命令。\n1 GDB的一些实用的文档 gdb cheat sheet 100-gdb-tips GDB User Manual GDB online 2 gdbinit文件的简单配置方法 在当前用户目录下创建文件：touch ~/.gdbinit\n在~/.gdbinit文件中添加常用的gdb命令即可。常用的配置如下：\n1 2 3 4 directory /usr/src/glibc/glibc-2.27/ # 指定源码所在目录 layout src # 显示源码模式 set pagination off # 输出信息较多时不会暂停输出 set confirm off # gdb退出时不显示提示信息 3 GDB常用命令 3.1 界面配置 命令 功能 layout src 显示源代码 layout asm 显示汇编代码 layout regs 显示寄存器内容 layout split 显示源代码和汇编窗口 layout next 显示下一个layout layout prev 显示上一个layout tui enable 显示layout窗口 tui disable 退出layout窗口 Ctrl + x -\u0026gt; o 在多个窗口间切换 3.2 单步执行 命令 功能 next/n 单步执行，不进入函数内部 step/s 单步执行，是函数则进入函数内部 until line-number 执行到指定行号 where 显示当前行号和当前所在的函数 3.3 断点调试 命令 功能 break/b \u0026lt;where\u0026gt; 在函数入口设置断点 enable \u0026lt;breakpoint\u0026gt; 打开断点 disable \u0026lt;breakpoint\u0026gt; 关闭断点 delete \u0026lt;breakpoint\u0026gt; 删除断点 clear 删除所有断点 info breakpoints [n] 查看断点 break \u0026lt;where\u0026gt; if \u0026lt;condition\u0026gt; 设置条件断点 示例:\n1 2 # 条件断点：第10行中，若变量i等于101则停止。 b 10 if i==101 3.4 观察点 命令 功能 watch \u0026lt;where\u0026gt;/variable 设置观察点 enable \u0026lt;breakpoint\u0026gt; 打开断点 disable \u0026lt;breakpoint\u0026gt; 关闭断点 delete \u0026lt;breakpoint\u0026gt; 删除断点 info watchpoints [n] 查看观察点 watch \u0026lt;where\u0026gt; if \u0026lt;condition\u0026gt; 设置条件观察点 rwatch/rw variable 设置读观察点 awatch/aw variable 设置读写观察点 watch expr thread threadnum 设置指定线程上的观察点 3.5 断点/观察点位置 命令 功能 function_name 函数名 line_num 行号 filenaem:line_num 文件+行号 addr 地址 3.6 打印信息 命令 功能 print \u0026lt;what\u0026gt; 打印指定内容 print /x $rbp-0x8 将计算结果按照16进制输出 print /x ($ebp+8) 将ebp+8内存中的内容按照16进制输出 info proc mappings 打印内存映射信息 x/nfu 0xaddr Examine the contents of memory and specify formatting.\nn: number of display items to print\nf: specify the format for the output\nu: specify the size of the data unit (eg. byte, word, \u0026hellip;)\nExample: x/4dw var n：输出单元的个数。\nf：是输出格式。比如 x 是以16进制形式输出， o 是以8进制形式输出,等等。\nu：标明一个单元的长度。\nb 是一个Byte(8 bit)\nh 是两个Byte （halfword）\nw 是四个Byte （word）\ng 是八个Byte （giant word）。\n3.7 查看栈帧 命令 功能 backtrace/bt 打印栈帧 frame/f \u0026lt;frame#\u0026gt; 显示指定栈帧 info frame 显示当前栈帧的信息 info locals 显示当前帧的局部变量信息 3.8 调试线程 命令 功能 set scheduler-locking on 只允许一个线程运行 set follow-fork-mode child 调试子进程 set detach-on-fork off 调试父子进程 show scheduler-locking 查看当前的调试模式 info threads 查看进程中的线程信息 thread \u0026lt;thread#\u0026gt; 切换调试线程 温馨提示：\n使用线程的调试模式，需要先使用start/run将程序运行起来后才可以设置。否则会提示Target 'exec' cannot support this command错误。\n3.9 修改程序中的值 命令 功能 set var \u0026lt;variable_name\u0026gt;=\u0026lt;value\u0026gt; 修改变量的值 return \u0026lt;expression\u0026gt; 强制将当前函数按照指定值返回 3.10 汇编运行 命令 功能 info line number 显示指定位置的汇编代码 stepi/si 单步运行汇编指令 nexti/ni 单步运行汇编指令 disassemble 0xstart 0xend 反汇编指定地址的代码 info registers 显示当前寄存器的值 info registers rip 仅显示pc的值 info registers rbp rsp 仅显示rbp, rsp的值 3.11 GDB打印C++ STL中常见结构的内容的方法 3.11.1 通用方法 1 2 3 //vector\u0026lt;int\u0026gt; vec = {1, 2, 3, 4, 5}; print *(vec._M_impl._M_start)@vec.size() print *(vec._M_impl._M_start)@n //print first n element 3.11.2 使用gdb脚本进行打印 使用方法见文章：GDB打印STL中各种容器的内容的方法\n","date":"2024-11-29T16:31:59+08:00","permalink":"http://www.alvincat.top/post/tools/gdb_usful_tips/","tags":["GDB"],"title":"GDB常用命令和一些实用方法"},{"categories":["数据结构"],"contents":"本文介绍二叉树的构造方式。\n1 二叉树的构造方法 1.1 通过前序遍历和中序遍历序列构造二叉树 前提条件：\npreorder 和 inorder 均 无重复 元素 inorder 均出现在 preorder preorder 保证 为二叉树的前序遍历序列 inorder 保证 为二叉树的中序遍历序列 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Solution { public: TreeNode* buildTree(vector\u0026lt;int\u0026gt;\u0026amp; preorder, vector\u0026lt;int\u0026gt;\u0026amp; inorder) { init_map(inorder); int left = 0; int right = inorder.size() - 1; int mid = node_idx[preorder[0]]; int left_len = mid - left; int right_len = right - mid; TreeNode* root = new TreeNode(preorder[0]); root-\u0026gt;left = innerBuildTree(preorder, inorder, left, mid - 1, left + 1, left + left_len); root-\u0026gt;right = innerBuildTree(preorder, inorder, mid + 1, right, left + left_len + 1, right); return root; } private: unordered_map\u0026lt;int, int\u0026gt; node_idx; void init_map(vector\u0026lt;int\u0026gt;\u0026amp; inorder) { for (int i = 0; i \u0026lt; inorder.size(); ++i) { node_idx[inorder[i]] = i; } } TreeNode* innerBuildTree(vector\u0026lt;int\u0026gt;\u0026amp; preorder, vector\u0026lt;int\u0026gt;\u0026amp; inorder, int left, int right, int pre_left, int pre_right) { if (left \u0026gt; right || pre_left \u0026gt; pre_right) { return nullptr; } int mid = node_idx[preorder[pre_left]]; int left_len = mid - left; int right_len = right - mid; TreeNode* node = new TreeNode(inorder[mid]); node-\u0026gt;left = innerBuildTree(preorder, inorder, left, mid - 1, pre_left + 1, pre_left + left_len); node-\u0026gt;right = innerBuildTree(preorder, inorder, mid + 1, right, pre_left + left_len + 1, pre_right); return node; } }; ","date":"2024-11-28T10:30:58+08:00","permalink":"http://www.alvincat.top/post/data_structure/tree/binary_tree_create/","tags":["二叉树"],"title":"创建二叉树的方法"},{"categories":["数据结构"],"contents":"本文介绍二叉树的遍历方法和具体代码实现。\n1 二叉树的遍历方法 二叉树的遍历方法根据访问根结点的先后顺序分为先序、中序、后序遍历。\n下面1.1，1.2，1.3节将分别介绍各种遍历方式的递归实现和非递归实现方法。\n1.1 二叉树的先序遍历 二叉树先序遍历的过程为：遍历根结点，先序遍历左子树，先序遍历右子树。\n1.1.1 二叉树先序遍历的递归实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public: vector\u0026lt;int\u0026gt; preorderTraversal(TreeNode* root) { preorder(root); return res; } void preorder(TreeNode* root) { if (root == NULL) { return; } res.push_back(root-\u0026gt;val); preorder(root-\u0026gt;left); preorder(root-\u0026gt;right); } private: vector\u0026lt;int\u0026gt; res; }; 1.1.2 二叉树先序遍历的非递归实现 先序遍历的非递归实现方式采用DFS的遍历算法，使用栈来保存中间结果。\n方法1：传统方式，首先将根结点添加至栈中，然后循环添加根结点的左孩子结点。\n当左孩子为空时，弹出栈顶结点，并将栈顶的右孩子结点作为根结点重复进行该过程。\n因为是先序遍历，因此所有结点在进栈前进行访问。具体代码如下所示： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public: vector\u0026lt;int\u0026gt; preorderTraversal(TreeNode* root) { vector\u0026lt;int\u0026gt; res; if (root == NULL) { return res; } stack\u0026lt;TreeNode*\u0026gt; stk; TreeNode* top = root; while (!stk.empty() || top) { while (top) { res.push_back(top-\u0026gt;val); stk.push(top); top = top-\u0026gt;left; } top = stk.top(); stk.pop(); top = top-\u0026gt;right; } return res; } }; 方法2：因为栈的特性是后进先出。入栈和出栈的顺序相反，因此可以利用这一特性简化代码流程：\n具体方法为：在根结点出栈前进行访问，然后分别将其右孩子和左孩子进栈。循环进行，直到栈为空为止。\n这样就会在访问的时候先访问左孩子再访问右孩子。具体实现方式如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public: vector\u0026lt;int\u0026gt; preorderTraversal(TreeNode* root) { vector\u0026lt;int\u0026gt; res; if (root == NULL) { return res; } stack\u0026lt;TreeNode*\u0026gt; stk; stk.push(root); while (!stk.empty()) { TreeNode* top = stk.top(); res.push_back(top-\u0026gt;val); stk.pop(); if (top-\u0026gt;right) { stk.push(top-\u0026gt;right); } if (top-\u0026gt;left) { stk.push(top-\u0026gt;left); } } return res; } }; 1.2 二叉树的中序遍历 二叉树先序遍历的过程为：中序序遍历左子树，遍历根结点，中序遍历右子树。\n1.2.1 二叉树的中序遍历的递归实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public: vector\u0026lt;int\u0026gt; inorderTraversal(TreeNode* root) { vector\u0026lt;int\u0026gt; res; inorder(root, res); return res; } void inorder(TreeNode* root, vector\u0026lt;int\u0026gt;\u0026amp; res) { if (root == nullptr) { return; } if (root-\u0026gt;left != nullptr) { inorder(root-\u0026gt;left, res); } res.emplace_back(root-\u0026gt;val); if (root-\u0026gt;right != nullptr) { inorder(root-\u0026gt;right, res); } } }; 1.2.2 二叉树的中序遍历的非递归实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public: vector\u0026lt;int\u0026gt; inorderTraversal(TreeNode* root) { vector\u0026lt;int\u0026gt; res; if (root == NULL) { return res; } stack\u0026lt;TreeNode*\u0026gt; stk; TreeNode* top = root; while (!stk.empty() || top) { while (top) { stk.push(top); top = top-\u0026gt;left; } top = stk.top(); res.push_back(top-\u0026gt;val); stk.pop(); top = top-\u0026gt;right; } return res; } }; 1.3 二叉树的后序遍历 二叉树先序遍历的过程为：中序序遍历左子树，遍历根结点，中序遍历右子树。\n1.3.1 二叉树的后序遍历的递归实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public: vector\u0026lt;int\u0026gt; postorderTraversal(TreeNode* root) { vector\u0026lt;int\u0026gt; res; postorder(root, res); return res; } void postorder(TreeNode* root, vector\u0026lt;int\u0026gt;\u0026amp; vec) { if (root == nullptr) { return; } postorder(root-\u0026gt;left, vec); postorder(root-\u0026gt;right, vec); vec.push_back(root-\u0026gt;val); } }; 1.3.2 二叉树的后序遍历的非递归实现 方法1：传统方法+访问标记 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public: vector\u0026lt;int\u0026gt; postorderTraversal(TreeNode* root) { vector\u0026lt;int\u0026gt; res; if (root == nullptr) { return res; } stack\u0026lt;pair\u0026lt;TreeNode*, bool\u0026gt;\u0026gt; stk; TreeNode* top = root; while (!stk.empty() || top) { while (top) { auto new_node = std::make_pair(top, false); stk.push(new_node); top = top-\u0026gt;left; } pair\u0026lt;TreeNode*, bool\u0026gt; head = stk.top(); stk.pop(); TreeNode* node = head.first; int sign = head.second; if (sign == false) { head.second = true; stk.push(head); top = node-\u0026gt;right; } else { res.push_back(node-\u0026gt;val); top = nullptr; } } return res; } }; 方法2：使用两个栈\n该方法类似于先序遍历的非递归方式中的方法2。\n只是为了得到中-右-左的序列，因此是先让左孩子入栈，再让右孩子入栈。\n最终的得到的序列和目标序列顺序相反，在使用一个栈将顺序调整过来即可。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public: vector\u0026lt;int\u0026gt; postorderTraversal(TreeNode* root) { vector\u0026lt;int\u0026gt; res; if (root == nullptr) { return res; } stack\u0026lt;TreeNode*\u0026gt; stk; stack\u0026lt;TreeNode*\u0026gt; stk_sec; stk.push(root); while (!stk.empty()) { TreeNode* top = stk.top(); stk.pop(); stk_sec.push(top); if (top-\u0026gt;left) { stk.push(top-\u0026gt;left); } if (top-\u0026gt;right) { stk.push(top-\u0026gt;right); } } while (!stk_sec.empty()) { TreeNode* top = stk_sec.top(); res.push_back(top-\u0026gt;val); stk_sec.pop(); } return res; } }; 方法3：使用一个栈\n原理同方法2：但是是通过特殊的先序遍历(遍历的方式为中-右-左的方式)的方式得到中-右-左的序列。 然后将得到的序列翻转一下即可。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public: vector\u0026lt;int\u0026gt; postorderTraversal(TreeNode* root) { vector\u0026lt;int\u0026gt; res; if (root == nullptr) { return res; } stack\u0026lt;TreeNode*\u0026gt; stk; TreeNode* top = root; while (!stk.empty() || top) { while (top) { res.push_back(top-\u0026gt;val); stk.push(top); top = top-\u0026gt;right; } top = stk.top(); stk.pop(); top = top-\u0026gt;left; } reverse(res.begin(), res.end()); return res; } }; 1.4 二叉树的层次遍历 二叉树的层次遍历实际上是对二叉树的广度优先遍历。\n原理参考BFS原理的讲解。具体代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; levelOrder(TreeNode* root) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res; if (root == NULL) { return res; } queue\u0026lt;TreeNode*\u0026gt; que_level; que_level.push(root); while (!que_level.empty()) { int que_size = que_level.size(); vector\u0026lt;int\u0026gt; level_vec; for (int i = 0; i \u0026lt; que_size; ++i) { TreeNode* head = que_level.front(); if (head-\u0026gt;left) { que_level.push(head-\u0026gt;left); } if (head-\u0026gt;right) { que_level.push(head-\u0026gt;right); } level_vec.push_back(head-\u0026gt;val); que_level.pop(); } res.push_back(level_vec); level_vec.clear(); } return res; } }; 2 二叉树的遍历方法总结 二叉树的前序中序、后序遍历都属于深度优先遍历(DFS)，而层次遍历属于广度优先遍历(BFS)。\n深度优先遍历需要使用栈作为存储中间过程的数据结构，而广度优先遍历需要使用队列作为中间过程的数据结构。 通过1.1,1.2,1.3的递归实现和非递归实现，我们不难发现。\n三种递归遍历方式实现代码较为简洁，三种遍历的方式的差异在于访问根结点的时机。迭代是访问根结点的时机和对应的遍历方式对应。\n三种非递归方式的实现都有可以使用传统遍历框架，区别在于访问结点的差异：\n先序遍历：先访问结点，再放入栈； 中序遍历：先放入栈，出栈时再访问结点； 后序遍历：增加标记，结点进栈两次，第二次出栈时再访问结点； 先序遍历和后续遍历：可以通过栈后进先出的特性调整顺序，简化操作。\n","date":"2024-11-27T11:11:07+08:00","permalink":"http://www.alvincat.top/post/data_structure/tree/binary_tree_traverse/","tags":["二叉树"],"title":"二叉树的遍历"},{"categories":["算法"],"contents":"本文讲解DFS算法的核心思想和代码基本框架。\n1 DFS算法的核心思想 DFS的英文全称为(Depth-first search),称为深度优先搜索算法。 该算法是用于在树形结构中按照某种规则搜索结点的算法。\n该算法的核心思想是从起始点出发，沿着某一条路径一直向前搜索，直到没有路径后结束。然后再回到起点继续遍历还未遍历的结点，直到遍历完所有结点。\n","date":"2024-11-26T16:31:22+08:00","permalink":"http://www.alvincat.top/post/algorithm/dfs/","tags":["DFS"],"title":"遍历-DFS"},{"categories":["算法"],"contents":"本文讲解BFS算法的核心思想和代码基本框架。\n1 BFS算法的核心思想 BFS的英文全称为(Breadth-first search),称为广度优先搜索算法。 该算法是用于在树形结构中按照某种规则搜索结点的算法。 该算法的核心思想是从起始点出发，依次遍历完起始点周围的结点，不断重复该过程直至扩散至所有结点。\n2 BFS算法的代码框架 基于BFS的特点：代码实现时，采用队列来保存每一轮迭代的结果。\n首次将起始点或初始状态的结点插入队列。 在出队列时，将和该结点关联的结点进队。 操作结束的条件：队列为空。 温馨提示：\n若需要区分每层遍历的结果，可以通过记录队列中元素的个数来实现。\n1 2 3 4 5 6 7 8 9 10 queue.push(root); while (!queue.empty()) { int size = 0; for (int idx = 0; idx \u0026lt; size; ++i) { head = queue.front(); xxx;// 执行和队列头部相关的操作 queue.push(head-\u0026gt;child); queue.pop(); } } ","date":"2024-11-26T16:29:32+08:00","permalink":"http://www.alvincat.top/post/algorithm/bfs/","tags":["BFS"],"title":"遍历-BFS"},{"categories":["操作系统"],"contents":"本文总结Linux系统启动的详细流程以及启动流程涉及的基础知识。\n1 Linux系统的传统启动流程 主机上电，运行BIOS MBR 进入引导程序(GRUB） 运行kernel init 2 BIOS和UEFI BIOS(Basic Input Output System) UEFI(Unified Extensible Firmware Interface)\n3 MBR和GPT MBR(Master Boot Record), GPT (GUID Partition Table),\n4 引导程序简介 5 常见linux发布版本启动的差异(CentOS/Ubuntu)","date":"2024-11-20T20:56:16+08:00","permalink":"http://www.alvincat.top/post/operating_system/linux_kernel/kernel_boot_process/","tags":["kernel_boot_process"],"title":"Kernel_boot_process"},{"categories":["Linux"],"contents":"本文记录Linux系统常用的系统设置的方法。\n1 Linux系统配置coredump的方法 1.1 临时配置方法 设置ulimit中core大小限制 执行命令：ulimit -c unlimited\n配置coredump的生成路径 执行命令：echo \u0026quot;/path/core-%e-%p-%s-%t\u0026quot; \u0026gt; /proc/sys/kernel/core_pattern\n该配置方法，当系统重启后就会失效。\n1.2 永久配置方法 配置当前用户的corefile size大小 在配置文件中增加一行配置项，如下所示： 1 2 #\u0026lt;domain\u0026gt; \u0026lt;type\u0026gt; \u0026lt;item\u0026gt; \u0026lt;value\u0026gt; root hard core 100000 其中，对于item为core的配置项，value的单位为KB.\n然后再/etc/profile文件中增加配置： 1 2 # No core files by default ulimit -S -c unlimited \u0026gt; /dev/null 2\u0026gt;\u0026amp;1 然后再进程的启动脚本中添加如下命令： 1 echo \u0026#34;/path/core-%e-%p-%s-%t\u0026#34; \u0026gt; /proc/sys/kernel/core_pattern 参考文档：\nHow to enable core file dumps when an application crashes or segmentation faults\n2 修改Hostname 2.1 通过命令修改 1 hostnamectl set-hostname new_host_name 2.2 修改配置文件 修改配置文件/etc/hostname中的名字即可（需要root权限）。\n3 Linux修改终端的显示 通过修改/etc/profile或者当前用户目录下的PS1变量既可以实现。\n参考链接： How to display current path in command prompt in linux\u0026rsquo;s sh (not bash)?\n1 2 3 4 # \\u username # \\h hostname # \\W Name of present folder (not full path) # \\w current path(pull path) ","date":"2024-11-19T15:48:31+08:00","permalink":"http://www.alvincat.top/post/linux/linux_common_setting/","tags":["linux系统设置"],"title":"Linux系统常用的系统配置"},{"categories":["Tools"],"contents":"本文记录vim常用参数的配置方法已经常用命令。\n1.1 vim常用设置 1.1 增加vim配置文件的方法 新建~/.vimrc文件。\n1.2 vim 常用设置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 \u0026#34; Turn syntax highlighting on. syntax on \u0026#34; Add numbers to each line on the left-hand side. set number \u0026#34; Highlight cursor line underneath the cursor horizontally. set cursorline \u0026#34; Highlight cursor line underneath the cursor vertically. \u0026#34;set cursorcolumn \u0026#34; Set shift width to 4 spaces. set shiftwidth=4 \u0026#34; Set tab width to 4 columns. set tabstop=4 \u0026#34; Use space characters instead of tabs. set expandtab \u0026#34; Do not save backup files. set nobackup \u0026#34; Do not let cursor scroll below or above N number of lines when scrolling. set scrolloff=10 \u0026#34; Do not wrap lines. Allow long lines to extend as far as the line goes. set nowrap \u0026#34; While searching though a file incrementally highlight matching characters as you type. set incsearch \u0026#34; Ignore capital letters during search. \u0026#34;set ignorecase \u0026#34; Override the ignorecase option if searching for capital letters. \u0026#34; This will allow you to search specifically for capital letters. set smartcase \u0026#34; Show partial command you type in the last line of the screen. set showcmd \u0026#34; Show the mode you are on the last line. set showmode \u0026#34; Show matching words during a search. set showmatch \u0026#34; Use highlighting when doing a search. set hlsearch \u0026#34; Set the commands to save in history default number is 20. set history=1000 \u0026#34; set autoindent \u0026#34; Set c language auto indent set cindent 参考文档:\nVimrc Configuration Guide - How to Customize Your Vim Code Editor with Mappings, Vimscript, Status Line, and More\n2 vim常用命令 2.1 vim替换字符串命令 替换当前行\n命令：:s/foo/bar/g\n替换第 n 行开始到最后一行中字符串\n命令： n,$s/foo/bar/\n替换文件中所有行的字符串\n命令：:%s/foo/bar/g\n2.2 vim直接输入tab的方法 因为在vim配置文件中配置tab键转换为4个空格，因此在编写makefile时直接按tab间无法达到输入tab的目的。\n在编辑模式或者命令模式下(界面最下方有冒号)，先按快捷键ctrl+v，然后按tab键即可。\n2.3 vim中执行命令的方法 进入命令模式，输入!加在终端输入的命令即可。例如： :!./hello\t//执行hello\n2.4 vim在多行尾部添加内容的方法 使用Shift + v选中多行 然后按:进入命令模式 然后键入normal,进入normal模式 再normal后键入空格，在输入A ;即可在多行后添加分号;。\n命令最终的内容如下：:'\u0026lt;,'\u0026gt;normal A;，其中的'\u0026lt;,'\u0026gt;不需要输入。 ","date":"2024-11-19T15:17:40+08:00","permalink":"http://www.alvincat.top/post/tools/vim_usful_setting/","tags":["vim"],"title":"Vim常用设置以及常用命令"},{"categories":["操作系统"],"contents":"本文记录Ubutun操作系统常用的系统配置的设置方法和常用命令的用法。\n1 Ubuntu 18.04配置网络的方法 1.1 查看网卡 按照教程VirtualBox实现宿主机访问虚拟机以及虚拟机联网的方法配置好两张网卡，一张卡用于访问外网， 一张卡用于在windows中登陆虚拟机。\n1.2 编辑网卡配置文件 编辑网卡配置文件：sudo vim /etc/netplan/00-installer-config.yaml 注意：Ubuntu 18.04及以后版本不在使用/etc/network/interfaces文件配置网络。改为使用/etc/netplan/*.yaml文件。\n1 2 3 4 5 6 7 8 9 10 network: version: 2 ethernets: enp0s3: dhcp4: true nameservers: addresses: [223.5.5.5,223.6.6.6] enp0s8: dhcp4: false addresses: [192.168.56.8/24] 配置说明：enp0s3为网卡1，是用来访问外网使用的，使用动态IP。 enp0s8是用来访问内部网络的。设置为静态IP，IP和虚拟网卡的IP在同一个网段即可。不需要配置网关，配置网关会导致无法访问外网。 配置完成后，重启网络，即可生效：sudo netplan apply 配置完成后，可以查询到跟新后的网络配置。如下图所示： 1.3 配置DNS的方法 查了下，这个服务的配置文件为 /etc/systemd/resolved.conf，大致内容如下：\n1 2 3 4 5 6 7 8 9 [Resolve] DNS=180.76.76.76 #FallbackDNS= #Domains= LLMNR=no #MulticastDNS=no #DNSSEC=no #Cache=yes #DNSStubListener=yes 如果我们要想让 /etc/resolve.conf 文件里的配置生效，需要添加到 systemd-resolved 的这个配置文件里 DNS 配置项（如上面的示例，已经完成修改），然后重启 systemd-resolved 服务即可： systemctl restart systemd-resolved.service 另一种更简单的办法是，我们直接停掉 systemd-resolved 服务，这样再修改 /etc/resolve.conf 就可以一直生效了。\n查看结果：systemd-resolve --status\n2 ubuntu系统配置apt源的方法 备份/etc/apt/sources.list文件 mv /etc/apt/sources.list /etc/apt/sourses.list.backup\n新建/etc/apt/sources.list文件并添加以下内容\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #163源 deb http://mirrors.163.com/ubuntu/ bionic main restricted universe multiverse deb http://mirrors.163.com/ubuntu/ bionic-security main restricted universe multiverse deb http://mirrors.163.com/ubuntu/ bionic-updates main restricted universe multiverse deb http://mirrors.163.com/ubuntu/ bionic-proposed main restricted universe multiverse deb http://mirrors.163.com/ubuntu/ bionic-backports main restricted universe multiverse deb-src http://mirrors.163.com/ubuntu/ bionic main restricted universe multiverse deb-src http://mirrors.163.com/ubuntu/ bionic-security main restricted universe multiverse deb-src http://mirrors.163.com/ubuntu/ bionic-updates main restricted universe multiverse deb-src http://mirrors.163.com/ubuntu/ bionic-proposed main restricted universe multiverse deb-src http://mirrors.163.com/ubuntu/ bionic-backports main restricted universe multiverse #中科大源 deb https://mirrors.ustc.edu.cn/ubuntu/ bionic main restricted universe multiverse deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-security main restricted universe multiverse deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic main restricted universe multiverse deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-security main restricted universe multiverse deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse #阿里云源 deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse #清华源 deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse 3 apt常用命令 1 2 3 4 5 6 7 8 apt-get update # 更新源 apt-get install package # 安装包 apt-get remove package # 删除包 apt-get upgrade # 更新已安装的包 apt-cache search package # 查询软件包 apt list --installed # 查询系统已安装的软件包 4 Ubuntu设置root登陆的方法 使用安装系统时的高级用户解锁root用户 1 sudo passwd root 设置root用户密码： 1 sudo passwd -u root 切换到root用户，执行命令：su\n解除root用户登陆限制： 打开文件/etc/ssh/sshd_config, 找如下内容：\n1 2 3 4 5 #LoginGraceTime 2m #PermitRootLogin prohibit-password #StrictModes yes #MaxAuthTries 6 #MaxSessions 10 然后将配置修改为：\n1 2 3 4 5 LoginGraceTime 2m PermitRootLogin yes StrictModes yes MaxAuthTries 3 MaxSessions 10 然后重启ssh服务：systemctl restart ssh.service 5 制作deb包的方法 创建工作目录并执行以下命令： 1 2 # 假设创建的软件为：myProject mkdir myProject \u0026amp;\u0026amp; mkdir myProject/DEBIAN 拷贝文件至工作目录 将需要打包到deb包中的文件拷贝到工作目录中。\n若希望deb软件包安装后将二进制存在在指定目录下，需要在工作目录下提前创建好对应的目录，然后将文件拷贝到对应的目录下。\n例如，希望将test.sh安装在/usr/local/bin/目录下，按照如下步骤操作即可： 1 2 mkdir -p myProject/usr/local/bin/; cp /usr/local/bin/test.sh myProject/usr/local/bin/ 创建配置文件 在DEBIAN目录下创建配置文件control，这个配置文件包含了软件的很多关键信息，例如：软件名称、版本、维护者、架构和描述信息等。\n创建post-installation文件 除以上几步以外，还可以添加post-installation文件，该文件用于在软件安装完成后执行一系列收尾工作。\n要添加该文件，需要在DEBIAN目录下创建名称为postinst的文件，并且确保该文件可以执行。\n创建软件包 切换到在工作目录所在目录，然后执行命令创建软件包：dpkg-deb --build myProject 创建的软件包会保存在工作目录下。\n可以使用如下命令安装文件： dpkg -i myProject.deb\n6 查询系统版本的方法 1 2 3 4 5 # 方法1 cat /etc/os-release # 方法2 lsb_release -a 7 Ubuntu安装操作ncat的方法 1 apt-get install nmap ","date":"2024-11-19T15:17:20+08:00","permalink":"http://www.alvincat.top/post/operating_system/ubuntu_setting/","tags":["ubuntu"],"title":"Ubuntu系统常用设置和命令"},{"categories":["数据结构"],"contents":"本文介绍LRU的原理和具体c代码实现。\nLRU的英文全称为Least Recently Used，即最近最少使用。该算法为cache淘汰算法，将最近最少使用的元素淘汰掉。具体代码是由hashTable和一个双向链表实现的。\n使用双向链表存放key-value，使用哈希表存储双向链表的结点地址，保证访问结点的复杂度为 $O(1)$。通常来讲，对数据的读写都算做对数据的访问。\n1 LRU的C代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;assert.h\u0026gt; /* define struct start */ #define FREE(ptr) \\ free(ptr); \\ ptr = NULL; typedef int KEY; typedef int VAL; typedef struct ForwardListNode { KEY key; VAL val; struct ForwardListNode* prev; struct ForwardListNode* next; } ForwardListNode; typedef struct HashNode { ForwardListNode* dNode; struct HashNode* next; } HashNode; typedef struct HashTable { HashNode** bucket; int (*destroy)(struct HashTable* tb); int (*hash)(struct HashTable* tb, KEY key); int (*insert)(struct HashTable* tb, HashNode* node); int (*remove)(struct HashTable* tb, KEY key); HashNode* (*find)(struct HashTable* tb, KEY key); int bucket_num; } HashTable; typedef struct { ForwardListNode* head; HashTable* ht; int capacity; int size; } LRUCache; /* ------------------------ */ /* LinkList function start */ int insertListNode(HashNode** head, HashNode* node) { if (*head == NULL) { *head = node; return 0; } node-\u0026gt;next = *head; *head = node; return 0; } int removeListNode(HashNode** head, HashNode* node) { if (*head == node) { *head = (*head)-\u0026gt;next; FREE(node); return 0; } HashNode* prev = *head; HashNode* cur = (*head)-\u0026gt;next; while (cur) { if (cur == node) { prev-\u0026gt;next = cur-\u0026gt;next; FREE(node); return 0; } prev = prev-\u0026gt;next; cur = cur-\u0026gt;next; } return -1; } HashNode* findListNode(HashNode* head, KEY key) { if (head == NULL) { return NULL; } while (head) { if (head-\u0026gt;dNode-\u0026gt;key == key) { return head; } head = head-\u0026gt;next; } return NULL; } void ListNodeDestroy(HashNode* head) { if (head == NULL) { return; } HashNode* cur = head; while (cur) { HashNode* prev = cur-\u0026gt;next; FREE(cur); cur = prev; } } /* ------------------------ */ /* HashTable function */ HashNode* initHashNode(ForwardListNode* node) { HashNode* hNode = (HashNode*)malloc(sizeof(HashNode)); if (hNode == NULL) { return NULL; } hNode-\u0026gt;dNode = node; hNode-\u0026gt;next = NULL; return hNode; } int hashFunc(HashTable* tb, KEY key) { return key % tb-\u0026gt;bucket_num; } HashNode* findHashNode(HashTable* tb, KEY key) { int index = tb-\u0026gt;hash(tb, key); assert(index \u0026gt;= 0 \u0026amp;\u0026amp; index \u0026lt; tb-\u0026gt;bucket_num); return findListNode(tb-\u0026gt;bucket[index], key); } int insertHashNode(HashTable* tb, HashNode* node) { int index = tb-\u0026gt;hash(tb, node-\u0026gt;dNode-\u0026gt;key); assert(index \u0026gt;= 0 \u0026amp;\u0026amp; index \u0026lt; tb-\u0026gt;bucket_num); return insertListNode(\u0026amp;tb-\u0026gt;bucket[index], node); } int removeHashNode(HashTable* tb, KEY key) { int index = tb-\u0026gt;hash(tb, key); assert(index \u0026gt;= 0 \u0026amp;\u0026amp; index \u0026lt; tb-\u0026gt;bucket_num); if (tb-\u0026gt;bucket[index] == NULL) { return -1; } HashNode** head = \u0026amp;tb-\u0026gt;bucket[index]; HashNode* node = findListNode(*head, key); return removeListNode(head, node); } HashTable* initHashTableMem(void) { HashTable* ht = (HashTable*)malloc(sizeof(HashTable)); if (ht == NULL) { return NULL; } memset(ht, 0, sizeof(HashTable)); return ht; } int destroyHashTable(struct HashTable* tb) { for (int i = 0; i \u0026lt; tb-\u0026gt;bucket_num; ++i) { HashNode* head = tb-\u0026gt;bucket[i]; if (head == NULL) { continue; } ListNodeDestroy(head); } FREE(tb-\u0026gt;bucket); FREE(tb); return 0; } int initializeHashTable(struct HashTable* tb, int num) { tb-\u0026gt;hash = hashFunc; tb-\u0026gt;insert = insertHashNode; tb-\u0026gt;remove = removeHashNode; tb-\u0026gt;find = findHashNode; tb-\u0026gt;destroy = destroyHashTable; if (num == 0) { printf(\u0026#34;input bucket num must greater then 0.\\n\u0026#34;); return -1; } tb-\u0026gt;bucket_num = num; tb-\u0026gt;bucket = (HashNode**)malloc(sizeof(HashNode*) * num); if (tb-\u0026gt;bucket == NULL) { printf(\u0026#34;malloc failed.\\n\u0026#34;); return -1; } memset(tb-\u0026gt;bucket, 0, sizeof(HashNode*) * num); return 0; } /*------------------------------------------*/ /* forward_list function */ ForwardListNode* initForwardListNode(KEY key, VAL val) { ForwardListNode* DNode = (ForwardListNode*)malloc(sizeof(ForwardListNode)); if (DNode == NULL) { return NULL; } DNode-\u0026gt;key = key; DNode-\u0026gt;val = val; DNode-\u0026gt;prev = DNode; DNode-\u0026gt;next = DNode; return DNode; } void insertToHead(ForwardListNode* head, ForwardListNode* node) { if (head-\u0026gt;next != head) { node-\u0026gt;next = head-\u0026gt;next; head-\u0026gt;next-\u0026gt;prev = node; head-\u0026gt;next = node; node-\u0026gt;prev = head; } else { head-\u0026gt;next = node; head-\u0026gt;prev = node; node-\u0026gt;prev = head; node-\u0026gt;next = head; } } void removeFromTail(ForwardListNode* head) { if (head-\u0026gt;next != head) { ForwardListNode* tail = head-\u0026gt;prev; tail-\u0026gt;next-\u0026gt;prev = tail-\u0026gt;prev; tail-\u0026gt;prev-\u0026gt;next = tail-\u0026gt;next; FREE(tail); } } void updateForwardList(ForwardListNode* head, ForwardListNode* node) { if (head == NULL) { return; } node-\u0026gt;prev-\u0026gt;next = node-\u0026gt;next; node-\u0026gt;next-\u0026gt;prev = node-\u0026gt;prev; insertToHead(head, node); } void destroyForwardListNode(ForwardListNode* head) { if (head == NULL) { return; } ForwardListNode* cur = head-\u0026gt;next; while (cur \u0026amp;\u0026amp; cur != head) { ForwardListNode* next = cur-\u0026gt;next; FREE(cur); cur = next; } FREE(head); } /*------------------------------------------*/ /* LRUCache function */ LRUCache* lRUCacheCreate(int capacity) { LRUCache* lru = (LRUCache*)malloc(sizeof(LRUCache)); if (lru == NULL) { return NULL; } memset(lru, 0, sizeof(LRUCache)); lru-\u0026gt;head = initForwardListNode(-1, -1); if (lru-\u0026gt;head == NULL) { FREE(lru); } lru-\u0026gt;ht = initHashTableMem(); if (lru-\u0026gt;ht == NULL) { FREE(lru-\u0026gt;head); FREE(lru); return NULL; } int ret = initializeHashTable(lru-\u0026gt;ht, capacity); if (ret != 0) { FREE(lru-\u0026gt;ht); FREE(lru-\u0026gt;head); FREE(lru); return NULL; } lru-\u0026gt;size = 0; lru-\u0026gt;capacity = capacity; return lru; } int lRUCacheGet(LRUCache* obj, int key) { HashTable* ht = obj-\u0026gt;ht; ForwardListNode* DouList = obj-\u0026gt;head; HashNode* node = ht-\u0026gt;find(ht, key); if (node == NULL) { return -1; } updateForwardList(DouList, node-\u0026gt;dNode); return node-\u0026gt;dNode-\u0026gt;val; } void lRUCachePut(LRUCache* obj, int key, int value) { HashTable* ht = obj-\u0026gt;ht; ForwardListNode* DouListHead = obj-\u0026gt;head; int index = ht-\u0026gt;hash(ht, key); HashNode* hNode = findListNode(ht-\u0026gt;bucket[index], key); if (hNode == NULL) { ForwardListNode* dNode = initForwardListNode(key, value); if (dNode == NULL) { printf(\u0026#34;mem alloc failed.\\n\u0026#34;); return; } HashNode* new_node = initHashNode(dNode); if (new_node == NULL) { FREE(dNode); printf(\u0026#34;mem alloc failed.\\n\u0026#34;); return; } insertToHead(DouListHead, dNode); insertListNode(\u0026amp;ht-\u0026gt;bucket[index], new_node); ++obj-\u0026gt;size; // del node from tail if (obj-\u0026gt;size \u0026gt; obj-\u0026gt;capacity) { ForwardListNode* tail = DouListHead-\u0026gt;prev; ht-\u0026gt;remove(ht, tail-\u0026gt;key); removeFromTail(DouListHead); obj-\u0026gt;size--; } } else { if (hNode-\u0026gt;dNode-\u0026gt;val != value) { hNode-\u0026gt;dNode-\u0026gt;val = value; } updateForwardList(DouListHead, hNode-\u0026gt;dNode); } } void lRUCacheFree(LRUCache* obj) { destroyForwardListNode(obj-\u0026gt;head); obj-\u0026gt;ht-\u0026gt;destroy(obj-\u0026gt;ht); FREE(obj); } 1.1 关键函数功能简介 LRU的代码实现可以分为4部分。\n1.1.1 单向链表的操作 int insertListNode(HashNode** head, HashNode* node)\n功能说明：向单链表的头部插入一个结点\nint removeListNode(HashNode** head, HashNode* node)\n功能说明：从单链表中移出指定的结点\nHashNode* findListNode(HashNode* head, KEY key)\n功能说明： 在单链表中查找包含指定key的结点\nvoid ListNodeDestroy(HashNode* head)\n功能说明：销毁单链表\n1.1.2 双向链表的操作 ForwardListNode* initForwardListNode(KEY key, VAL val)\n功能说明：构造双向链表的结点。\nvoid insertToHead(ForwardListNode* head, ForwardListNode* node)\n功能说明：向双向链表的头部插入一个结点。\nvoid removeFromTail(ForwardListNode* head)\n功能说明：从双向链表的尾部删除一个结点\nvoid updateForwardList(ForwardListNode* head, ForwardListNode* node)\n功能说明：更新双向链表中的结点，即将指定结点移动到双向链表的头部。\nvoid destroyForwardListNode(ForwardListNode* head)\n功能说明：销毁双向链表\n温馨提示：\n双向链表的遍历操作和单向链表不同,通过判断cur == head作为判断循环终止的条件。\n1.1.3 哈希表的操作 HashNode* initHashNode(ForwardListNode* node)\n功能说明：初始化哈希表的结点\nint hashFunc(HashTable* tb, KEY key)\n功能说明：哈希函数\nHashNode* findHashNode(HashTable* tb, KEY key)\n功能说明：根据key查找哈希结点\nint insertHashNode(HashTable* tb, HashNode* node)\n功能说明： 插入一个哈希结点\nint removeHashNode(HashTable* tb, KEY key)\n功能说明： 删除一个哈希结点\nHashTable* initHashTableMem(void)\n功能说明： 初始化哈希表\nint destroyHashTable(struct HashTable* tb)\n功能说明： 销毁哈希表\nint initializeHashTable(struct HashTable* tb, int num)\n功能说明： 初始化哈希表中的成员\n1.1.4 LRU相关的操作 LRUCache* lRUCacheCreate(int capacity)\n功能说明：创建LRU\nint lRUCacheGet(LRUCache* obj, int key)\n功能说明：查询lru中是否存在key\nvoid lRUCachePut(LRUCache* obj, int key, int value)\n功能说明：向LRU中插入指定的key-value\nvoid lRUCacheFree(LRUCache* obj)\n功能说明： 销毁LRU\n1.1.4 LRU程序的测试代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 void printHashTable(HashTable* tb); void printLruCache(LRUCache* lru); int main(void) { LRUCache* lru = lRUCacheCreate(2); printf(\u0026#34;Put (1,1) \u0026#34;); lRUCachePut(lru, 1, 1); printLruCache(lru); printf(\u0026#34;Put (2,2) \u0026#34;); lRUCachePut(lru, 2, 2); printLruCache(lru); printf(\u0026#34;Get 1 \u0026#34;); int ret = lRUCacheGet(lru, 1); printf(\u0026#34;get(1) ret:%d.\\n\u0026#34;, ret); printLruCache(lru); printf(\u0026#34;Put (3,3) \u0026#34;); lRUCachePut(lru, 3, 3); printLruCache(lru); printf(\u0026#34;Get 2 2 \u0026#34;); ret = lRUCacheGet(lru, 2); printf(\u0026#34;get(2) ret:%d.\\n\u0026#34;, ret); printLruCache(lru); printf(\u0026#34;Put (4,4) \u0026#34;); lRUCachePut(lru, 4, 4); printLruCache(lru); printf(\u0026#34;Get 1 \u0026#34;); ret = lRUCacheGet(lru, 1); printf(\u0026#34;get(1) ret:%d.\\n\u0026#34;, ret); printLruCache(lru); printf(\u0026#34;Put (3,3) \u0026#34;); lRUCachePut(lru, 3, 3); printLruCache(lru); lRUCacheFree(lru); return 0; } void printLruCache(LRUCache* lru) { DouListNode* cur = lru-\u0026gt;head-\u0026gt;next; printf(\u0026#34;LRUCache num: %d.\\n\u0026#34;, lru-\u0026gt;size); while (cur != lru-\u0026gt;head) { printf(\u0026#34;[%d|%d|-]-\u0026gt;\u0026#34;, cur-\u0026gt;key, cur-\u0026gt;val); cur = cur-\u0026gt;next; } printf(\u0026#34;\\n\\n\u0026#34;); return; } void printListNode(HashNode* head) { if (head == NULL) { return; } while (head) { printf(\u0026#34;[%d|%d|-]-\u0026gt;\u0026#34;, head-\u0026gt;dNode-\u0026gt;key, head-\u0026gt;dNode-\u0026gt;val); head = head-\u0026gt;next; } printf(\u0026#34;\\n\u0026#34;); } void printHashTable(HashTable* tb) { for (int i = 0; i \u0026lt; tb-\u0026gt;bucket_num; ++i) { HashNode* head = tb-\u0026gt;bucket[i]; if (head == NULL) { continue; } printf(\u0026#34;index：%d, \u0026#34;, i); printListNode(head); } } 2 LRU的c++代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 struct DNode { DNode() : key(-1), value(-1), prev(nullptr), next(nullptr) {} DNode(int k, int v) : key(k), value(v), prev(nullptr), next(nullptr) {} int key; int value; DNode* prev; DNode* next; }; class LRUCache { public: LRUCache(int capacity) { cap = capacity; size = 0; head = new DNode(); tail = new DNode(); head-\u0026gt;next = tail; head-\u0026gt;prev = tail; tail-\u0026gt;prev = head; tail-\u0026gt;next = head; } int get(int key) { auto item = hashTable.find(key); if (item != hashTable.end()) { DNode* node = item-\u0026gt;second; removeNode(node); insertNodeToHead(node); return node-\u0026gt;value; } return -1; } void put(int key, int value) { auto item = hashTable.find(key); if (item != hashTable.end()) { DNode* node = item-\u0026gt;second; if (node-\u0026gt;value != value) { node-\u0026gt;value = value; } removeNode(node); insertNodeToHead(node); } else { DNode* node = new DNode(key, value); hashTable[key] = node; insertNodeToHead(node); ++size; if (size \u0026gt; cap) { --size; DNode* lastNode = tail-\u0026gt;prev; hashTable.erase(lastNode-\u0026gt;key); removeNode(lastNode); delete lastNode; } } } private: unordered_map\u0026lt;int, DNode*\u0026gt; hashTable; DNode* head; DNode* tail; int cap; int size; void removeNode(DNode* node) { node-\u0026gt;prev-\u0026gt;next = node-\u0026gt;next; node-\u0026gt;next-\u0026gt;prev = node-\u0026gt;prev; } void insertNodeToHead(DNode* node) { node-\u0026gt;next = head-\u0026gt;next; node-\u0026gt;prev = head; head-\u0026gt;next-\u0026gt;prev = node; head-\u0026gt;next = node; } }; ","date":"2024-11-18T17:06:55+08:00","permalink":"http://www.alvincat.top/post/data_structure/hash_table/lru/","tags":["哈希表","单向链表","双向链表"],"title":"LRU的C代码实现"},{"categories":["Linux"],"contents":"本文主要记录c语言编码过程中的一些注意事项。\n1 C语言编码注意事项 1.1 申请的动态内存一定要做初始化工作 例如：如下所示的代码，若未对table-\u0026gt;bucket指针数组赋初值，该数组中就有可能存在非法值，导致代码访问到非法内存。\n1 2 3 4 5 6 7 8 9 10 11 12 int initHashTable(HashTable* table, int bucket_num) { table-\u0026gt;bucket_num = bucket_num; table-\u0026gt;bucket = (HashNode**)malloc(sizeof(HashNode*) * bucket_num); if (table-\u0026gt;bucket == NULL) { printf(\u0026#34;Alloc memory failed.\\n\u0026#34;); return -1; } // 此处一定要做初始化工作，否则可能存在非法内存访问的情况 memset(table-\u0026gt;bucket, 0, sizeof(HashNode*) * bucket_num); return 0; } 1.2 对结构体变量初始化时，需要初始化所有的变量 实例如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 struct ListNode { int val; struct ListNode *next; }; ListNode* initNode(int val) { ListNode* node = (ListNode*)malloc(sizeof(ListNode)); if (node == NULL) { return NULL; } node-\u0026gt;val = val; // 注意此处一定要初始化，否则有可能访问到非法内存 node-\u0026gt;next = NULL; } 1.3 c语言初始化数组的方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 //Unless that value is 0 (in which case you can omit some part of the initializer and //the corresponding elements will be initialized to 0), there\u0026#39;s no easy way. //Don\u0026#39;t overlook the obvious solution, though: int myArray[10] = { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 }; //Elements with missing values will be initialized to 0: // initialize to 1,2,0,0,0... int myArray[10] = { 1, 2 }; //So this will initialize all elements to 0: int myArray[10] = { 0 }; // all elements 0 //In C++, an empty initialization list will also initialize every element to 0. This is not allowed with C: int myArray[10] = {}; // all elements 0 in C++ //Remember that objects with static storage duration will initialize to 0 if no initializer is specified: static int myArray[10]; // all elements 0 1.4 字符数组初始化的方法 1 2 3 4 5 6 7 8 9 //If you don\u0026#39;t want to change the strings, then you could simply do const char *a[2]; a[0] = \u0026#34;blah\u0026#34;; a[1] = \u0026#34;hmm\u0026#34;; //If you do want to be able to change the actual string content, the you have to do something like char a[2][14]; strcpy(a[0], \u0026#34;blah\u0026#34;); strcpy(a[1], \u0026#34;hmm\u0026#34;); 1.5 16进制字符串转换为整数字符串 1 2 3 4 5 char str[] = \u0026#34;0x1800785\u0026#34;; int num; sscanf(str, \u0026#34;%x\u0026#34;, \u0026amp;num); printf(\u0026#34;0x%x %i\\n\u0026#34;, num, num); 1.6 typedef用法 1 2 3 4 5 6 7 // typedef existing_name alias_name; typedef unsigned int UINT; typedef struct Node { int val; struct Node* next; } Node; 2 C语言中和指针相关知识 2.1 与指针有关的函数声明 1 2 3 4 5 6 7 8 //声明返回指针数组的函数 int (*func(int i))[10]; //声明一个指向函数的指针(pf) bool (*pf)(const string \u0026amp;, const string \u0026amp;); //声明一个名字为pf的函数，该函数返回bool* bool *pf(cosnt string\u0026amp;, const string \u0026amp;); //声明一个返回函数指针的函数 int (*f1(int))(int *, int); 2.2 与指针有关的数组声明 指针数组：array of pointers，即用于存储指针的数组,也就是数组元素都是指针\n数组指针：a pointer to an array，即指向数组的指针\n例如： int* a[4] 指针数组\n表示：数组a中的元素都为int型指针\n元素表示： *a[i]和*(a[i])是一样的，因为[]优先级高于*\nint (*a)[4] 数组指针 表示：指向数组a的指针 元素表示：(*a)[i] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 int main(){ int c[4]={1,2,3,4}; int *a[4]; //指针数组 int (*b)[4]; //数组指针 b=\u0026amp;c; //将数组c中元素赋给数组a for(int i=0;i\u0026lt;4;i++){ a[i]=\u0026amp;c[i]; } //输出看下结果 cout\u0026lt;\u0026lt;*a[1]\u0026lt;\u0026lt;endl; //输出2就对 cout\u0026lt;\u0026lt;(*b)[2]\u0026lt;\u0026lt;endl; //输出3就对 return 0; } 2.3 数组名和指针的区别 2.3.1 数组名不是指针 验证程序：\n1 2 3 int data[10]; cout \u0026lt;\u0026lt; sizeof(data) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; data \u0026lt;\u0026lt; \u0026amp;data \u0026lt;\u0026lt; endl; 说明：第一行的输出结果为40，说明data不是一个指针，编译器将data当作一个数组来处理。此处data为包含10个整型元素的数组。\n2.3.2 数组名作为常量指针 数组名可以转换为指向其指代实体的指针，而且是一个指针常量。该指针指向数组的第一个元素。\n验证程序：\n1 2 3 4 5 6 char str1[10] = \u0026#34;I Love U\u0026#34;; str1++;\t//该语句编译时会出错，因为str1是常量 strcpy(str2, str1);\t//标记2 cout \u0026lt;\u0026lt; \u0026#34;string array 1: \u0026#34; \u0026lt;\u0026lt; str1 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;string array 2: \u0026#34; \u0026lt;\u0026lt; str2 \u0026lt;\u0026lt; endl; 说明：标准C库函数strcpy的函数原形中能接纳的两个参数都为char型指针，而我们在调用中传给它的却是两个数组名。\n2.3.3 指向数组的指针 指向数组的指针则是另外一种变量类型(在32平台下，长度为4），仅仅意味着数组的存放地址。\n验证程序：\n1 2 3 char str1[10] = \u0026#34;I Love U\u0026#34;; char *pStr = str; //标记1 cout \u0026lt;\u0026lt; sizeof(pStr) \u0026lt;\u0026lt; endl; 2.3.4 数组名当作函数实参 数组名在当作实参传入函数内部时，失去数组名的特性，成为普通的指针。\n1 2 3 4 5 6 7 8 9 10 #include \u0026lt;iostream\u0026gt; void arrayTest(char str[]){ cout \u0026lt;\u0026lt; sizeof(str) \u0026lt;\u0026lt; endl; } int main() { char str1[10] = \u0026#34;I Love U\u0026#34;; arrayTest(str1); return 0; } 说明：程序的输出结果为4。\n(1) 数组名作为函数形参时，在函数体内，其失去了本身的内涵，仅仅只是一个指针；\n(2) 很遗憾，在失去其内涵的同时，它还失去了其常量特性，可以作自增、自减等操作，可以被修改。\n3 glibc源码阅读 3.1 实用gdb阅读glibc接口的方法 将glibc源码下载到本地，并解压。 在gdb中添加glibc源码路径； 方法1：在.gdbinit文件中添加命令directory glibc_src_path 方法2：gdb调试二进制时，增加-d参数:-d directory 3.2 理解glibc的简单方法：使用musl libc库 musl libc库实现了和glibc一样的功能，但是代码更简洁易懂。\n可以通过阅读这个代码理解glibc中接口是如何实现的。\nmusl libc库网址\n","date":"2024-11-17T21:39:06+08:00","permalink":"http://www.alvincat.top/post/linux/c_language_usful_tips/","tags":["c语言"],"title":"c语言基础和编码注意事项"},{"categories":["数据结构"],"contents":"本文介绍哈希表的基本特性和具体实现。\n1 哈希表的基本特性 哈希表产生的背景：因为数组的数组的查找复杂度为$O(n)$, 为了\n2 哈希表(拉链法)的c语言实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;assert.h\u0026gt; #define FREE(ptr) \\ free(ptr); \\ ptr = NULL; typedef int KEY; typedef int VALUE; // hashTable的结点定义 struct HashNode { KEY key; VALUE value; struct HashNode* next; }; typedef struct HashNode HashNode; // hashTable的定义 struct HashTable { int (*initHashTable)(struct HashTable* table, int bucket_num); // init function void (*destroyHashTable)(struct HashTable* table); // destroy function int (*hashFunc)(struct HashTable* table, KEY key); // hash function HashNode* (*find)(struct HashTable* table, KEY key); // find function void (*insertHashNode)(struct HashTable* table, HashNode* node); // insert function HashNode** bucket; // bucket array int bucket_num; // bucket num }; typedef struct HashTable HashTable; int initHashTable(HashTable* table, int bucket_num) { table-\u0026gt;bucket_num = bucket_num; table-\u0026gt;bucket = (HashNode**)malloc(sizeof(HashNode*) * bucket_num); if (table-\u0026gt;bucket == NULL) { printf(\u0026#34;Alloc memory failed.\\n\u0026#34;); return -1; } memset(table-\u0026gt;bucket, 0, sizeof(HashNode*) * bucket_num); return 0; } HashNode* findLinkListNode(HashNode* head, KEY key) { if (head == NULL) { return NULL; } while (head) { if (head-\u0026gt;key == key) { return head; } head = head-\u0026gt;next; } return NULL; } void destroyLinkList(HashNode* head) { if (head == NULL) { return; } HashNode* cur = head-\u0026gt;next; while (cur) { HashNode* prev = cur-\u0026gt;next; head-\u0026gt;next = prev; FREE(cur); cur = head-\u0026gt;next; } } void destroyHashTable(HashTable* table) { int num = table-\u0026gt;bucket_num; HashNode** arr = table-\u0026gt;bucket; for (int i = 0; i \u0026lt; num; ++i) { if (arr[i]) { destroyLinkList(arr[i]); } } FREE(arr); FREE(table); } int hashFunc(HashTable* table, KEY key) { return key % table-\u0026gt;bucket_num; } HashNode* findHashNode(HashTable* table, KEY key) { int index = table-\u0026gt;hashFunc(table, key); assert(index \u0026gt;= 0 \u0026amp;\u0026amp; index \u0026lt; table-\u0026gt;bucket_num); return findLinkListNode(table-\u0026gt;bucket[index], key); } void insertHashNode(HashTable* table, HashNode* node) { if (node == NULL) { return; } int index = table-\u0026gt;hashFunc(table, node-\u0026gt;key); assert(index \u0026gt;= 0 \u0026amp;\u0026amp; index \u0026lt; table-\u0026gt;bucket_num); HashNode* head = table-\u0026gt;bucket[index]; if (head) { HashNode* prev = head-\u0026gt;next; node-\u0026gt;next = prev; head-\u0026gt;next = node; } else { table-\u0026gt;bucket[index] = node; } } HashTable* InitializeHashTable(void) { HashTable* table = (HashTable*)malloc(sizeof(HashTable)); if (table == NULL) { printf(\u0026#34;Melloc memory failed.\\n\u0026#34;); return NULL; } memset(table, 0, sizeof(HashTable)); table-\u0026gt;initHashTable = initHashTable; table-\u0026gt;destroyHashTable = destroyHashTable; table-\u0026gt;hashFunc = hashFunc; table-\u0026gt;findHashNode = findHashNode; table-\u0026gt;insertHashNode = insertHashNode; return table; } HashNode* initHashNode(KEY key, VALUE value) { HashNode* node = (HashNode*)malloc(sizeof(HashNode)); if (node == NULL) { printf(\u0026#34;Melloc memory failed.\\n\u0026#34;); return NULL; } node-\u0026gt;key = key; node-\u0026gt;value = value; node-\u0026gt;next = NULL; return node; } 3 哈希函数 针对key为整数的情况，直接使用对桶大小取余的方式就可以。但是针对复杂的key，例如key为一个链表结点的地址，就需要更加复杂的哈希函数。以下是针对复杂的key的哈希算法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 size_t _Hash_bytes(const void* ptr, size_t len, size_t seed) { size_t hash = seed; const uint8_t* cptr = (const uint8_t*)(ptr); for (; len; --len) { hash = (hash * 131) + *cptr++; } return hash; } int hashFunc(HashTable* table, KEY key) { const void* ptr = (const void*)(key); size_t hash = _Hash_bytes(ptr, 2, rand()); return abs(hash) % table-\u0026gt;bucket_num; } ","date":"2024-11-16T22:09:29+08:00","permalink":"http://www.alvincat.top/post/data_structure/hash_table/hash_table/","tags":["哈希表"],"title":"哈希表"},{"categories":["数据结构"],"contents":"本文主要介绍单链表常见的功能函数。\n1 单链表常见功能函数 链表相关的功能有：反转链表，获取链表的长度，获取链表的中间结点，判断两条链表是否相加，判断链表是否有环，合并两个有序链表等。\n1.1 翻转单链表 1.1.1 迭代方式翻转单链表 迭代方式翻转链表也称为链表头插法。\n方法1：新增一个临时头结点 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // 新增额外头结点的 struct ListNode* reverseList(struct ListNode* head) { if (head == NULL || head-\u0026gt;next == NULL) { return head; } struct ListNode* headp = (struct ListNode*)malloc(sizeof(struct ListNode)); headp-\u0026gt;val = 0; headp-\u0026gt;next = NULL; struct ListNode* tail = NULL; struct ListNode* cur = head; while (cur) { struct ListNode* pre = cur-\u0026gt;next; tail = headp-\u0026gt;next; headp-\u0026gt;next = cur; cur-\u0026gt;next = tail; cur = pre; } cur = headp-\u0026gt;next; free(headp); headp = NULL; return cur; } 方法2：不新增头结点，进行翻转 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 struct ListNode* reverseList(struct ListNode* head) { if (head == NULL || head-\u0026gt;next == NULL) { return head; } struct ListNode* cur = head-\u0026gt;next; head-\u0026gt;next = NULL; while (cur) { struct ListNode* pre = cur-\u0026gt;next; cur-\u0026gt;next = head; head = cur; cur = pre; } return head; } 1.1.2 递归方式翻转单链表 递归方式代码比较简单，但是要不太容易理解。递归的关键是抽象出一个通用的模型以及边界条件的处理。\n1 2 3 4 5 6 7 8 9 10 11 12 struct ListNode* reverseList(struct ListNode* head) { if (head == NULL || head-\u0026gt;next == NULL) { return head; } struct ListNode* prev = reverseList(head-\u0026gt;next); head-\u0026gt;next-\u0026gt;next = head; head-\u0026gt;next = NULL; return prev; } 1.2 获取单链表长度 1 2 3 4 5 6 7 8 9 10 11 12 13 14 int GetListNum(struct ListNode* head) { if (head == NULL) { return 0; } int cnt = 0; struct ListNode* tmp = head; while (tmp) { ++cnt; tmp = tmp-\u0026gt;next; } return cnt; } 1.3 获取单链表中间结点 功能说明：\n该函数返回链表中心点的前一个结点，即轴对称的尾结点。 例如，若链表有3个结点，则返回的是第1个结点的地址。若链表有4个结点，则返回的是第二个结点的地址。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 struct ListNode* GetMidNode(struct ListNode* head) { int cnt = GetListNum(head); int i = 0; tmp = head; struct ListNode* cur = NULL; while (i \u0026lt; cnt/2 \u0026amp;\u0026amp; tmp) { cur = tmp; tmp = tmp-\u0026gt;next; ++i; } return cur; } 1.4 判断单链表是否存在环 方法说明：\n方法1：使用hashtable。 方法2：使用快慢指针。具体方法是慢指针每次前进一步，快指针每次前进两步。若链表存在环，则经过若干步后，快指针肯定会追上慢指针，即两个指针指向同一个结点。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 bool hasCycle(struct ListNode *head) { if (head == NULL || head-\u0026gt;next == NULL) { return false; } struct ListNode* slow = head; struct ListNode* fast = head-\u0026gt;next; while (slow != fast) { if (fast == NULL || fast-\u0026gt;next == NULL) { return false; } slow = slow-\u0026gt;next; fast = fast-\u0026gt;next-\u0026gt;next; } return true; } 1.4.1 进阶：获取单链表环的入口结点 方法1：使用hashtable。 方法2：使用快慢指针。 2 链表高级特性 3 C++中的链表","date":"2024-11-16T21:29:14+08:00","permalink":"http://www.alvincat.top/post/data_structure/linklist/link_list_function/","tags":["链表"],"title":"单链表常见功能函数"},{"categories":[],"contents":"","date":"2024-11-16T15:35:21+08:00","permalink":"http://www.alvincat.top/search/","tags":[],"title":"站内搜索结果"},{"categories":["Linux"],"contents":"这篇文章介绍C语言结构体字节对齐的问题。\n1 结构体字节对齐的规则 结构体变量的首地址能够被其最宽基本类型成员的大小所整除；???\n数据类型自身的对齐：例如，在x86_64系统，char型数据自身对齐值为1字节，short型数据为2字节，int/float型为4字节，long/double/void*型为8字节。\n结构体或者类的自身的对齐：其成员中自身对齐值中的最大值。\n指定对齐值的情况下的对齐规则：#pragma pack (value)时的指定对齐值value。指定规则后以指定规则进行对齐。\n使用伪指令#pragma pack(n)：C编译器将按照n个字节对齐； 使用伪指令#pragma pack()： 取消自定义字节对齐方式。 数据成员、结构体和类的有效对齐值：若存在指定对齐值，需要自身对齐值和指定对齐值中较小者，即有效对齐值=min{自身对齐值，当前指定的pack值}。\n2 x86环境各种基本数据类型的字节数 数据类型 x86 x86_64 char 1 1 short 2 2 int 4 4 long 4 8 float 4 4 double 8 8 void* 4 8 3 示例程序 当前的实例程序假定结构体首地址为0。环境关键信息如下：\nArchithecture: x86_64\nGCC version: 4.4.7\n3.1 指定1字节对齐的示例分析 1 2 3 4 5 6 7 8 #pragma pack(1) struct test { char a; // not padding int b; // not pading short c; }; #pragma pack() sizeof(struct test); // 7 字节 说明：\n变量a，char自身对齐值为1, 指定值为1; 两者取小的值为1。首地址为0，变量a是对齐的，因此变量a占用1个字节。此时偏移1字节。\n变量b, int类型自身对齐值为4, 指定值为1，两者取小的偏移值为1。当前偏移1字节，因此变量b前不需要填充，b占用4字节。此时偏移5字节。\n变量c, short类型自身对齐值为2，指定值为1，两者取小的偏移单位为1。当前偏移5字节，因此变量c前也不需要填充，c占用2字节。此时偏移7字节。\n结构体自身的对齐值取最大变量的长度(int)，即4字节。但是指定的长度为1字节，两者取小即可得到整个结构体的对齐单位为1字节。因此，整个结构体占用7字节。\n3.2 指定2字节对齐的示例分析 1 2 3 4 5 6 7 8 #pragma pack(2) struct test { char a; // pading 1Byte int b; // not padding short c; }; #pragma pack() sizeof(struct test); // 8 字节 说明：\n变量a，char自身对齐值为1, 指定值为2; 两者取小的值为1。首地址为0，变量a是对齐的，因此变量a占用1个字节。此时偏移1字节。\n变量b, int类型自身对齐值为4, 指定值为2，两者取小的偏移值为2。当前偏移1字节，因此变量b前需要填充1字节，b占用4字节。此时偏移6字节。\n变量c, short类型自身对齐值为2，指定值为2，两者取小的偏移单位为2。当前偏移6字节，因此变量c前不需要填充，c占用2字节。此时偏移8字节。\n结构体自身的对齐值取最大变量的长度(int)，即4字节。但是指定的长度为2字节，两者取小即可得到整个结构体的对齐单位为2字节。当前偏移长度为8字节，已经是对齐单位整数倍，所以无需填充。因此，整个结构体占用8字节。\n3.3 指定4字节对齐的示例分析 1 2 3 4 5 6 7 8 #pragma pack(4) struct test { char a; int b; short c; }; #pragma pack() sizeof(struct test); // 12字节 说明： 变量a，char自身对齐值为1, 指定值为4; 两者取小的值为1。首地址为0，变量a默认是对齐的，因此变量a占用1个字节，无需填充。当前偏移1字节。\n变量b, int类型自身对齐值为4, 指定值为4，两者取小的偏移值为4。当前偏移1字节，因此变量b前需要填充3字节，b占用4字节。当前偏移8字节。\n变量c, short类型自身对齐值为2，指定值为4，两者取小的偏移单位为2。当前偏移8字节，因此变量c前不需要填充，c占用2字节。当前偏移10字节。\n结构体自身的对齐值取最大变量的长度(int)，即4字节。指定的长度为4字节，两者取小即可得到整个结构体的对齐单位为4字节。当前偏移长度为10字节，不是对齐单位整数倍，所以需要填充2字节。因此，整个结构体占用12字节。\n3.3 指定8字节对齐的示例分析 1 2 3 4 5 6 7 8 #pragma pack(8) struct test { char a; int b; short c; }; #pragma pack() sizeof(struct test); // 12字节 说明： 变量a，char自身对齐值为1, 指定值为8; 两者取小的值为1。首地址为0，变量a默认是对齐的，因此变量a占用1个字节，无需填充。当前偏移1字节。\n变量b, int类型自身对齐值为4, 指定值为8，两者取小的偏移值为4。当前偏移1字节，因此变量b前需要填充3字节，b占用4字节。当前偏移8字节。\n变量c, short类型自身对齐值为2，指定值为8，两者取小的偏移单位为2。当前偏移8字节，因此变量c前不需要填充，c占用2字节。当前偏移10字节。\n结构体自身的对齐值取最大变量的长度(int)，即4字节。指定的长度为8字节，两者取小即可得到整个结构体的对齐单位为4字节。当前偏移长度为10字节，不是对齐单位整数倍，所以需要填充2字节。因此，整个结构体占用12字节。\n3.4 不指定字节，按照默认对齐的示例分析 1 2 3 4 5 6 7 struct test { char a; int b; short c; long d; }; sizeof(struct test); // 24字节 说明： 变量a，char自身对齐值为1; 首地址为0，变量a默认是对齐的，因此变量a占用1个字节，无需填充。当前偏移1字节。\n变量b, int类型自身对齐值为4。当前偏移1字节，因此变量b前需要填充3字节，b占用4字节。当前偏移8字节。\n变量c, short类型自身对齐值为2。当前偏移8字节，因此变量c前不需要填充，c占用2字节。当前偏移10字节。\n变量d, long类型自身对齐值为8。当前偏移10字节，因此变量d前需要填充6个字节，c占用8字节。当前偏移24字节。\n结构体自身的对齐值取最大变量的长度(long)，即8字节。无指定的对齐长度，因此整个结构体的对齐单位为8字节。当前偏移长度为24字节，是对齐单位整数倍，所以不需要填充。因此，整个结构体占用24字节。\n","date":"2024-11-15T22:52:34+08:00","permalink":"http://www.alvincat.top/post/linux/struct_alignment/","tags":["结构体字节对齐"],"title":"C语言结构体字节对齐问题"},{"categories":["数据结构"],"contents":"本文介绍链表的基本特性以及链表常用的操作。\n1 链表的特性 链表是一种链式存储数据的结构。相邻的两个结点之间在物理地址上并不是连续存放的。因此就决定了链表无法进行随机访问，只能按照链接关系进行顺序访问。 只能单向变量的链表称为单链表，可以双向访问的链表称为双向链表。\n2 链表的基本操作 链表的常用操作有：创建链表，链表结点的插入、删除，销毁链表等。\n2.1 链表结点的定义 链表结点的定义是一种递归形式的定义，链表中的指针是链表结点类型的指针。\n1 2 3 4 struct ListNode { int val; struct ListNode *next; }; 2.1 链表的创建 2.2 链表的销毁","date":"2024-11-15T17:52:42+08:00","permalink":"http://www.alvincat.top/post/data_structure/linklist/link_list_introduction/","tags":["链表"],"title":"链表基本特性及其相关操作"},{"categories":["Linux"],"contents":"本文记录Linux常用命令的用法。\n1 linux命令的综合使用 1 2 # 删除出指定文件之外的文件 ls | grep -xvF file.txt | xargs rm -rf -- 2 linux常用命令的使用方法 2.1 tar 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # tar常用的命令参数 # -j 使用bzip处理文件 # -J 使用xz处理文件 # -z 使用gzip处理文件 # -c 压缩文件 # -x 解压文件 # -C 指定操作目录 # -v 显示正在处理的文件 # 示例1. 打包为bz文件 tar -jcvf test.tar.bz ./test/ # 示例2. 解压gz文件 tar -zxvf test.gz 2.2 zip/unzip 1 2 3 4 5 # zip 示例：zip options archive inpath zip -r foo.zip foo # unzip示例： unzip -d dir xxx.zip mkdir output \u0026amp;\u0026amp; unzip -d ./output file.zip ","date":"2024-11-15T17:13:30+08:00","permalink":"http://www.alvincat.top/post/linux/linux_common_tools/","tags":["Linux常用命令"],"title":"Linux常用命令的用法"},{"categories":["算法"],"contents":"本文记录字符串匹配算法的演进已经具体实现。\n字符串匹配算法(String Search Algorigthm) 一点说明：\n原串：即子串匹配过程中， 待查找的字符串；\n搜索串：即用来匹配的特定的一个子串。\n1 KMP算法 (The Knuth-Morris-Pratt Algorithm) 优点：在暴力解法的基础上，减少匹配过程中查找字符串比较次数。\n缺点：当待查找的字符串没有重复搜索串时，算法退化为暴力解法。\n算法中的概念：\n局部匹配表(partial match table):查找过程中的子串中真前缀和真后缀的最大公共长度。\n字符串的真前缀(proper prefix)：例如 “S”, “Sn”, “Sna”, 和 “Snap” 都是 “Snape”的proper prefix。\n字符串的真后缀(proper suffix)：例如“d”,“agrid”, “grid”, “rid”, “id”和 都是“Hagrid”的proper suffix。\n计算局部匹配表(partial math table) 局部匹配表有时也称为next数组。该表是由子串的内容决定的。计算过程如下(以下过程以字符串\u0026quot;abababca\u0026quot;为例)：\n字符串长度为1时，字符串为\u0026quot;a\u0026quot;。因此对应表项为0。\n字符串长度为2时，字符串为“ab”，proper prefix包含“a”；proper suffix包含“b”，因此对应表项为0。\n字符串长度为3时，字符串为“aba”，proper prefix包含“a”, “ab”； proper suffix包含“a”,“ba”，因此对应表项为1。\n字符串长度为4时，字符串为“abab”，proper prefix包含“a”, “ab”,“aba”；proper suffix包含“b”，“ab”，“bab”，因此对应表项为2。\n字符串长度为5时，字符串为“ababa”，proper prefix包含“a”, “ab”,“aba”,“abab”；proper suffix包含“a”，“ba”，“aba”，“baba”，因此对应表项为3。\n字符串长度为6时，字符串为“ababab”，proper prefix包含“a”, “ab”,“aba”,“abab”,“ababa”；proper suffix包含“b”，“ab”，“bab”，“abab”,，因此对应表项为3。\n使用局部匹配表进行字符串匹配 设局部匹配表为table。如果存在部分匹配值partial_match_length，而且table[partial_match_length] \u0026gt; 1，则子串可以跳过的长度为：partial_match_length - table[partial_match_length - 1] 。例如：\n第一次匹配情况，如下图所示：\n该匹配中部分匹配长度(partial_match_length)为1。而对应的值table[partial_match_length - 1]即table[0]等于0。因此我们不需要跳过任何字母。 接下来的匹配情况如下图所示：\n该匹配中部分匹配长度为(partial_match_length)为5。这个值对应的table[partial_match_length - 1](即table[4])值为3。这意味着partial_match_length - table[partial_match_length - 1](即5 - talbe[4]，即5-3，即2)。即子串向右移动2个字符。如图所示：\n移动后的匹配情况如上图所示，匹配成功长度(partial_match_length)为3。对应的table[partial_match_length - 1](即table[2])值为1。意味着我们向后移动长度为：partial_match_length - table[partial_match_length - 1](即3 - table[2] = 3 - 1 = 2)。移动后的结果如图所示：\n因子串尾部以超过原串长度，因此结束匹配。\n2 BM算法 (Boyer-Moore Algorithm) 1977年，德克萨斯大学的Robert S. Boyer教授和J Strother Moore教授发明了这种算法。因此取这两个人的名字而得。word中的查找功能就是使用该算法。\n算法中的概念：\n坏字符(bad character)：字符串匹配过程中，与搜索串不匹配的字符。 好后缀(good suffix): 即搜索串与原串尾部能够匹配的字符串。 坏字符实例，如下图: 好后缀实例，如下图：\n比较规则：首先，将搜索串与原串对齐，从搜索串尾部从后往前比较。\n坏字符移动规则: 后移位数 = 坏字符的位置 - 搜索词中的上一次出现位置。说明，若搜索串中不包含坏字符，则搜索串上一次出现位置为-1。若包含该字符，则为离坏字符位置最近的那个位置。\n好后缀规则 :后移位数 = 好后缀的位置 - 搜索词中的上一次出现位置。好后缀位置以后缀最后一个位置为准。说明，若搜索串中不包含坏字符，则搜索串上一次出现位置为-1。例如：\n如果字符串\u0026quot;ABCDAB\u0026quot;的后一个\u0026quot;AB\u0026quot;是\u0026quot;好后缀\u0026quot;。那么它的位置是5（从0开始计算，取最后的\u0026quot;B\u0026quot;的值），在\u0026quot;搜索词中的上一次出现位置\u0026quot;是1（第一个\u0026quot;B\u0026quot;的位置），所以后移 5 - 1 = 4位，前一个\u0026quot;AB\u0026quot;移到后一个\u0026quot;AB\u0026quot;的位置。 如果字符串\u0026quot;ABCDEF\u0026quot;的\u0026quot;EF\u0026quot;是好后缀，则\u0026quot;EF\u0026quot;的位置是5 ，上一次出现的位置是 -1（即未出现），所以后移 5 - (-1) = 6位，即整个字符串移到\u0026quot;F\u0026quot;的后一位。 注意：\n以上两个规则的中的位置指的是搜索串中的位置。 当通过坏字符规则和好后缀移动规则得到的值不同时，取较大的值作为移动量。 下面以字符串为\u0026quot;HERE IS A SIMPLE EXAMPLE\u0026quot;，搜索词为\u0026quot;EXAMPLE\u0026quot;为例，进行说明：\nstep1：\n首先遇到坏字符，计算移动位置：6 - (-1) = 7. step2:\n遇到坏字符，计算移动位置：6 - 4 = 2.\nstep3:\n遇到好后缀，计算移动位置：6 - 0 = 6。\nstep4:\n坏字符和好后缀的选择问题：\n坏字符的结果：\n后后缀的结果：\nstep5:\n3 Sunday算法(Sunday Algorigthm) sunday算法是对BM算法的改进。改进之处：当匹配失败时，判断搜索串下次匹配位置的第一个字符是否与搜索串第一个字符是否相同。进而减少匹配次数。\n","date":"2024-11-15T16:01:16+08:00","permalink":"http://www.alvincat.top/post/algorithm/string_match_algorightm/","tags":["字符串匹配"],"title":"字符串匹配算法"},{"categories":["环境搭建"],"contents":"Hugo中一些实用的配置。\n1 设置网站的页面宽度 在文件themes\\even\\assets\\sass\\_variables.scss中找到配置项$global-body-width，默认值为800。\n调整这个值就可以改变网站中页面的宽度。\n2 Hugo中使用图片的方法 在根目录static目录下创建目录放置图片即可。在markdown文件中按照形如/image/logo.png的方式进行引用即可。\n3 修改Hugo even主题主页的字体 将文件themes\\even\\assets\\sass\\_partial\\_header\\_logo.scss 中.logo的font-family属性按照如下形式修改即可：\n1 2 3 4 .logo { font-size: $logo-font-size; font-family: $global-serif-font-family; } 4 修改网站的语言 修改方法：修改网站工程根目录的config.toml文件，将defaultContentLanguage属性改为zh-cn 即可。切换后会使用theme主题i18n目录下对应的yaml文件。\n5 添加站内搜索功能 我自己的修改：\n源码仓：git@github.com:alvincat/MyGithubWebsite.git/master: 5f7a66cfe4e0a6cb94f33518297828c894e431b4\n模板仓：git@github.com:alvincat/HugoThemeEven.git/master: 088afb3d0cc34329a64b4e596a54e3e2af0c634b\n主要参考文档：\n给Hugo中的Even主题添加搜索功能 - 飞狐的部落格\n其他参考文档：\n给hugo添加搜索功能 | 搜百谷\nSuper fast, keyboard-optimized, client side Hugo search\n6 将页面置顶 若需要在主页将某个页面置顶，只需要在页面对应的md文件的文件头中添加weight: 1即可。 weight:1表示将该页面放在第1的位置，若需要将某个页面放在第二个位置，在源文件的头部添加weight:2即可。\n7 使用自己的域名的方法 7.1 注册域名 可以在namesilo网站购买个人域名。在网站首页输入自己想要的域名，可以查看是否被占用以及购买的价格。\n参考文档：购买个人域名方法\n7.2 关联github webpage 关联github page的方法参考文档： How To Add a Custom Domain To a GitHub Pages Site 使用自定义域名来访问GitHub上部署的hugo博客(GitHub Pages)\n温馨提示：\n在namesilo的【DNS管理】中，若点击\u0026quot;CNAME\u0026quot;，提示\u0026quot;WWW\u0026quot;已被占用，可以将已经存在\u0026quot;www\u0026quot;的标签删除，新建即可。\n","date":"2024-11-14T23:34:32+08:00","permalink":"http://www.alvincat.top/post/hugo/hugo_some_usful_setting/","tags":["Hugo"],"title":"Hugo中一些实用的配置"},{"categories":["Tools"],"contents":"本文记录Git常用命令。\n1 Git常用命令 1.1 查询命令 1 2 3 4 5 git status # 查看当前git状态 git log # 查询修改记录 git tag -l # 查询tag # git log精简模式显示指定信息 git log --pretty=format:\u0026#34;%h,%an,%aI,%s\u0026#34; | head 1.2 代码下载上传 1 2 3 4 5 6 7 8 # down load source code git clone -b main git@github.com:alvincat/MyGithubWebsite.git MyWebsite # recurse update submodule git submodule update --init --recursive git push git pull git push --set-upstream origin gh_pages # upload new branch 1.3 分支相关操作 1 2 3 4 5 6 git branch # 查看本地所有分支 git branch | grep \u0026#34;*\u0026#34; #查看当前分支 git checkout branch_name # 切换分支 git checkout -b gh_pages # create branch git branch -D gh_pages # 删除本地分支 git push origin --delete main # 删除远端分支 1.4 修改相关操作 1 2 3 4 5 6 7 8 9 10 11 git commit -m \u0026#34;\u0026#34; # add commit git add file1 file2 # add to local cache git stash # 暂存当前修改 git stash pop # 恢复暂存内容 git reset --hard origin/master # 强制更新当前分支代码为master分支 git reset --mixed commit_id # 将制定commit_id以后的提交回退至未提交 git rebase -i head~2 git cherry-pick commit_id 1.5 远程仓库操作 1 2 3 4 5 6 7 8 9 10 11 12 # 查询本地关联的代码仓 git remote -v # 添加远程分支, 其中origin为远程代码仓在本地的name, 本地代码可以关联多个远程代码仓 git remote origin https://github.com/olOwOlo/hugo-theme-even git remote add myEvenBackup git@github.com:alvincat/HugoThemeEven.git # 提交代码时可以指定代码仓进行 # 提交代码至https://github.com/olOwOlo/hugo-theme-even的master分支 git push -u origin master # 提交代码至git@github.com:alvincat/HugoThemeEven.git的master分支 git push -u myEvenBackup master 2 Git相关配置 2.1 Git添加ssh公钥 设置用户名和邮箱 1 2 3 4 5 6 7 8 9 10 11 12 # 设置用户名 git config --global user.name \u0026#34;username\u0026#34; # 设置邮箱 git config --global user.email your_email@example.com # 查看用户名和密码 git config user.name git config user.email # 查看其他配置信息(git设置列表) git config --list 执行命令生成ssh公钥和私钥 windows环境 1 2 # 使用Ed25519加密算法生成公钥和私钥 ssh-keygen -t ed25519 -C \u0026#34;your_email@example.com\u0026#34; Linux或者MacOS环境 1 2 # 使用Ed25519加密算法生成公钥和私钥 ssh-keygen -t ed25519-sk -C \u0026#34;your_email@example.com\u0026#34; 将生成的公钥文件id_ed25519.pub中的内容添加至github即可使用ssh上传下载代码。 温馨提示：\n若添加公钥后，提交代码提示错误：push declined due to email privacy restrictions\n原因：将github关联的email设置为私密，对外不可见。\n解决方法：\n方法1：进入https://github.com/settings/emails页面，将【Block command line pushes that expose my email】勾选去掉。 方法2：使用github提供的转换邮件地址。(在标签【Keep my email addresses private】的内容中提供，形如：12345678+username@users.noreply.github.com)。使用这个邮件地址更新密钥即可。 2.2 gitignore的用法 git在提交代码时，存在部分本地生成的和代码无关的文件，不需要提交。这种文件或者目录就需要使用gitignore的机制进行过滤。使用方法如下：\n在代码根目录创建文件.gitignore 在文件中添加需要过滤的文件和目录，注意若要过滤整个目录，需要在目录后跟/ 常见情况解决方法：\n添加到.gitignore文件中的目录，再次提交后并未生效。解决方法，执行代码：git rm -r --cached \u0026lt;folder\u0026gt; ","date":"2024-11-14T17:13:30+08:00","permalink":"http://www.alvincat.top/post/tools/git_commond/","tags":["Git"],"title":"Git常用命令"},{"categories":["环境搭建"],"contents":"本文记录Hugo配置github静态页面的关键步骤。\n1 Hugo简介 Hugo是由Go语言实现的静态网站生成器。简单、易用、高效、易扩展、快速部署。\nHugo官网：Hugo官网\nHugo的官方文档：Hugo中文文档\n2 使用Hugo发布静态网站的准备工作 2.1 下载安装部署网站工具 2.1.1 下载安装git Git下载地址：Download Git\nWindows下安装方法：运行二进制程序，然后按照提示操作即可。\n2.1.2 下载安装go 官方下载地址：Download and install - The Go Programming Language\nGo语言中文网下载地址：Go语言中文网下载地址\n我下载的go版本是：go1.17.3\n安装配置完成后，使用命令go version 查看版本号。\n温馨提示：若下载的是免安装版本，需要手动配置环境变量，否则无法使用。\n2.1.3 下载安装hugo-extend Hugo v0.138.0下载地址： Hugo v0.138.0下载地址\n我下载的是：hugo_extended_withdeploy_0.138.0_windows-amd64.zip\n安装配置完成后，使用命令hugo version 查看版本号。\n温馨提示：若下载的是免安装版本，需要手动配置环境变量，否则无法使用。\n2.2 创建代码仓 在github创建私有库MyGithubWebsite: 用于存放网站工程源码 在github创建公共代码username.github.io: 用于保存网站内容。\ngithub规定必须将网站内容放在形如username.github.io的代码仓中，此处的username为你的github的用户名。 2.3 下载代码 1 git clone git@github.com:alvincat/MyGithubWebsite.git MyWebsite 2.4 初始化网站 1 2 # 在网站根目录的上层目录执行命令，MyWebsite为网站工程根目录名 hugo new site MyWebsite --force 2.5 Hugo使用even模板 2.5.1 下载even模板 1 2 # 进入根目录，执行命令下载网站模板 git clone https://github.com/olOwOlo/hugo-theme-even themes/even 2.5.2 even模板配置 在even主题的 exampleSite 目录下有一个 config.toml 文件，将这个 config.toml 文件复制到你的站点根目录下，根据自己的需求更改即可。\n为了定制 favicon，你需要在站点根目录的 static 文件夹下放置下述所有文件，这将覆盖 themes/even/static/ 文件夹下的那些文件。\nandroid-chrome-192x192.png android-chrome-512x512.png apple-touch-icon.png browserconfig.xml favicon.ico favicon-16x16.png favicon-32x32.png manifest.json mstile-150x150.png safari-pinned-tab.svg 2.5.3 even文章模板配置 你可以通过 front-matter 针对每一篇文章单独进行设置。themes/even/archetypes/default.md 文件陈列了所有可用的参数。\n将该文件复制到站点根目录的 archetypes 文件夹下将会有所帮助。\n3 使用Hugo撰写博客 3.1 使用hugo创建文件 1 hugo new post/hello.md 注意:\n对于even这个主题，你应该使用 post 而不是 posts，即 hugo new post/some-content.md 建议使用hugo new命令来新建文件，而不要直接在post目录下创建文件。 3.2 hugo本地调试博客文章 1 hugo server -D 登陆浏览器查看结果：localhost\n3.3 发布网站 在站点根目录执行 以下Hugo 命令生成最终页面：\n1 hugo -D --baseURL=\u0026#34;https://alvincat.github.io/\u0026#34; 执行这条命令，就会在public目录下生成最终网站内容。\n将public的内容推送到username.github.io仓库，就可以访问网站了\n3.4 创建.gitignore文件，忽略部分文件 3.5 本地调试完成后，提交代码至github 1 2 3 git add file git commit -m \u0026#34;add file\u0026#34; git push 温馨提示：\n在本地调试完成提交前，建议先将public目录下的内容清空，重新编译后再提交，以免public目录存在修改的残留文件。\n4 使用github actions功能自动发布网站的方法 4.1 创建personal access token 按照setting -\u0026gt; Developer Settings -\u0026gt; Personal access tokens的顺序打开创建token界面。如下图所示。 按照Tokens(classic) -\u0026gt; Generate new token -\u0026gt; Generate new token(classic)的顺序创建token。如下图所示： 在创建token的界面勾选【workflow]按钮。如下图所示： 点击创建后，就会生成一串token编码。此时需要复制这串编码，后面添加的时候需要使用。 4.2 添加secrets 进入网站工程的setting界面，如下图所示： 进入添加secret界面，填写secretname和步骤5.1生成的token。(注意： 此处的secret name后续在配置文件中会用到。）如下图所示： 添加完成后就会提示添加成功。如下图所示：\n4.3 添加active自动化配置文件 在网站工程根目录创建目录.github/workflows/，然后再该目录下创建一个yml文件，文件名自定。此处文件名为hugo.yml。文件内容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 name: GitHub Pages on: push: branches: - master # 博客工程根目录的默认分支，我的是master，请以实际为准 jobs: deploy: runs-on: ubuntu-latest concurrency: group: ${{ github.workflow }}-${{ github.ref }} steps: - uses: actions/checkout@v2 with: submodules: false fetch-depth: 0 - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#39;latest\u0026#39; extended: true # 如果你使用的不是extended版本的hugo，将true改为false - name: Build run: hugo --minify - name: Deploy uses: peaceiris/actions-gh-pages@v3 if: ${{ github.ref == \u0026#39;refs/heads/master\u0026#39; }} # 博客工程根目录的默认分支，我的是master，请以实际为准 with: personal_token: ${{ secrets.YOUR_SECRET}} # 如果secret取了其他名称，将YOUR_SECRET替换掉 external_repository: alvincat/alvincat.github.io # 填写远程仓库，名字 publish_dir: ./public #cname: www.example.com # 填写你的自定义域名。如果没有用自定义域名，注释掉这行 该配置文件的作用就是当私有库MyGithubWebsite的master分支代码提交后，将public目录的内容推送到username.github.io的gh-pages分支。可以通过查看MyGithubWebsite的action页面确认，该配置是否生效。 如下图所示： 其实该功能也可以手动完成，当本地调试完成后，将public的内容推送到username.github.io的gh-pages分支。\n1 2 3 4 5 6 cd public git init git remote add origin git@github.com:alvincat/alvincat.github.io.git git add . git commit -m \u0026#39;add blog\u0026#39; git push origin gh-pages 4.4 修改username.github.io代码仓的page页面关联分支 当步骤5.4更新成功后，就会将生成的网站内容推送到username.github.io代码仓的gh-pages分支。因此需要将username.github.io代码仓的page关联分支切换为gh-pages。\n修改方法如下：\n5 优化方案 步骤4中的方案有个问题是：需要在两个代码仓中均存放public目录中的文件（好处是可以自动更新网站内容）。\n只保存一份public文件的方法：\n忽略源代码仓的public文件夹：即提交源代码仓中的修改时不提交public目录下的文件。 将public文件夹和username.github.io代码仓关联。 需要更新网站时，只需要将public目录中的内容push到username.github.io远程代码仓即可。 1 2 3 4 5 6 git init # 初始化git目录 git remote add webPage git@github.com:alvincat/alvincat.github.io.git # 关联远端代码仓 git fetch webPage # 更新代码 git checkout -b master # 创建本地分支 git pull webPage master # pull远端代码 git push -u webPage master # 提交代码 6 参考文献 将Hugo静态网站部署到Github Pages\nHugo + even + GitHub Pages+ Utterances搭建个人博客\n利用GitHub Action实现Hugo博客在GitHub Pages自动部署\nHugo + GitHub Action，搭建你的博客自动发布系统\n","date":"2024-11-14T16:51:30+08:00","permalink":"http://www.alvincat.top/post/hugo/hugo_build_static_page/","tags":["Hugo"],"title":"Hugo配置github静态页面的方法"},{"categories":[],"contents":"关于我的详细信息。\n个人信息 Name : alvincat 个人爱好 联系我 \u0026#x1f4e7; : alvincat@126.com Github: https://github.com/alvincat 友情链接","date":"2024-11-14T11:16:25+08:00","permalink":"http://www.alvincat.top/about/","tags":[],"title":"关于我"},{"categories":[""],"contents":"该页面为C++的导航页。\nC C语言常用功能\nC++ C++易混淆知识点\nC++中部分关键字的用法\nC++面向对象基础知识\nC++常用功能汇总\nC++常用库函数的用法\nC++ sring的用法\nC++ STL的用法\nC++ vector的内部实现和用法\nC++新特性\nC++ 算法库 Sort操作函数的使用方法\n","date":"2024-11-13T18:26:40+08:00","permalink":"http://www.alvincat.top/index/content_cpp/","tags":[""],"title":"C++导航页"},{"categories":[""],"contents":"该页面为工具使用的导航页。\n工具 程序员入门必读\nGit常用命令\nVim常用设置以及常用命令\nGDB常用命令\nGDB打印STL中各种容器的内容的方法\nGCC常用编译命令和库函数\nMarkdown使用技巧\nQT入门文档\n网络工具使用方法\n","date":"2024-11-13T18:25:40+08:00","permalink":"http://www.alvincat.top/index/content_tools/","tags":[""],"title":"工具使用导航页"},{"categories":[""],"contents":"该页面为杂项的导航页。\n杂项 音乐\n","date":"2024-11-13T18:25:40+08:00","permalink":"http://www.alvincat.top/index/content_others/","tags":[""],"title":"杂项导航页"},{"categories":[""],"contents":"该页为的操作系统导航页。\n操作系统 环境配置 Ubuntu环境配置\n树莓派系统的初始化\n内核相关 Kernel_boot_process\n","date":"2024-11-13T17:57:26+08:00","permalink":"http://www.alvincat.top/index/content_os/","tags":[""],"title":"操作系统导航页"},{"categories":[""],"contents":"该页为的环境搭建导航页。\n环境搭建 Hugo配置github静态页面的方法\nHugo中一些实用的配置\n","date":"2024-11-13T16:58:15+08:00","permalink":"http://www.alvincat.top/index/content_environment_deploy/","tags":[""],"title":"环境搭建导航页"},{"categories":[""],"contents":"该页为的Linux相关内容的导航页。\nLinux C语言结构体字节对齐问题\nc语言编码注意事项\nLinux常用命令的用法\nLinux系统常用的系统配置\n并发编程中常见的问题\nLinux系统中进程打印堆栈的原理\nLinux系统中钩子的使用方法\nCSAPP 信息的处理与表示\nAPUE UNIX标准\n进程环境\n信号\n线程\n线程同步的方法\n进程同步的方法\n内存映射\n进程间通信的方法\nNginx Nginx源码结构简介\n","date":"2024-11-13T16:57:51+08:00","permalink":"http://www.alvincat.top/index/content_linux/","tags":[""],"title":"Linux相关内容的导航页"},{"categories":[""],"contents":"该页为数据结构的导航页。\n1 数据结构 1.1 线性结构 1.1.1 数组 1.1.1.1 数组 1.1.1.2 字符串 1.1.1.4 矩阵 1.1.2 链表 1.1.2.1 单向链表 单链表常见功能函数\n链表基本特性及其相关操作\n1.1.2.2 双向链表 1.1.3 栈 1.1.3.1 栈的原理和实现 1.1.3.1.1 栈的原理 1.1.3.1.2 栈的具体实现 C语言实现栈的方法\n1.1.3.2 单调栈 1.1.4 队列 1.1.4.1 队列的原理和实现 1.1.4.1.1 队列的原理 1.1.4.1.2 队列的实现 C语言实现一个队列的方法\n1.1.4.3 单调队列 1.1.4.3 优先级队列(堆) 1.2 哈希表 1.2.1 哈希表 哈希表的原理和实现\n1.2.2 LRU LRU的原理和实现\n1.2.3 LFU 1.3 树 1.3.1 树 1.3.2 二叉树 创建二叉树的方法\n二叉树的遍历方法\n1.3.3 二叉搜索树 1.3.3.1 BST 1.3.3.2 红黑树 1.3.4 字典树 1.3.5 线段树 1.3.6 树状数组 TrieTree\n1.4 图 1.4.01 图论基础 1.4.02 最短路径 1.4.03 并查集 1.4.04 拓扑排序 拓扑排序的原理和代码实现\n1.4.05 最小生成树 1.4.06 强连通分量 1.4.07 双连通分量 1.4.08 欧拉回路 1.5 有序集合","date":"2024-11-13T16:56:59+08:00","permalink":"http://www.alvincat.top/index/content_data_structure/","tags":[""],"title":"数据结构导航页"},{"categories":[""],"contents":"该页为算法的导航页。\n1 排序 1.1 交换类排序 1.1.1 冒泡排序 1.1.2 快速排序 1.2 选择类排序 1.2.1 选择排序 1.2.2 堆排序 堆排序的原理和实现\n1.3 插入类排序 1.3.1 插入排序 1.3.2 希尔排序 1.4 归并排序 1.5 计数排序 1.6 基数排序 1.7 桶排序 1.8 排序总结 排序总结\n2 查找 2.1 二分查找 3 回溯 回溯算法总结\n4 递归 5 分治 6 贪心 贪心算法\n7 动态规划 动态规划的原理和引用\n7.1 最长公共子序列(LCS) 8 搜索 8.1 深度优先搜索(DFS) 遍历-DFS\n8.2 广度优先搜索(BFS) 遍历-BFS\n9 记忆化搜索 10 字符串匹配 字符串匹配算法\n11 模拟 12 枚举","date":"2024-11-13T16:56:45+08:00","permalink":"http://www.alvincat.top/index/content_algorithm/","tags":[""],"title":"算法导航页"}]