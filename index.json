[{"categories":[""],"contents":"该页面为网站的导航页面。\n汇编语言导航页 C++导航页 算法导航页 数据结构导航页 操作系统导航页 Linux相关内容导航页 工具使用导航页 环境搭建导航页 文学导航页 ","date":"2024-11-13T16:30:08+08:00","permalink":"http://localhost:1313/contents/","tags":[""],"title":"网站导航页"},{"categories":["汇编语言"],"contents":"本文总结内联汇编的基本用法和应用举例。\n1 内联汇编语法格式 1 2 3 4 5 6 asm [volatile] ( \u0026#34;汇编指令\u0026#34; : 输出操作数列表 : 输入操作数列表 : 被破坏的寄存器列表 ); 1.1 内联汇编参数说明 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;stdio.h\u0026gt; int add(int a, int b) { int res; asm volatile( \u0026#34;addl %1, %2 \\n\\t\u0026#34; \u0026#34;movl %2, %0 \\n\\t\u0026#34; : \u0026#34;=r\u0026#34;(res) : \u0026#34;r\u0026#34;(a), \u0026#34;r\u0026#34;(b)); return res; } int main(void) { int result = add(1, 2); printf(\u0026#34;result: %d\\n\u0026#34;, result); return 0; } 代码说明：该代码为GCC内联汇编，汇编格式为AT\u0026amp;T。\n内联汇编代码说明 第7，8行为汇编代码。其中%0, %1, %2为占位符，占位符将在后续说明。 内联汇编中，若有多行代码，一般使用\\n\\t分隔； 此处%1表示的是第一个输出操作数。%1为第一个输入操作数，%2为第二个输入操作数。 输出操作数列表 汇编代码结束后，紧挨着的一个冒号(:)后就是输出操作数列表； 输出操作数可以为空，但是即使输出操作数列表为空，冒号却不能省略； 若有多个输出操作数，多个输出操作数之间使用逗号(,)分隔。 输入操作数列表 输出操作数列表后紧挨着的一个冒号(:)后就是输入操作数列表； 输入操作数可以为空，但是即使输出操作数列表为空，冒号却不能省略； 若有多个输入操作数，多个操作数之间使用逗号(,)分隔。 被破坏的寄存器列表 若存在被破坏的寄存器列表，放在输入操作列表后。 若被破坏的寄存器列表为空，则冒号可以省略； 1.2 内联汇编中符号的功能 1.2.1 占位符 在内联汇编中，%0、%1、%2 等是占位符（placeholders），代表操作数列表中各个操作数的引用。它们按照操作数在列表中的顺序进行编号。\n编号规则：\n从0开始编号 先从输出操作数开始，依次编号。 编号顺序为：第一个输出操作数为%0，，第二个输出操作数为%1，然后一次编号输入操作数。输出操作数编号完毕后，紧接着编号输入操作数。 1.2.2 修饰符 修饰符用于控制输入操作数列表，输出操作数列表和被破坏寄存器列表，可以多个修饰符共同使用。\n修饰符 功能说明 示例 = 表示当前变量为只写变量，一般用用于修饰输出操作数 \u0026ldquo;=r\u0026rdquo;(res) + 表示当前变量为可读写变量 \u0026ldquo;+r\u0026rdquo;(a) \u0026amp; 表示修饰的变量不能与其他变量公用寄存器(或内存) \u0026ldquo;=\u0026amp;r\u0026rdquo;(result1) r 表示当前操作数使用通用寄存器存放 \u0026ldquo;r\u0026rdquo;(sum) m 表示当前操作数使用内存存放 \u0026ldquo;m\u0026rdquo;(res) 0-9 使用指定操作数保存变量 \u0026ldquo;0\u0026rdquo;(var) 2 内联汇编实例 2.1","date":"2026-02-07T16:42:10+08:00","permalink":"http://localhost:1313/post/assembly/inlineassembly/","tags":[""],"title":"内联汇编"},{"categories":["文学"],"contents":"《离骚》是屈原的代表作，全诗共373句，近2500字，是中国古代最长的抒情诗。\n《离骚》节选 长太息以掩涕兮，哀民生之多艰。 余虽好修姱以鞿羁兮，謇朝谇而夕替。 既替余以蕙纕兮，又申之以揽茝。 亦余心之所善兮，虽九死其犹未悔。 怨灵修之浩荡兮，终不察夫民心。 众女嫉余之蛾眉兮，谣诼谓余以善淫。 固时俗之工巧兮，偭规矩而改错。 背绳墨以追曲兮，竞周容以为度。 忳郁邑余侘傺兮，吾独穷困乎此时也。 宁溘死以流亡兮，余不忍为此态也！ 鸷鸟之不群兮，自前世而固然。 何方圜之能周兮？夫孰异道而相安？ 屈心而抑志兮，忍尤而攘诟。 伏清白以死直兮，固前圣之所厚。\n悔相道之不察兮，延伫乎吾将反。 回朕车以复路兮，及行迷之未远。 步余马于兰皋兮，驰椒丘且焉止息。 进不入以离尤兮，退将复修吾初服。 制芰荷以为衣兮，集芙蓉以为裳。 不吾知其亦已兮，苟余情其信芳。 高余冠之岌岌兮，长余佩之陆离。 芳与泽其杂糅兮，唯昭质其犹未亏。 忽反顾以游目兮，将往观乎四荒。 佩缤纷其繁饰兮，芳菲菲其弥章。 民生各有所乐兮，余独好修以为常。 虽体解吾犹未变兮，岂余心之可惩？\n","date":"2025-12-16T22:02:59+08:00","permalink":"http://localhost:1313/post/classic_literature/long_content/li_sao/","tags":[""],"title":"《离骚》-屈原"},{"categories":["文学"],"contents":"本文为司马迁《史记》中的名篇，讲述了战国后期赵国将相之间由“和”到“不和”再到“和”的过程，刻画了蔺相如的智勇双全与顾全大局，以及廉颇的忠勇直率与知错能改。全文由“完璧归赵”、“渑池之会”、“将相和”三个核心故事构成。\n《廉颇蔺相如列传》 完璧归赵 廉颇者，赵之良将也。赵惠文王十六年，廉颇为赵将，伐齐，大破之，取阳晋，拜为上卿，以勇气闻于诸侯。\n蔺相如者，赵人也。为赵宦者令缪贤舍人。\n赵惠文王时，得楚和氏璧。秦昭王闻之，使人遗赵王书，愿以十五城请易璧。赵王与大将军廉颇诸大臣谋：欲予秦，秦城恐不可得，徒见欺；欲勿予，即患秦兵之来。计未定，求人可使报秦者，未得。\n宦者令缪贤曰：“臣舍人蔺相如可使。”王问：“何以知之？”对曰：“臣尝有罪，窃计欲亡走燕。臣舍人相如止臣，曰：‘君何以知燕王？’臣语曰：‘臣尝从大王与燕王会境上，燕王私握臣手，曰“愿结友”。以此知之，故欲往。’相如谓臣曰：‘夫赵强而燕弱，而君幸于赵王，故燕王欲结于君。今君乃亡赵走燕，燕畏赵，其势必不敢留君，而束君归赵矣。君不如肉袒伏斧质请罪，则幸得脱矣。’臣从其计，大王亦幸赦臣。臣窃以为其人勇士，有智谋，宜可使。”\n于是王召见，问蔺相如曰：“秦王以十五城请易寡人之璧，可予不？”相如曰：“秦强而赵弱，不可不许。”王曰：“取吾璧，不予我城，奈何？”相如曰：“秦以城求璧而赵不许，曲在赵；赵予璧而秦不予赵城，曲在秦。均之二策，宁许以负秦曲。”王曰：“谁可使者？”相如曰：“王必无人，臣愿奉璧往使。城入赵而璧留秦；城不入，臣请完璧归赵。”赵王于是遂遣相如奉璧西入秦。\n秦王坐章台见相如。相如奉璧奏秦王。秦王大喜，传以示美人及左右，左右皆呼万岁。相如视秦王无意偿赵城，乃前曰：“璧有瑕，请指示王。”王授璧。相如因持璧却立，倚柱，怒发上冲冠，谓秦王曰：“大王欲得璧，使人发书至赵王，赵王悉召群臣议，皆曰：‘秦贪，负其强，以空言求璧，偿城恐不可得。’议不欲予秦璧。臣以为布衣之交尚不相欺，况大国乎！且以一璧之故逆强秦之欢，不可。于是赵王乃斋戒五日，使臣奉璧，拜送书于庭。何者？严大国之威以修敬也。今臣至，大王见臣列观，礼节甚倨；得璧，传之美人，以戏弄臣。臣观大王无意偿赵王城邑，故臣复取璧。大王必欲急臣，臣头今与璧俱碎于柱矣！”\n相如持其璧睨柱，欲以击柱。秦王恐其破璧，乃辞谢固请，召有司案图，指从此以往十五都予赵。相如度秦王特以诈佯为予赵城，实不可得，乃谓秦王曰：“和氏璧，天下所共传宝也。赵王恐，不敢不献。赵王送璧时，斋戒五日。今大王亦宜斋戒五日，设九宾于廷，臣乃敢上璧。”秦王度之，终不可强夺，遂许斋五日，舍相如广成传舍。\n相如度秦王虽斋，决负约不偿城，乃使其从者衣褐，怀其璧，从径道亡，归璧于赵。\n秦王斋五日后，乃设九宾礼于廷，引赵使者蔺相如。相如至，谓秦王曰：“秦自缪公以来二十余君，未尝有坚明约束者也。臣诚恐见欺于王而负赵，故令人持璧归，间至赵矣。且秦强而赵弱，大王遣一介之使至赵，赵立奉璧来。今以秦之强而先割十五都予赵，赵岂敢留璧而得罪于大王乎？臣知欺大王之罪当诛，臣请就汤镬。唯大王与群臣孰计议之。”\n秦王与群臣相视而嘻。左右或欲引相如去。秦王因曰：“今杀相如，终不能得璧也，而绝秦赵之欢。不如因而厚遇之，使归赵。赵王岂以一璧之故欺秦邪？”卒廷见相如，毕礼而归之。\n相如既归，赵王以为贤大夫，使不辱于诸侯，拜相如为上大夫。 秦亦不以城予赵，赵亦终不予秦璧。\n渑池之会 其后秦伐赵，拔石城。明年，复攻赵，杀二万人。\n秦王使使者告赵王，欲与王为好，会于西河外渑池。赵王畏秦，欲毋行。廉颇、蔺相如计曰：“王不行，示赵弱且怯也。”赵王遂行，相如从。廉颇送至境，与王诀曰：“王行，度道里会遇之礼毕，还，不过三十日。三十日不还，则请立太子为王，以绝秦望。”王许之。遂与秦王会渑池。\n秦王饮酒酣，曰：“寡人窃闻赵王好音，请奏瑟。”赵王鼓瑟。秦御史前书曰：“某年月日，秦王与赵王会饮，令赵王鼓瑟。”蔺相如前曰：“赵王窃闻秦王善为秦声，请奉盆缶秦王，以相娱乐。”秦王怒，不许。于是相如前进缶，因跪请秦王。秦王不肯击缶。相如曰：“五步之内，相如请得以颈血溅大王矣！”左右欲刃相如，相如张目叱之，左右皆靡。于是秦王不怿，为一击缶。相如顾召赵御史书曰：“某年月日，秦王为赵王击缶。”\n秦之群臣曰：“请以赵十五城为秦王寿！”蔺相如亦曰：“请以秦之咸阳为赵王寿！”\n秦王竟酒，终不能加胜于赵。赵亦盛设兵以待秦，秦不敢动。\n将相和 既罢，归国，以相如功大，拜为上卿，位在廉颇之右。\n廉颇曰：“我为赵将，有攻城野战之大功，而蔺相如徒以口舌为劳，而位居我上。且相如素贱人，吾羞，不忍为之下！”宣言曰：“我见相如，必辱之。”相如闻，不肯与会。相如每朝时，常称病，不欲与廉颇争列。已而相如出，望见廉颇，相如引车避匿。\n于是舍人相与谏曰：“臣所以去亲戚而事君者，徒慕君之高义也。今君与廉颇同列，廉君宣恶言而君畏匿之，恐惧殊甚，且庸人尚羞之，况于将相乎！臣等不肖，请辞去。”蔺相如固止之，曰：“公之视廉将军孰与秦王？”曰：“不若也。”相如曰：“夫以秦王之威，而相如廷叱之，辱其群臣。相如虽驽，独畏廉将军哉？顾吾念之，强秦之所以不敢加兵于赵者，徒以吾两人在也。今两虎共斗，其势不俱生。吾所以为此者，以先国家之急而后私仇也。”\n廉颇闻之，肉袒负荆，因宾客至蔺相如门谢罪曰：“鄙贱之人，不知将军宽之至此也！”\n卒相与欢，为刎颈之交。\n","date":"2025-12-16T21:50:54+08:00","permalink":"http://localhost:1313/post/classic_literature/long_content/wan_bi_gui_zhao/","tags":[""],"title":"《廉颇蔺相如列传》"},{"categories":[""],"contents":"《寡人之于国也》是《孟子·梁惠王上》中的著名篇章，记录了孟子与梁惠王（即魏惠王）关于治国之道的对话。\n《寡人之于国也》 梁惠王曰：“寡人之于国也，尽心焉耳矣。河内凶，则移其民于河东，移其粟于河内；河东凶亦然。察邻国之政，无如寡人之用心者。邻国之民不加少，寡人之民不加多，何也？”\n孟子对曰：“王好战，请以战喻。填然鼓之，兵刃既接，弃甲曳兵而走。或百步而后止，或五十步而后止。以五十步笑百步，则何如？”\n曰：“不可，直不百步耳，是亦走也。”\n曰：“王如知此，则无望民之多于邻国也。\n“不违农时，谷不可胜食也；数罟不入洿池，鱼鳖不可胜食也；斧斤以时入山林，材木不可胜用也。谷与鱼鳖不可胜食，材木不可胜用，是使民养生丧死无憾也。养生丧死无憾，王道之始也。\n“五亩之宅，树之以桑，五十者可以衣帛矣；鸡豚狗彘之畜，无失其时，七十者可以食肉矣；百亩之田，勿夺其时，数口之家可以无饥矣；谨庠序之教，申之以孝悌之义，颁白者不负戴于道路矣。七十者衣帛食肉，黎民不饥不寒，然而不王者，未之有也。\n“狗彘食人食而不知检，涂有饿莩而不知发；人死，则曰：‘非我也，岁也。’是何异于刺人而杀之，曰：‘非我也，兵也。’王无罪岁，斯天下之民至焉。”\n","date":"2025-12-16T21:46:06+08:00","permalink":"http://localhost:1313/post/classic_literature/long_content/gua_ren_zhi_yu_guo_ye/","tags":[""],"title":"《寡人之于国也》 — 《孟子》"},{"categories":["文学"],"contents":"《游褒禅山记》是北宋政治家、文学家王安石的一篇记游说理散文，通过一次游山经历阐发治学与为政的深刻哲理。\n《游褒禅山记》 褒禅山亦谓之华山。唐浮图慧褒始舍于其址，而卒葬之；以故其后名之曰“褒禅”。今所谓慧空禅院者，褒之庐冢也。距其院东五里，所谓华山洞者，以其乃华山之阳名之也。距洞百余步，有碑仆道，其文漫灭，独其为文犹可识，曰“花山”。今言“华”如“华实”之“华”者，盖音谬也。\n其下平旷，有泉侧出，而记游者甚众，所谓前洞也。由山以上五六里，有穴窈然，入之甚寒，问其深，则其好游者不能穷也，谓之后洞。余与四人拥火以入，入之愈深，其进愈难，而其见愈奇。有怠而欲出者，曰：“不出，火且尽。”遂与之俱出。盖余所至，比好游者尚不能十一，然视其左右，来而记之者已少。盖其又深，则其至又加少矣。方是时，予之力尚足以入，火尚足以明也。既其出，则或咎其欲出者，而余亦悔其随之而不得极夫游之乐也。\n于是余有叹焉。古人之观于天地、山川、草木、虫鱼、鸟兽，往往有得，以其求思之深而无不在也。夫夷以近，则游者众；险以远，则至者少。而世之奇伟、瑰怪、非常之观，常在于险远，而人之所罕至焉，故非有志者不能至也。有志矣，不随以止也，然力不足者，亦不能至也。有志与力，而又不随以怠，至于幽暗昏惑而无物以相之，亦不能至也。然力足以至焉，于人为可讥，而在己为有悔；尽吾志也而不能至者，可以无悔矣，其孰能讥之乎？此余之所得也。\n余于仆碑，又以悲夫古书之不存，后世之谬其传而莫能名者，何可胜道也哉！此所以学者不可以不深思而慎取之也。\n四人者：庐陵萧君圭君玉，长乐王回深父，余弟安国平父、安上纯父。至和元年七月某日，临川王某记。\n","date":"2025-12-16T21:43:32+08:00","permalink":"http://localhost:1313/post/classic_literature/long_content/you_bao_chan_shan_ji/","tags":[""],"title":"《游褒禅山记》-王安石"},{"categories":["文学"],"contents":"《荆轲刺秦王》是《战国策·燕策三》中的著名篇章，后亦被司马迁收录于《史记·刺客列传》。背景是秦灭韩、赵后兵临燕国，燕太子丹孤注一掷，策划刺秦王。\n《战国策·燕策三·荆轲刺秦王》 太子及宾客知其事者，皆白衣冠以送之。至易水上，既祖，取道。高渐离击筑，荆轲和而歌，为变徵之声，士皆垂泪涕泣。又前而为歌曰：“风萧萧兮易水寒，壮士一去兮不复还！”复为慷慨羽声，士皆瞋目，发尽上指冠。于是荆轲遂就车而去，终已不顾。\n遂至秦，持千金之资币物，厚遗秦王宠臣中庶子蒙嘉。嘉为先言于秦王曰：“燕王诚振怖大王之威，不敢兴兵以拒大王，愿举国为内臣，比诸侯之列，给贡职如郡县，而得奉守先王之宗庙。恐惧不敢自陈，谨斩樊於期头，及献燕之督亢之地图，函封，燕王拜送于庭，使使以闻大王。唯大王命之。”\n秦王闻之，大喜。乃朝服，设九宾，见燕使者咸阳宫。荆轲奉樊於期头函，而秦舞阳奉地图匣，以次进。至陛下，秦舞阳色变振恐，群臣怪之。荆轲顾笑舞阳，前谢曰：“北蛮夷之鄙人，未尝见天子，故振慑，愿大王少假借之，使毕使于前。”秦王谓轲曰：“起，取舞阳所持地图！”轲既取图奉之，发图，图穷而匕首见。因左手把秦王之袖，而右手持匕首揕之。未至身，秦王惊，自引而起，绝袖。拔剑，剑长，操其室。时恐急，剑坚，故不可立拔。\n荆轲逐秦王，秦王还柱而走。群臣惊愕，卒起不意，尽失其度。而秦法，群臣侍殿上者，不得持尺兵；诸郎中执兵，皆陈殿下，非有诏不得上。方急时，不及召下兵，以故荆轲逐秦王，而卒惶急无以击轲，而乃以手共搏之。\n是时，侍医夏无且以其所奉药囊提轲。秦王方还柱走，卒惶急不知所为。左右乃曰：“王负剑！王负剑！”遂拔以击荆轲，断其左股。荆轲废，乃引其匕首提秦王，不中，中柱。秦王复击轲，被八创。\n轲自知事不就，倚柱而笑，箕踞以骂曰：“事所以不成者，乃欲以生劫之，必得约契以报太子也。”\n于是左右既前杀轲，秦王不怡者良久。已而论功，赏群臣及当坐者各有差，而赐夏无且黄金二百镒，曰：“无且爱我，乃以药囊提轲也。”\n","date":"2025-12-16T21:39:26+08:00","permalink":"http://localhost:1313/post/classic_literature/long_content/jing_ke_ci_qin_wang/","tags":[""],"title":"《荆轲刺秦王》- 《史记·刺客列传》"},{"categories":["文学"],"contents":"《师说》是唐代文学家、思想家韩愈的代表作之一，写于唐德宗贞元十八年（公元802年），旨在抨击当时士大夫阶层“耻学于师”的社会风气，倡导尊师重道。\n《师说》 古之学者必有师。师者，所以传道受业解惑也。人非生而知之者，孰能无惑？惑而不从师，其为惑也，终不解矣。生乎吾前，其闻道也固先乎吾，吾从而师之；生乎吾后，其闻道也亦先乎吾，吾从而师之。吾师道也，夫庸知其年之先后生于吾乎？是故无贵无贱，无长无少，道之所存，师之所存也。\n嗟乎！师道之不传也久矣！欲人之无惑也难矣！古之圣人，其出人也远矣，犹且从师而问焉；今之众人，其下圣人也亦远矣，而耻学于师。是故圣益圣，愚益愚。圣人之所以为圣，愚人之所以为愚，其皆出于此乎？\n爱其子，择师而教之；于其身也，则耻师焉，惑矣。彼童子之师，授之书而习其句读者，非吾所谓传其道解其惑者也。句读之不知，惑之不解，或师焉，或不焉，小学而大遗，吾未见其明也。\n巫医乐师百工之人，不耻相师。士大夫之族，曰师曰弟子云者，则群聚而笑之。问之，则曰：“彼与彼年相若也，道相似也。位卑则足羞，官盛则近谀。”呜呼！师道之不复可知矣。巫医乐师百工之人，君子不齿，今其智乃反不能及，其可怪也欤！\n圣人无常师。孔子师郯子、苌弘、师襄、老聃。郯子之徒，其贤不及孔子。孔子曰：三人行，则必有我师。是故弟子不必不如师，师不必贤于弟子，闻道有先后，术业有专攻，如是而已。\n李氏子蟠，年十七，好古文，六艺经传皆通习之，不拘于时，学于余。余嘉其能行古道，作《师说》以贻之。\n","date":"2025-12-16T21:32:38+08:00","permalink":"http://localhost:1313/post/classic_literature/long_content/shi_shuo/","tags":[""],"title":"《师说》- 韩愈"},{"categories":["文学"],"contents":"《荀子·劝学》是中国古代思想史上的经典名篇，全文篇幅较长，但逻辑严密，比喻生动，系统地阐述了学习的重要性、方法及目的。\n#《荀子·劝学》\n君子曰：学不可以已。\n青，取之于蓝，而青于蓝；冰，水为之，而寒于水。木直中绳，輮以为轮，其曲中规，虽有槁暴，不复挺者，輮使之然也。故木受绳则直，金就砺则利，君子博学而日参省乎己，则知明而行无过矣。\n故不登高山，不知天之高也；不临深溪，不知地之厚也；不闻先王之遗言，不知学问之大也。干、越、夷、貉之子，生而同声，长而异俗，教使之然也。《诗》曰：“嗟尔君子，无恒安息。靖共尔位，好是正直。神之听之，介尔景福。”神莫大于化道，福莫长于无祸。\n吾尝终日而思矣，不如须臾之所学也；吾尝跂而望矣，不如登高之博见也。登高而招，臂非加长也，而见者远；顺风而呼，声非加疾也，而闻者彰。假舆马者，非利足也，而致千里；假舟楫者，非能水也，而绝江河。君子生非异也，善假于物也。\n南方有鸟焉，名曰蒙鸠，以羽为巢，而编之以发，系之苇苕，风至苕折，卵破子死。巢非不完也，所系者然也。西方有木焉，名曰射干，茎长四寸，生于高山之上，而临百仞之渊，木茎非能长也，所立者然也。蓬生麻中，不扶而直；白沙在涅，与之俱黑。兰槐之根是为芷，其渐之滫，君子不近，庶人不服。其质非不美也，所渐者然也。故君子居必择乡，游必就士，所以防邪辟而近中正也。\n物类之起，必有所始。荣辱之来，必象其德。肉腐出虫，鱼枯生蠹。怠慢忘身，祸灾乃作。强自取柱，柔自取束。邪秽在身，怨之所构。施薪若一，火就燥也；平地若一，水就湿也。草木畴生，禽兽群焉，物各从其类也。是故质的张而弓矢至焉，林木茂而斧斤至焉，树成荫而众鸟息焉，醯酸而蚋聚焉。故言有召祸也，行有招辱也，君子慎其所立乎！\n积土成山，风雨兴焉；积水成渊，蛟龙生焉；积善成德，而神明自得，圣心备焉。故不积跬步，无以至千里；不积小流，无以成江海。骐骥一跃，不能十步；驽马十驾，功在不舍。锲而舍之，朽木不折；锲而不舍，金石可镂。蚓无爪牙之利，筋骨之强，上食埃土，下饮黄泉，用心一也。蟹六跪而二螯，非蛇鳝之穴无可寄托者，用心躁也。\n是故无冥冥之志者，无昭昭之明；无惛惛之事者，无赫赫之功。行衢道者不至，事两君者不容。目不能两视而明，耳不能两听而聪。螣蛇无足而飞，鼫鼠五技而穷。《诗》曰：“尸鸠在桑，其子七兮。淑人君子，其仪一兮。其仪一兮，心如结兮！”故君子结于一也。\n昔者瓠巴鼓瑟而流鱼出听，伯牙鼓琴而六马仰秣。故声无小而不闻，行无隐而不形。玉在山而草木润，渊生珠而崖不枯。为善不积邪？安有不闻者乎？\n学恶乎始？恶乎终？曰：其数则始乎诵经，终乎读礼；其义则始乎为士，终乎为圣人。真积力久则入，学至乎没而后止也。故学数有终，若其义则不可须臾舍也。为之，人也；舍之，禽兽也。故《书》者，政事之纪也；《诗》者，中声之所止也；《礼》者，法之大分，类之纲纪也，故学至乎《礼》而止矣。夫是之谓道德之极。《礼》之敬文也，《乐》之中和也，《诗》《书》之博也，《春秋》之微也，在天地之间者毕矣。\n君子之学也，入乎耳，箸乎心，布乎四体，形乎动静。端而言，蝡而动，一可以为法则。小人之学也，入乎耳，出乎口。口耳之间则四寸耳，曷足以美七尺之躯哉！古之学者为己，今之学者为人。君子之学也，以美其身；小人之学也，以为禽犊。故不问而告谓之傲，问一而告二谓之囋。傲，非也；囋，非也；君子如向矣。\n学莫便乎近其人。《礼》《乐》法而不说，《诗》《书》故而不切，《春秋》约而不速。方其人之习君子之说，则尊以遍矣，周于世矣。故曰：学莫便乎近其人。\n学之经莫速乎好其人，隆礼次之。上不能好其人，下不能隆礼，安特将学杂识志，顺《诗》《书》而已耳，则末世穷年，不免为陋儒而已！将原先王，本仁义，则礼正其经纬蹊径也。若挈裘领，诎五指而顿之，顺者不可胜数也。不道礼宪，以《诗》《书》为之，譬之犹以指测河也，以戈舂黍也，以锥餐壶也，不可以得之矣。故隆礼，虽未明，法士也；不隆礼，虽察辩，散儒也。\n问楛者勿告也，告楛者勿问也，说楛者勿听也，有争气者勿与辩也。故必由其道至，然后接之，非其道则避之。故礼恭而后可与言道之方，辞顺而后可与言道之理，色从而后可与言道之致。故未可与言而言谓之傲，可与言而不言谓之隐，不观气色而言谓之瞽。故君子不傲、不隐、不瞽，谨顺其身。《诗》曰：“匪交匪舒，天子所予。”此之谓也。\n百发失一，不足谓善射；千里跬步不至，不足谓善御；伦类不通，仁义不一，不足谓善学。学也者，固学一之也。一出焉，一入焉，涂巷之人也；其善者少，不善者多，桀、纣、盗跖也；全之尽之，然后学者也。\n君子知夫不全不粹之不足以为美也，故诵数以贯之，思索以通之，为其人以处之，除其害者以持养之。使目非是无欲见也，使耳非是无欲闻也，使口非是无欲言也，使心非是无欲虑也。及至其致好之也，目好之五色，耳好之五声，口好之五味，心利之有天下。是故权利不能倾也，群众不能移也，天下不能荡也。生乎由是，死乎由是，夫是之谓德操。德操然后能定，能定然后能应。能定能应，夫是之谓成人。天见其明，地见其光，君子贵其全也。\n","date":"2025-12-16T21:30:56+08:00","permalink":"http://localhost:1313/post/classic_literature/long_content/quan_xue_xunzi/","tags":[""],"title":"《荀子·劝学》"},{"categories":["文学"],"contents":"《鸿门宴》出自西汉司马迁《史记·项羽本纪》，是楚汉争霸的关键转折点。司马迁以高超的叙事艺术，在觥筹交错的宴会场景中，刻画了项羽的优柔寡断、刘邦的隐忍机变、范增的深谋远虑、张良的沉着机智、樊哙的忠勇刚烈，以及项伯的因私误公，揭示了刘胜项败的深层性格与历史必然。\n《史记·项羽本纪·鸿门宴》 楚左尹项伯者，项羽季父也，素善留侯张良。张良是时从沛公，项伯乃夜驰之沛公军，私见张良，具告以事，欲呼张良与俱去。曰：“毋从俱死也。”张良曰：“臣为韩王送沛公，沛公今事有急，亡去不义，不可不语。”良乃入，具告沛公。沛公大惊，曰：“为之奈何？”张良曰：“谁为大王为此计者？”曰：“鲰生说我曰：‘距关，毋内诸侯，秦地可尽王也。’故听之。”良曰：“料大王士卒足以当项王乎？”沛公默然，曰：“固不如也。且为之奈何？”张良曰：“请往谓项伯，言沛公不敢背项王也。”沛公曰：“君安与项伯有故？”张良曰：“秦时与臣游，项伯杀人，臣活之；今事有急，故幸来告良。”沛公曰：“孰与君少长？”良曰：“长于臣。”沛公曰：“君为我呼入，吾得兄事之。”张良出，要项伯。项伯即入见沛公。沛公奉卮酒为寿，约为婚姻，曰：“吾入关，秋毫不敢有所近，籍吏民，封府库，而待将军。所以遣将守关者，备他盗之出入与非常也。日夜望将军至，岂敢反乎！愿伯具言臣之不敢倍德也。”项伯许诺，谓沛公曰：“旦日不可不蚤自来谢项王。”沛公曰：“诺。”于是项伯复夜去，至军中，具以沛公言报项王，因言曰：“沛公不先破关中，公岂敢入乎？今人有大功而击之，不义也。不如因善遇之。”项王许诺。\n沛公旦日从百余骑来见项王，至鸿门，谢曰：“臣与将军戮力而攻秦，将军战河北，臣战河南，然不自意能先入关破秦，得复见将军于此。今者有小人之言，令将军与臣有郤。”项王曰：“此沛公左司马曹无伤言之；不然，籍何以至此？”项王即日因留沛公与饮。项王、项伯东向坐，亚父南向坐。亚父者，范增也。沛公北向坐，张良西向侍。范增数目项王，举所佩玉玦以示之者三，项王默然不应。范增起，出召项庄，谓曰：“君王为人不忍。若入前为寿，寿毕，请以剑舞，因击沛公于坐，杀之。不者，若属皆且为所虏。”庄则入为寿。寿毕，曰：“君王与沛公饮，军中无以为乐，请以剑舞。”项王曰：“诺。”项庄拔剑起舞，项伯亦拔剑起舞，常以身翼蔽沛公，庄不得击。\n于是张良至军门见樊哙。樊哙曰：“今日之事何如？”良曰：“甚急！今者项庄拔剑舞，其意常在沛公也。”哙曰：“此迫矣！臣请入，与之同命。”哙即带剑拥盾入军门。交戟之卫士欲止不内，樊哙侧其盾以撞，卫士仆地，哙遂入，披帷西向立，瞋目视项王，头发上指，目眦尽裂。项王按剑而跽曰：“客何为者？”张良曰：“沛公之参乘樊哙者也。”项王曰：“壮士！赐之卮酒。”则与斗卮酒。哙拜谢，起，立而饮之。项王曰：“赐之彘肩。”则与一生彘肩。樊哙覆其盾于地，加彘肩上，拔剑切而啖之。项王曰：“壮士！能复饮乎？”樊哙曰：“臣死且不避，卮酒安足辞！夫秦王有虎狼之心，杀人如不能举，刑人如恐不胜，天下皆叛之。怀王与诸将约曰：‘先破秦入咸阳者王之。’今沛公先破秦入咸阳，毫毛不敢有所近，封闭宫室，还军霸上，以待大王来。故遣将守关者，备他盗出入与非常也。劳苦而功高如此，未有封侯之赏，而听细说，欲诛有功之人，此亡秦之续耳。窃为大王不取也！”项王未有以应，曰：“坐。”樊哙从良坐。\n坐须臾，沛公起如厕，因招樊哙出。沛公已出，项王使都尉陈平召沛公。沛公曰：“今者出，未辞也，为之奈何？”樊哙曰：“大行不顾细谨，大礼不辞小让。如今人方为刀俎，我为鱼肉，何辞为？”于是遂去。乃令张良留谢。良问曰：“大王来何操？”曰：“我持白璧一双，欲献项王；玉斗一双，欲与亚父。会其怒，不敢献。公为我献之。”张良曰：“谨诺。”当是时，项王军在鸿门下，沛公军在霸上，相去四十里。沛公则置车骑，脱身独骑，与樊哙、夏侯婴、靳强、纪信等四人持剑盾步走，从郦山下，道芷阳间行。沛公谓张良曰：“从此道至吾军，不过二十里耳。度我至军中，公乃入。”\n沛公已去，间至军中。张良入谢，曰：“沛公不胜杯杓，不能辞。谨使臣良奉白璧一双，再拜献大王足下；玉斗一双，再拜奉大将军足下。”项王曰：“沛公安在？”良曰：“闻大王有意督过之，脱身独去，已至军矣。”项王则受璧，置之坐上。亚父受玉斗，置之地，拔剑撞而破之，曰：“唉！竖子不足与谋。夺项王天下者，必沛公也。吾属今为之虏矣！”沛公至军，立诛杀曹无伤。\n","date":"2025-12-14T14:01:00+08:00","permalink":"http://localhost:1313/post/classic_literature/long_content/hong_men_yan/","tags":[""],"title":"《史记·项羽本纪·鸿门宴》"},{"categories":["文学"],"contents":"《木兰诗》是南北朝时期北方的一首长篇叙事民歌，与《孔雀东南飞》并称“乐府双璧”。它歌颂了女子花木兰女扮男装、替父从军、保家卫国的英雄故事，塑造了一位英勇智慧、忠孝两全的传奇女性形象。 全诗语言生动活泼，风格刚健清新，充满传奇色彩。\n《木兰诗》 唧唧复唧唧，木兰当户织。不闻机杼声，唯闻女叹息。\n问女何所思，问女何所忆。女亦无所思，女亦无所忆。昨夜见军帖，可汗大点兵，军书十二卷，卷卷有爷名。阿爷无大儿，木兰无长兄，愿为市鞍马，从此替爷征。\n东市买骏马，西市买鞍鞯，南市买辔头，北市买长鞭。旦辞爷娘去，暮宿黄河边，不闻爷娘唤女声，但闻黄河流水鸣溅溅。旦辞黄河去，暮至黑山头，不闻爷娘唤女声，但闻燕山胡骑鸣啾啾。\n万里赴戎机，关山度若飞。朔气传金柝，寒光照铁衣。将军百战死，壮士十年归。\n归来见天子，天子坐明堂。策勋十二转，赏赐百千强。可汗问所欲，木兰不用尚书郎，愿驰千里足，送儿还故乡。\n爷娘闻女来，出郭相扶将；阿姊闻妹来，当户理红妆；小弟闻姊来，磨刀霍霍向猪羊。开我东阁门，坐我西阁床，脱我战时袍，著我旧时裳。当窗理云鬓，对镜帖花黄。出门看火伴，火伴皆惊忙：同行十二年，不知木兰是女郎。\n雄兔脚扑朔，雌兔眼迷离；双兔傍地走，安能辨我是雄雌？\n","date":"2025-12-14T13:55:54+08:00","permalink":"http://localhost:1313/post/classic_literature/long_content/mu_lan_shi/","tags":[""],"title":"《木兰诗》"},{"categories":["文学"],"contents":"《孔雀东南飞》是中国文学史上第一部长篇叙事诗，也是汉乐府民歌的巅峰之作，与北朝《木兰诗》并称“乐府双璧”。全诗通过刘兰芝与焦仲卿的爱情悲剧，深刻揭露了封建礼教与家长制的残酷，歌颂了忠贞不渝的爱情与反抗精神。全诗共357句，1785字，情节完整，人物鲜明，语言质朴而感染力极强。\n《孔雀东南飞（并序）》 【序】\n汉末建安中，庐江府小吏焦仲卿妻刘氏，为仲卿母所遣，自誓不嫁。其家逼之，乃投水而死。仲卿闻之，亦自缢于庭树。时人伤之，为诗云尔。\n【正文】\n孔雀东南飞，五里一徘徊。\n“十三能织素，十四学裁衣，十五弹箜篌，十六诵诗书。十七为君妇，心中常苦悲。君既为府吏，守节情不移，贱妾留空房，相见常日稀。鸡鸣入机织，夜夜不得息。三日断五匹，大人故嫌迟。非为织作迟，君家妇难为！妾不堪驱使，徒留无所施。便可白公姥，及时相遣归。”\n府吏得闻之，堂上启阿母：“儿已薄禄相，幸复得此妇，结发同枕席，黄泉共为友。共事二三年，始尔未为久，女行无偏斜，何意致不厚？”\n阿母谓府吏：“何乃太区区！此妇无礼节，举动自专由。吾意久怀忿，汝岂得自由！东家有贤女，自名秦罗敷，可怜体无比，阿母为汝求。便可速遣之，遣去慎莫留！”\n府吏长跪告：“伏惟启阿母，今若遣此妇，终老不复取！”\n阿母得闻之，槌床便大怒：“小子无所畏，何敢助妇语！吾已失恩义，会不相从许！”\n府吏默无声，再拜还入户。举言谓新妇，哽咽不能语：“我自不驱卿，逼迫有阿母。卿但暂还家，吾今日报府。不久当归还，还必相迎取。以此下心意，慎勿违吾语。”\n新妇谓府吏：“勿复重纷纭。往昔初阳岁，谢家来贵门。奉事循公姥，进止敢自专？昼夜勤作息，伶俜萦苦辛。谓言无罪过，供养卒大恩；仍更被驱遣，何言复来还！妾有绣腰襦，葳蕤自生光；红罗复斗帐，四角垂香囊；箱帘六七十，绿碧青丝绳，物物各自异，种种在其中。人贱物亦鄙，不足迎后人，留待作遗施，于今无会因。时时为安慰，久久莫相忘！”\n鸡鸣外欲曙，新妇起严妆。著我绣夹裙，事事四五通。足下蹑丝履，头上玳瑁光。腰若流纨素，耳著明月珰。指如削葱根，口如含朱丹。纤纤作细步，精妙世无双。\n上堂拜阿母，阿母怒不止。“昔作女儿时，生小出野里，本自无数训，兼愧贵家子。受母钱帛多，不堪母驱使。今日还家去，念母劳家里。”却与小姑别，泪落连珠子。“新妇初来时，小姑始扶床；今日被驱遣，小姑如我长。勤心养公姥，好自相扶将。初七及下九，嬉戏莫相忘。”出门登车去，涕落百余行。\n府吏马在前，新妇车在后，隐隐何甸甸，俱会大道口。下马入车中，低头共耳语：“誓不相隔卿，且暂还家去；吾今日赴府，不久当还归，誓天不相负！”\n新妇谓府吏：“感君区区怀！君既若见录，不久望君来。君当作磐石，妾当作蒲苇，蒲苇纫如丝，磐石无转移。我有亲父兄，性行暴如雷，恐不任我意，逆以煎我怀。”举手长劳劳，二情同依依。\n入门上家堂，进退无颜仪。阿母大拊掌，不图子自归：“十三教汝织，十四能裁衣，十五弹箜篌，十六知礼仪，十七遣汝嫁，谓言无誓违。汝今何罪过，不迎而自归？”兰芝惭阿母：“儿实无罪过。”阿母大悲摧。\n还家十余日，县令遣媒来。云有第三郎，窈窕世无双，年始十八九，便言多令才。\n阿母谓阿女：“汝可去应之。”\n阿女含泪答：“兰芝初还时，府吏见了宁，结誓不别离。今日违情义，恐此事非奇。自可断来信，徐徐更谓之。”\n阿母白媒人：“贫贱有此女，始适还家门。不堪吏人妇，岂合令郎君？幸可广问讯，不得便相许。”\n媒人去数日，寻遣丞请还，说有兰家女，承籍有宦官。云有第五郎，娇逸未有婚。遣丞为媒人，主簿通语言。直说太守家，有此令郎君，既欲结大义，故遣来贵门。\n阿母谢媒人：“女子先有誓，老姥岂敢言！”\n阿兄得闻之，怅然心中烦，举言谓阿妹：“作计何不量！先嫁得府吏，后嫁得郎君，否泰如天地，足以荣汝身。不嫁义郎体，其往欲何云？”\n兰芝仰头答：“理实如兄言。谢家事夫婿，中道还兄门。处分适兄意，那得自任专！虽与府吏要，渠会永无缘。登即相许和，便可作婚姻。”\n媒人下床去，诺诺复尔尔。还部白府君：“下官奉使命，言谈大有缘。”府君得闻之，心中大欢喜。视历复开书，便利此月内，六合正相应。良吉三十日，今已二十七，卿可去成婚。交语速装束，络绎如浮云。青雀白鹄舫，四角龙子幡，婀娜随风转。金车玉作轮，踯躅青骢马，流苏金镂鞍。赍钱三百万，皆用青丝穿。杂彩三百匹，交广市鲑珍。从人四五百，郁郁登郡门。\n阿母谓阿女：“适得府君书，明日来迎汝。何不作衣裳？莫令事不举！”\n阿女默无声，手巾掩口啼，泪落便如泻。移我琉璃榻，出置前窗下。左手持刀尺，右手执绫罗。朝成绣夹裙，晚成单罗衫。晻晻日欲暝，愁思出门啼。\n府吏闻此变，因求假暂归。未至二三里，摧藏马悲哀。新妇识马声，蹑履相逢迎。怅然遥相望，知是故人来。举手拍马鞍，嗟叹使心伤：“自君别我后，人事不可量。果不如先愿，又非君所详。我有亲父母，逼迫兼弟兄，以我应他人，君还何所望！”\n府吏谓新妇：“贺卿得高迁！磐石方且厚，可以卒千年；蒲苇一时纫，便作旦夕间。卿当日胜贵，吾独向黄泉！”\n新妇谓府吏：“何意出此言！同是被逼迫，君尔妾亦然。黄泉下相见，勿违今日言！”执手分道去，各各还家门。生人作死别，恨恨那可论？念与世间辞，千万不复全！\n府吏还家去，上堂拜阿母：“今日大风寒，寒风摧树木，严霜结庭兰。儿今日冥冥，令母在后单。故作不良计，勿复怨鬼神！命如南山石，四体康且直！”\n阿母得闻之，零泪应声落：“汝是大家子，仕宦于台阁，慎勿为妇死，贵贱情何薄！东家有贤女，窈窕艳城郭，阿母为汝求，便复在旦夕。”\n府吏再拜还，长叹空房中，作计乃尔立。转头向户里，渐见愁煎迫。\n其日牛马嘶，新妇入青庐。奄奄黄昏后，寂寂人定初。“我命绝今日，魂去尸长留！”揽裙脱丝履，举身赴清池。\n府吏闻此事，心知长别离，徘徊庭树下，自挂东南枝。\n两家求合葬，合葬华山傍。东西植松柏，左右种梧桐。枝枝相覆盖，叶叶相交通。中有双飞鸟，自名为鸳鸯，仰头相向鸣，夜夜达五更。行人驻足听，寡妇起彷徨。多谢后世人，戒之慎勿忘！\n","date":"2025-12-14T13:52:46+08:00","permalink":"http://localhost:1313/post/classic_literature/long_content/kong_que_dong_nan_fei/","tags":[""],"title":"《孔雀东南飞（并序）》"},{"categories":[""],"contents":"《烛之武退秦师》出自《左传·僖公三十年》，是先秦历史散文的经典篇章。文章记述了郑国大夫烛之武在秦、晋两大国围郑的危急关头，凭借一己之辩才，剖析利害，成功说服秦穆公退兵，从而瓦解秦晋联盟、保全郑国的故事。全文语言精炼，逻辑严密，生动展现了烛之武的爱国情怀与外交智慧。\n《烛之武退秦师》 晋侯、秦伯围郑，以其无礼于晋，且贰于楚也。晋军函陵，秦军氾南。\n佚之狐言于郑伯曰：“国危矣，若使烛之武见秦君，师必退。”公从之。辞曰：“臣之壮也，犹不如人；今老矣，无能为也已。”公曰：“吾不能早用子，今急而求子，是寡人之过也。然郑亡，子亦有不利焉！”许之。\n夜缒而出。见秦伯，曰：“秦、晋围郑，郑既知亡矣。若亡郑而有益于君，敢以烦执事。越国以鄙远，君知其难也。焉用亡郑以陪邻？邻之厚，君之薄也。若舍郑以为东道主，行李之往来，共其乏困，君亦无所害。且君尝为晋君赐矣，许君焦、瑕，朝济而夕设版焉，君之所知也。夫晋，何厌之有？既东封郑，又欲肆其西封。若不阙秦，将焉取之？阙秦以利晋，唯君图之。”\n秦伯说，与郑人盟。使杞子、逢孙、杨孙戍之，乃还。\n子犯请击之。公曰：“不可。微夫人之力不及此。因人之力而敝之，不仁；失其所与，不知；以乱易整，不武。吾其还也。”亦去之。\n","date":"2025-12-14T13:48:34+08:00","permalink":"http://localhost:1313/post/classic_literature/long_content/zhu_zhi_wu_tui_qin_shi/","tags":[""],"title":"《烛之武退秦师》- 《左传》"},{"categories":["文学"],"contents":"《庖丁解牛》出自《庄子·养生主》，是庄子以寓言阐述“顺应自然之道以养生”的经典篇章。文章通过庖丁解牛时出神入化的技艺，揭示了“依乎天理”“因其固然”的处世哲学，将技术活动提升至“道”的境界。以下是全文、解析与思想阐释。\n《庖丁解牛》 庖丁为文惠君解牛，手之所触，肩之所倚，足之所履，膝之所踦，砉然向然，奏刀騞然，莫不中音。合于《桑林》之舞，乃中《经首》之会。\n文惠君曰：“嘻，善哉！技盖至此乎？”\n庖丁释刀对曰：“臣之所好者道也，进乎技矣。始臣之解牛之时，所见无非牛者。三年之后，未尝见全牛也。方今之时，臣以神遇而不以目视，官知止而神欲行。依乎天理，批大郤，导大窾，因其固然，技经肯綮之未尝，而况大軱乎！良庖岁更刀，割也；族庖月更刀，折也。今臣之刀十九年矣，所解数千牛矣，而刀刃若新发于硎。彼节者有间，而刀刃者无厚；以无厚入有间，恢恢乎其于游刃必有余地矣，是以十九年而刀刃若新发于硎。虽然，每至于族，吾见其难为，怵然为戒，视为止，行为迟。动刀甚微，謋然已解，如土委地。提刀而立，为之四顾，为之踌躇满志，善刀而藏之。”\n文惠君曰：“善哉！吾闻庖丁之言，得养生焉。”\n","date":"2025-12-14T13:46:21+08:00","permalink":"http://localhost:1313/post/classic_literature/long_content/pao_ding_jie_niu/","tags":[""],"title":"《庖丁解牛》- 《庄子·养生主》"},{"categories":["文学"],"contents":"《阿房宫赋》是唐代文学家杜牧的赋体名篇。文章通过铺陈阿房宫的壮丽奢华与瞬间覆灭，总结了秦朝因暴政奢靡而亡的历史教训，并向后世统治者发出深刻警示。全文辞藻华美，气势磅礴，逻辑严密，是古典赋体中“文赋”的典范之作。\n《阿房宫赋》· 杜牧\n六王毕，四海一，蜀山兀，阿房出。覆压三百余里，隔离天日。骊山北构而西折，直走咸阳。二川溶溶，流入宫墙。五步一楼，十步一阁；廊腰缦回，檐牙高啄；各抱地势，钩心斗角。盘盘焉，囷囷焉，蜂房水涡，矗不知其几千万落。长桥卧波，未云何龙？复道行空，不霁何虹？高低冥迷，不知西东。歌台暖响，春光融融；舞殿冷袖，风雨凄凄。一日之内，一宫之间，而气候不齐。\n妃嫔媵嫱，王子皇孙，辞楼下殿，辇来于秦。朝歌夜弦，为秦宫人。明星荧荧，开妆镜也；绿云扰扰，梳晓鬟也；渭流涨腻，弃脂水也；烟斜雾横，焚椒兰也。雷霆乍惊，宫车过也；辘辘远听，杳不知其所之也。一肌一容，尽态极妍，缦立远视，而望幸焉；有不得见者，三十六年。燕赵之收藏，韩魏之经营，齐楚之精英，几世几年，剽掠其人，倚叠如山；一旦不能有，输来其间。鼎铛玉石，金块珠砾，弃掷逦迤，秦人视之，亦不甚惜。\n嗟乎！一人之心，千万人之心也。秦爱纷奢，人亦念其家。奈何取之尽锱铢，用之如泥沙？使负栋之柱，多于南亩之农夫；架梁之椽，多于机上之工女；钉头磷磷，多于在庾之粟粒；瓦缝参差，多于周身之帛缕；直栏横槛，多于九土之城郭；管弦呕哑，多于市人之言语。使天下之人，不敢言而敢怒。独夫之心，日益骄固。戍卒叫，函谷举，楚人一炬，可怜焦土！\n呜呼！灭六国者六国也，非秦也；族秦者秦也，非天下也。嗟夫！使六国各爱其人，则足以拒秦；使秦复爱六国之人，则递三世可至万世而为君，谁得而族灭也？秦人不暇自哀，而后人哀之；后人哀之而不鉴之，亦使后人而复哀后人也。\n","date":"2025-12-14T13:41:57+08:00","permalink":"http://localhost:1313/post/classic_literature/long_content/e_pang_gong_fu/","tags":[""],"title":"《阿房宫赋》· 杜牧"},{"categories":["文学"],"contents":"《六国论》是北宋文学家苏洵（苏轼、苏辙之父）政论文的代表作，选自《嘉祐集·权书》。 文章通过剖析战国时期六国（齐、楚、燕、赵、韩、魏）灭亡的原因，讽谏北宋朝廷应以史为鉴，改变对外（辽、西夏）屈辱求和的政策，避免重蹈覆辙。全文逻辑严密，笔力雄健，气势纵横，是古代史论的典范之作。\n《六国论》 六国破灭，非兵不利，战不善，弊在赂秦。赂秦而力亏，破灭之道也。或曰：六国互丧，率赂秦耶？曰：不赂者以赂者丧。盖失强援，不能独完。故曰：弊在赂秦也。\n秦以攻取之外，小则获邑，大则得城。较秦之所得，与战胜而得者，其实百倍；诸侯之所亡，与战败而亡者，其实亦百倍。则秦之所大欲，诸侯之所大患，固不在战矣。\n思厥先祖父，暴霜露，斩荆棘，以有尺寸之地。子孙视之不甚惜，举以予人，如弃草芥。今日割五城，明日割十城，然后得一夕安寝。起视四境，而秦兵又至矣。然则诸侯之地有限，暴秦之欲无厌，奉之弥繁，侵之愈急。故不战而强弱胜负已判矣。至于颠覆，理固宜然。古人云：“以地事秦，犹抱薪救火，薪不尽，火不灭。”此言得之。\n齐人未尝赂秦，终继五国迁灭，何哉？与嬴而不助五国也。五国既丧，齐亦不免矣。燕赵之君，始有远略，能守其土，义不赂秦。是故燕虽小国而后亡，斯用兵之效也。至丹以荆卿为计，始速祸焉。赵尝五战于秦，二败而三胜。后秦击赵者再，李牧连却之。洎牧以谗诛，邯郸为郡，惜其用武而不终也。且燕赵处秦革灭殆尽之际，可谓智力孤危，战败而亡，诚不得已。向使三国各爱其地，齐人勿附于秦，刺客不行，良将犹在，则胜负之数，存亡之理，当与秦相较，或未易量。\n呜呼！以赂秦之地封天下之谋臣，以事秦之心礼天下之奇才，并力西向，则吾恐秦人食之不得下咽也。悲夫！有如此之势，而为秦人积威之所劫，日削月割，以趋于亡。为国者无使为积威之所劫哉！\n夫六国与秦皆诸侯，其势弱于秦，而犹有可以不赂而胜之之势。苟以天下之大，下而从六国破亡之故事，是又在六国下矣。\n","date":"2025-12-14T13:38:16+08:00","permalink":"http://localhost:1313/post/classic_literature/long_content/liu_guo_lun/","tags":[""],"title":"《六国论》苏洵 "},{"categories":["文学"],"contents":"《石钟山记》是北宋文学家苏轼于元丰七年（1084年）由黄州移官汝州途中，游历江西湖口石钟山后所写的一篇考察性游记。文章围绕石钟山得名缘由的探究，生动阐述了“事不目见耳闻，而臆断其有无，可乎？”的求真思想，将游记与说理完美结合，是中国古代哲理游记的典范。\n《石钟山记》 《水经》云：“彭蠡之口有石钟山焉。”郦元以为下临深潭，微风鼓浪，水石相搏，声如洪钟。是说也，人常疑之。今以钟磬置水中，虽大风浪不能鸣也，而况石乎！至唐李渤始访其遗踪，得双石于潭上，扣而聆之，南声函胡，北音清越，桴止响腾，余韵徐歇。自以为得之矣。然是说也，余尤疑之。石之铿然有声者，所在皆是也，而此独以钟名，何哉？\n元丰七年六月丁丑，余自齐安舟行适临汝，而长子迈将赴饶之德兴尉，送之至湖口，因得观所谓石钟者。寺僧使小童持斧，于乱石间择其一二扣之，硿硿焉。余固笑而不信也。至莫夜月明，独与迈乘小舟，至绝壁下。大石侧立千尺，如猛兽奇鬼，森然欲搏人；而山上栖鹘，闻人声亦惊起，磔磔云霄间；又有若老人咳且笑于山谷中者，或曰此鹳鹤也。余方心动欲还，而大声发于水上，噌吰如钟鼓不绝。舟人大恐。徐而察之，则山下皆石穴罅，不知其浅深，微波入焉，涵澹澎湃而为此也。舟回至两山间，将入港口，有大石当中流，可坐百人，空中而多窍，与风水相吞吐，有窾坎镗鞳之声，与向之噌吰者相应，如乐作焉。因笑谓迈曰：“汝识之乎？噌吰者，周景王之无射也；窾坎镗鞳者，魏庄子之歌钟也。古之人不余欺也！”\n事不目见耳闻，而臆断其有无，可乎？郦元之所见闻，殆与余同，而言之不详；士大夫终不肯以小舟夜泊绝壁之下，故莫能知；而渔工水师虽知而不能言。此世所以不传也。而陋者乃以斧斤考击而求之，自以为得其实。余是以记之，盖叹郦元之简，而笑李渤之陋也。\n","date":"2025-12-14T13:33:04+08:00","permalink":"http://localhost:1313/post/classic_literature/song/sushi/shi_zhong_shan_ji/","tags":[""],"title":"《石钟山记》- 苏轼"},{"categories":["文学"],"contents":"《种树郭橐驼传》是唐代文学家柳宗元的一篇寓言体传记散文，收录于《柳河东集》。文章通过一位驼背种树高手郭橐驼之口，阐发了“顺天致性”、反对烦政扰民的治国道理，体现了柳宗元朴素的唯物思想和“民本”理念。\n《种树郭橐驼传》 郭橐驼，不知始何名。病偻，隆然伏行，有类橐驼者，故乡人号之“驼”。驼闻之曰：“甚善，名我固当。”因舍其名，亦自谓“橐驼”云。\n其乡曰丰乐乡，在长安西。驼业种树，凡长安豪富人为观游及卖果者，皆争迎取养。视驼所种树，或移徙，无不活；且硕茂，早实以蕃。他植者虽窥伺效慕，莫能如也。\n有问之，对曰：“橐驼非能使木寿且孳也，能顺木之天，以致其性焉尔。凡植木之性，其本欲舒，其培欲平，其土欲故，其筑欲密。既然已，勿动勿虑，去不复顾。其莳也若子，其置也若弃，则其天者全而其性得矣。故吾不害其长而已，非有能硕茂之也；不抑耗其实而已，非有能早而蕃之也。\n“他植者则不然：根拳而土易，其培之也，若不过焉则不及。苟有能反是者，则又爱之太恩，忧之太勤。旦视而暮抚，已去而复顾。甚者爪其肤以验其生枯，摇其本以观其疏密，而木之性日以离矣。虽曰爱之，其实害之；虽曰忧之，其实仇之，故不我若也。吾又何能为哉？”\n问者曰：“以子之道，移之官理，可乎？”驼曰：“我知种树而已，官理，非吾业也。然吾居乡，见长人者好烦其令，若甚怜焉，而卒以祸。旦暮吏来而呼曰：‘官命促尔耕，勖尔植，督尔获，早缫而绪，早织而缕，字而幼孩，遂而鸡豚。’鸣鼓而聚之，击木而召之。吾小人辍飧饔以劳吏者，且不得暇，又何以蕃吾生而安吾性耶？故病且怠。若是，则与吾业者其亦有类乎？”\n问者嘻曰：“不亦善夫！吾问养树，得养人术。”传其事以为官戒也。\n","date":"2025-12-14T13:29:50+08:00","permalink":"http://localhost:1313/post/classic_literature/long_content/zhong_shu_guo_tuo_tuo_zhuan/","tags":[""],"title":"《种树郭橐驼传》- 柳宗元 "},{"categories":["文学"],"contents":"《归去来兮辞》是东晋诗人、文学家陶渊明的代表作，创作于义熙元年（公元405年），标志着他彻底告别官场、归隐田园的决定。全文以“归去来兮”的呼告开篇，抒发了对官场生活的厌弃、对田园生活的向往，以及回归自然后的欣喜与感悟，是中国隐逸文学和田园诗的开山之作。\n《归去来兮辞》 归去来兮，田园将芜胡不归？既自以心为形役，奚惆怅而独悲？悟已往之不谏，知来者之可追。实迷途其未远，觉今是而昨非。舟遥遥以轻飏，风飘飘而吹衣。问征夫以前路，恨晨光之熹微。\n乃瞻衡宇，载欣载奔。僮仆欢迎，稚子候门。三径就荒，松菊犹存。携幼入室，有酒盈樽。引壶觞以自酌，眄庭柯以怡颜。倚南窗以寄傲，审容膝之易安。园日涉以成趣，门虽设而常关。策扶老以流憩，时矫首而遐观。云无心以出岫，鸟倦飞而知还。景翳翳以将入，抚孤松而盘桓。\n归去来兮，请息交以绝游。世与我而相违，复驾言兮焉求？悦亲戚之情话，乐琴书以消忧。农人告余以春及，将有事于西畴。或命巾车，或棹孤舟。既窈窕以寻壑，亦崎岖而经丘。木欣欣以向荣，泉涓涓而始流。善万物之得时，感吾生之行休。\n已矣乎！寓形宇内复几时？曷不委心任去留？胡为乎遑遑欲何之？富贵非吾愿，帝乡不可期。怀良辰以孤往，或植杖而耘耔。登东皋以舒啸，临清流而赋诗。聊乘化以归尽，乐夫天命复奚疑！\n","date":"2025-12-14T13:25:07+08:00","permalink":"http://localhost:1313/post/classic_literature/long_content/gui_qu_lai_xi_ci/","tags":[""],"title":"《归去来兮辞》陶渊明"},{"categories":["文学"],"contents":"《兰亭集序》（又称《兰亭序》《临河序》）是东晋书法家、文学家王羲之于永和九年（公元353年）三月三日，与谢安、孙绰等四十一位名士在会稽山阴（今浙江绍兴）兰亭举行修禊雅集时，为诗集所作的序言。它不仅是中国书法史上被誉为“天下第一行书”的杰作，其文章本身也是骈散结合、哲理深远的文学经典。\n《兰亭集序》 永和九年，岁在癸丑，暮春之初，会于会稽山阴之兰亭，修禊事也。群贤毕至，少长咸集。此地有崇山峻岭，茂林修竹；又有清流激湍，映带左右，引以为流觞曲水，列坐其次。虽无丝竹管弦之盛，一觞一咏，亦足以畅叙幽情。\n是日也，天朗气清，惠风和畅。仰观宇宙之大，俯察品类之盛，所以游目骋怀，足以极视听之娱，信可乐也。\n夫人之相与，俯仰一世。或取诸怀抱，悟言一室之内；或因寄所托，放浪形骸之外。虽趣舍万殊，静躁不同，当其欣于所遇，暂得于己，快然自足，不知老之将至；及其所之既倦，情随事迁，感慨系之矣。向之所欣，俯仰之间，已为陈迹，犹不能不以之兴怀。况修短随化，终期于尽。古人云：“死生亦大矣。”岂不痛哉！\n每览昔人兴感之由，若合一契，未尝不临文嗟悼，不能喻之于怀。固知一死生为虚诞，齐彭殇为妄作。后之视今，亦犹今之视昔，悲夫！故列叙时人，录其所述。虽世殊事异，所以兴怀，其致一也。后之览者，亦将有感于斯文。\n","date":"2025-12-14T13:20:55+08:00","permalink":"http://localhost:1313/post/classic_literature/long_content/lan_ting_ji_xu/","tags":[""],"title":"《兰亭集序》- 王羲之"},{"categories":["文学"],"contents":"《项脊轩志》是明代文学家归有光的一篇抒情散文，也是其代表作“明文第一”的经典篇目。文章通过回忆书房“项脊轩”的变迁琐事，抒发了对祖母、母亲、妻子的深切怀念，以及家族零落、身世飘零的感慨。全文语言平淡自然，细节感人至深，体现了“不事雕琢而自有风味”的唐宋派散文风格。\n《项脊轩志》 项脊轩，旧南阁子也。室仅方丈，可容一人居。百年老屋，尘泥渗漉，雨泽下注；每移案，顾视无可置者。又北向，不能得日，日过午已昏。余稍为修葺，使不上漏。前辟四窗，垣墙周庭，以当南日，日影反照，室始洞然。又杂植兰桂竹木于庭，旧时栏楯，亦遂增胜。借书满架，偃仰啸歌，冥然兀坐，万籁有声；而庭阶寂寂，小鸟时来啄食，人至不去。三五之夜，明月半墙，桂影斑驳，风移影动，珊珊可爱。\n然余居于此，多可喜，亦多可悲。\n先是，庭中通南北为一。迨诸父异爨，内外多置小门墙，往往而是。东犬西吠，客逾庖而宴，鸡栖于厅。庭中始为篱，已为墙，凡再变矣。家有老妪，尝居于此。妪，先大母婢也，乳二世，先妣抚之甚厚。室西连于中闺，先妣尝一至。妪每谓余曰：“某所，而母立于兹。”妪又曰：“汝姊在吾怀，呱呱而泣；娘以指叩门扉曰：‘儿寒乎？欲食乎？’吾从板外相为应答。”语未毕，余泣，妪亦泣。\n余自束发读书轩中，一日，大母过余曰：“吾儿，久不见若影，何竟日默默在此，大类女郎也？”比去，以手阖门，自语曰：“吾家读书久不效，儿之成，则可待乎！”顷之，持一象笏至，曰：“此吾祖太常公宣德间执此以朝，他日汝当用之。”瞻顾遗迹，如在昨日，令人长号不自禁。\n轩东故尝为厨，人往，从轩前过。余扃牖而居，久之，能以足音辨人。轩凡四遭火，得不焚，殆有神护者。\n项脊生曰：“蜀清守丹穴，利甲天下，其后秦皇帝筑女怀清台；刘玄德与曹操争天下，诸葛孔明起陇中。方二人之昧昧于一隅也，世何足以知之？余区区处败屋中，方扬眉瞬目，谓有奇景。人知之者，其谓与坎井之蛙何异？”\n余既为此志，后五年，吾妻来归，时至轩中，从余问古事，或凭几学书。吾妻归宁，述诸小妹语曰：“闻姊家有阁子，且何谓阁子也？”其后六年，吾妻死，室坏不修。其后二年，余久卧病无聊，乃使人复葺南阁子，其制稍异于前。然自后余多在外，不常居。\n庭有枇杷树，吾妻死之年所手植也，今已亭亭如盖矣。\n","date":"2025-12-14T12:05:59+08:00","permalink":"http://localhost:1313/post/classic_literature/long_content/xiang_ji_xuan_zhi/","tags":[""],"title":"《项脊轩志》- 归有光"},{"categories":["文学"],"contents":"《陈情表》是西晋文学家李密（又名李虔）呈给晋武帝司马炎的奏章，旨在辞谢朝廷的征召，陈述自己因祖母年迈多病、无人奉养而不能奉诏赴任的苦衷。全文以孝情为主线，情真意切，感人肺腑，与诸葛亮的《出师表》、韩愈的《祭十二郎文》并称为“千古至情文章”。\n《陈情表》 臣密言：臣以险衅，夙遭闵凶。生孩六月，慈父见背；行年四岁，舅夺母志。祖母刘愍臣孤弱，躬亲抚养。臣少多疾病，九岁不行，零丁孤苦，至于成立。既无伯叔，终鲜兄弟，门衰祚薄，晚有儿息。外无期功强近之亲，内无应门五尺之僮，茕茕孑立，形影相吊。而刘夙婴疾病，常在床蓐，臣侍汤药，未曾废离。\n逮奉圣朝，沐浴清化。前太守臣逵察臣孝廉，后刺史臣荣举臣秀才。臣以供养无主，辞不赴命。诏书特下，拜臣郎中，寻蒙国恩，除臣洗马。猥以微贱，当侍东宫，非臣陨首所能上报。臣具以表闻，辞不就职。诏书切峻，责臣逋慢；郡县逼迫，催臣上道；州司临门，急于星火。臣欲奉诏奔驰，则刘病日笃；欲苟顺私情，则告诉不许：臣之进退，实为狼狈。\n伏惟圣朝以孝治天下，凡在故老，犹蒙矜育，况臣孤苦，特为尤甚。且臣少仕伪朝，历职郎署，本图宦达，不矜名节。今臣亡国贱俘，至微至陋，过蒙拔擢，宠命优渥，岂敢盘桓，有所希冀！但以刘日薄西山，气息奄奄，人命危浅，朝不虑夕。臣无祖母，无以至今日；祖母无臣，无以终余年。母、孙二人，更相为命，是以区区不能废远。\n臣密今年四十有四，祖母刘今年九十有六，是臣尽节于陛下之日长，报养刘之日短也。乌鸟私情，愿乞终养。臣之辛苦，非独蜀之人士及二州牧伯所见明知，皇天后土实所共鉴。愿陛下矜愍愚诚，听臣微志，庶刘侥幸，保卒余年。臣生当陨首，死当结草。臣不胜犬马怖惧之情，谨拜表以闻。\n","date":"2025-12-14T11:36:09+08:00","permalink":"http://localhost:1313/post/classic_literature/long_content/chen_qing_biao/","tags":[""],"title":"《陈情表》- 李密"},{"categories":["文学"],"contents":"《逍遥游》是《庄子·内篇》的首篇，也是中国哲学与文学史上最富想象力的经典之一。它通过恢弘的寓言和层层递进的论述，探讨了“绝对自由”的境界——即“无所待”的逍遥。\n《庄子·逍遥游》 北冥有鱼，其名为鲲。鲲之大，不知其几千里也。化而为鸟，其名为鹏。鹏之背，不知其几千里也；怒而飞，其翼若垂天之云。是鸟也，海运则将徙于南冥。南冥者，天池也。\n《齐谐》者，志怪者也。《谐》之言曰：“鹏之徙于南冥也，水击三千里，抟扶摇而上者九万里，去以六月息者也。”野马也，尘埃也，生物之以息相吹也。天之苍苍，其正色邪？其远而无所至极邪？其视下也，亦若是则已矣。\n且夫水之积也不厚，则其负大舟也无力。覆杯水于坳堂之上，则芥为之舟；置杯焉则胶，水浅而舟大也。风之积也不厚，则其负大翼也无力。故九万里，则风斯在下矣，而后乃今培风；背负青天而莫之夭阏者，而后乃今将图南。\n蜩与学鸠笑之曰：“我决起而飞，抢榆枋而止，时则不至，而控于地而已矣，奚以之九万里而南为？”适莽苍者，三餐而反，腹犹果然；适百里者，宿舂粮；适千里者，三月聚粮。之二虫又何知！\n小知不及大知，小年不及大年。奚以知其然也？朝菌不知晦朔，蟪蛄不知春秋，此小年也。楚之南有冥灵者，以五百岁为春，五百岁为秋；上古有大椿者，以八千岁为春，八千岁为秋，此大年也。而彭祖乃今以久特闻，众人匹之，不亦悲乎！\n汤之问棘也是已。穷发之北有冥海者，天池也。有鱼焉，其广数千里，未有知其修者，其名为鲲。有鸟焉，其名为鹏，背若泰山，翼若垂天之云，抟扶摇羊角而上者九万里，绝云气，负青天，然后图南，且适南冥也。斥鴳笑之曰：“彼且奚适也？我腾跃而上，不过数仞而下，翱翔蓬蒿之间，此亦飞之至也。而彼且奚适也？”此小大之辩也。\n故夫知效一官，行比一乡，德合一君，而徵一国者，其自视也亦若此矣。而宋荣子犹然笑之。且举世而誉之而不加劝，举世而非之而不加沮，定乎内外之分，辩乎荣辱之境，斯已矣。彼其于世未数数然也。虽然，犹有未树也。\n夫列子御风而行，泠然善也，旬有五日而后反。彼于致福者，未数数然也。此虽免乎行，犹有所待者也。若夫乘天地之正，而御六气之辩，以游无穷者，彼且恶乎待哉？故曰：至人无己，神人无功，圣人无名。\n尧让天下于许由，曰：“日月出矣，而爝火不息，其于光也，不亦难乎！时雨降矣，而犹浸灌，其于泽也，不亦劳乎！夫子立而天下治，而我犹尸之，吾自视缺然。请致天下。”许由曰：“子治天下，天下既已治也。而我犹代子，吾将为名乎？名者，实之宾也。吾将为宾乎？鹪鹩巢于深林，不过一枝；偃鼠饮河，不过满腹。归休乎君，予无所用天下为！庖人虽不治庖，尸祝不越樽俎而代之矣。”\n肩吾问于连叔曰：“吾闻言于接舆，大而无当，往而不返。吾惊怖其言，犹河汉而无极也；大有径庭，不近人情焉。”连叔曰：“其言谓何哉？”曰：“藐姑射之山，有神人居焉，肌肤若冰雪，淖约若处子。不食五谷，吸风饮露。乘云气，御飞龙，而游乎四海之外。其神凝，使物不疵疠而年谷熟。吾以是狂而不信也。”连叔曰：“然。瞽者无以与乎文章之观，聋者无以与乎钟鼓之声。岂唯形骸有聋盲哉？夫知亦有之。是其言也，犹时女也。之人也，之德也，将旁礴万物以为一，世蕲乎乱，孰弊弊焉以天下为事！之人也，物莫之伤，大浸稽天而不溺，大旱金石流、土山焦而不热。是其尘垢秕糠，将犹陶铸尧舜者也，孰肯以物为事！”\n宋人资章甫而适诸越，越人断发文身，无所用之。尧治天下之民，平海内之政，往见四子藐姑射之山，汾水之阳，窅然丧其天下焉。\n惠子谓庄子曰：“魏王贻我大瓠之种，我树之成而实五石。以盛水浆，其坚不能自举也。剖之以为瓢，则瓠落无所容。非不呺然大也，吾为其无用而掊之。”庄子曰：“夫子固拙于用大矣。宋人有善为不龟手之药者，世世以洴澼絖为事。客闻之，请买其方百金。聚族而谋曰：‘我世世为洴澼絖，不过数金；今一朝而鬻技百金，请与之。’客得之，以说吴王。越有难，吴王使之将，冬与越人水战，大败越人，裂地而封之。能不龟手一也，或以封，或不免于洴澼絖，则所用之异也。今子有五石之瓠，何不虑以为大樽而浮乎江湖，而忧其瓠落无所容？则夫子犹有蓬之心也夫！”\n惠子谓庄子曰：“吾有大树，人谓之樗。其大本臃肿而不中绳墨，其小枝卷曲而不中规矩，立之途，匠者不顾。今子之言，大而无用，众所同去也。”庄子曰：“子独不见狸狌乎？卑身而伏，以候敖者；东西跳梁，不辟高下；中于机辟，死于罔罟。今夫斄牛，其大若垂天之云。此能为大矣，而不能执鼠。今子有大树，患其无用，何不树之于无何有之乡，广莫之野，彷徨乎无为其侧，逍遥乎寝卧其下。不夭斤斧，物无害者，无所可用，安所困苦哉！”\n","date":"2025-12-14T09:51:13+08:00","permalink":"http://localhost:1313/post/classic_literature/long_content/xiao_yao_you/","tags":[""],"title":"《庄子·逍遥游》"},{"categories":["文学"],"contents":"《小石潭记》是唐代文学家柳宗元“永州八记”中的第四篇（原题为《至小丘西小石潭记》）。这篇山水游记以简洁清冷的笔触，描绘了永州（今湖南零陵）一处幽静凄美的石潭景致，并在景物中融入了作者被贬后孤寂凄怆的心境，是唐代游记散文的典范之作。\n《小石潭记》 【唐 柳宗元】\n从小丘西行百二十步，隔篁竹，闻水声，如鸣珮环，心乐之。伐竹取道，下见小潭，水尤清冽。全石以为底，近岸，卷石底以出，为坻，为屿，为嵁，为岩。青树翠蔓，蒙络摇缀，参差披拂。\n潭中鱼可百许头，皆若空游无所依。日光下澈，影布石上，佁然不动；俶尔远逝，往来翕忽，似与游者相乐。\n潭西南而望，斗折蛇行，明灭可见。其岸势犬牙差互，不可知其源。\n坐潭上，四面竹树环合，寂寥无人，凄神寒骨，悄怆幽邃。以其境过清，不可久居，乃记之而去。\n同游者：吴武陵，龚古，余弟宗玄。隶而从者，崔氏二小生：曰恕己，曰奉壹。\n","date":"2025-12-14T09:44:47+08:00","permalink":"http://localhost:1313/post/classic_literature/long_content/xiao_shi_tan_ji/","tags":[""],"title":"《小石潭记》- 柳宗元"},{"categories":["文学"],"contents":"《滕王阁序》（全称《秋日登洪府滕王阁饯别序》或《滕王阁诗序》）是唐代文学家王勃创作的一篇骈文名作。据传，王勃于唐高宗上元二年（675年）九月，前往交趾（今越南）探望父亲途中，路过洪州（今江西南昌），恰逢都督阎公于重阳节在滕王阁大宴宾客。王勃即席赋诗并写下此序，文惊四座，成为千古绝唱。\n《滕王阁序》 豫章故郡，洪都新府。星分翼轸，地接衡庐。襟三江而带五湖，控蛮荆而引瓯越。物华天宝，龙光射牛斗之墟；人杰地灵，徐孺下陈蕃之榻。雄州雾列，俊采星驰。台隍枕夷夏之交，宾主尽东南之美。都督阎公之雅望，棨戟遥临；宇文新州之懿范，襜帷暂驻。十旬休假，胜友如云；千里逢迎，高朋满座。腾蛟起凤，孟学士之词宗；紫电青霜，王将军之武库。家君作宰，路出名区；童子何知，躬逢胜饯。\n时维九月，序属三秋。潦水尽而寒潭清，烟光凝而暮山紫。俨骖騑于上路，访风景于崇阿。临帝子之长洲，得仙人之旧馆。层峦耸翠，上出重霄；飞阁流丹，下临无地。鹤汀凫渚，穷岛屿之萦回；桂殿兰宫，即冈峦之体势。\n披绣闼，俯雕甍，山原旷其盈视，川泽纡其骇瞩。闾阎扑地，钟鸣鼎食之家；舸舰弥津，青雀黄龙之舳。云销雨霁，彩彻区明。落霞与孤鹜齐飞，秋水共长天一色。渔舟唱晚，响穷彭蠡之滨；雁阵惊寒，声断衡阳之浦。\n遥襟甫畅，逸兴遄飞。爽籁发而清风生，纤歌凝而白云遏。睢园绿竹，气凌彭泽之樽；邺水朱华，光照临川之笔。四美具，二难并。穷睇眄于中天，极娱游于暇日。天高地迥，觉宇宙之无穷；兴尽悲来，识盈虚之有数。望长安于日下，目吴会于云间。地势极而南溟深，天柱高而北辰远。关山难越，谁悲失路之人？萍水相逢，尽是他乡之客。怀帝阍而不见，奉宣室以何年？\n嗟乎！时运不齐，命途多舛。冯唐易老，李广难封。屈贾谊于长沙，非无圣主；窜梁鸿于海曲，岂乏明时？所赖君子见机，达人知命。老当益壮，宁移白首之心？穷且益坚，不坠青云之志。酌贪泉而觉爽，处涸辙以犹欢。北海虽赊，扶摇可接；东隅已逝，桑榆非晚。孟尝高洁，空余报国之情；阮籍猖狂，岂效穷途之哭！\n勃，三尺微命，一介书生。无路请缨，等终军之弱冠；有怀投笔，慕宗悫之长风。舍簪笏于百龄，奉晨昏于万里。非谢家之宝树，接孟氏之芳邻。他日趋庭，叨陪鲤对；今兹捧袂，喜托龙门。杨意不逢，抚凌云而自惜；钟期既遇，奏流水以何惭？\n呜呼！胜地不常，盛筵难再；兰亭已矣，梓泽丘墟。临别赠言，幸承恩于伟饯；登高作赋，是所望于群公。敢竭鄙怀，恭疏短引；一言均赋，四韵俱成。请洒潘江，各倾陆海云尔：\n滕王高阁临江渚，佩玉鸣鸾罢歌舞。 画栋朝飞南浦云，珠帘暮卷西山雨。 闲云潭影日悠悠，物换星移几度秋。 阁中帝子今何在？槛外长江空自流。\n","date":"2025-12-14T09:40:30+08:00","permalink":"http://localhost:1313/post/classic_literature/long_content/teng_wang_ge_xu/","tags":[""],"title":"《滕王阁序》- 王勃"},{"categories":["文学"],"contents":"《醉翁亭记》是北宋文学家欧阳修被贬滁州（今安徽滁州）期间，于庆历六年（1046年）所作的一篇山水游记散文。全文以“乐”字贯穿，描绘了山水之乐、宴游之乐与民同乐的情趣，并含蓄表达了作者在逆境中豁达洒脱、怡然自得的心境。\n《醉翁亭记》 环滁皆山也。其西南诸峰，林壑尤美，望之蔚然而深秀者，琅琊也。山行六七里，渐闻水声潺潺，而泻出于两峰之间者，酿泉也。峰回路转，有亭翼然临于泉上者，醉翁亭也。作亭者谁？山之僧智仙也。名之者谁？太守自谓也。太守与客来饮于此，饮少辄醉，而年又最高，故自号曰醉翁也。醉翁之意不在酒，在乎山水之间也。山水之乐，得之心而寓之酒也。\n若夫日出而林霏开，云归而岩穴暝，晦明变化者，山间之朝暮也。野芳发而幽香，佳木秀而繁阴，风霜高洁，水落而石出者，山间之四时也。朝而往，暮而归，四时之景不同，而乐亦无穷也。\n至于负者歌于途，行者休于树，前者呼，后者应，伛偻提携，往来而不绝者，滁人游也。临溪而渔，溪深而鱼肥。酿泉为酒，泉香而酒洌；山肴野蔌，杂然而前陈者，太守宴也。宴酣之乐，非丝非竹，射者中，弈者胜，觥筹交错，起坐而喧哗者，众宾欢也。苍颜白发，颓然乎其间者，太守醉也。\n已而夕阳在山，人影散乱，太守归而宾客从也。树林阴翳，鸣声上下，游人去而禽鸟乐也。然而禽鸟知山林之乐，而不知人之乐；人知从太守游而乐，而不知太守之乐其乐也。醉能同其乐，醒能述以文者，太守也。太守谓谁？庐陵欧阳修也。\n","date":"2025-12-14T09:30:30+08:00","permalink":"http://localhost:1313/post/classic_literature/long_content/zui_weng_ting_ji/","tags":[""],"title":"《醉翁庭记》- 欧阳修"},{"categories":["文学"],"contents":"《岳阳楼记》是北宋文学家范仲淹应好友滕子京之请，于庆历六年（1046年）所作的一篇散文。它超越了普通写景楼记的范畴，以洞庭湖的万千气象为背景，抒发了“先天下之忧而忧，后天下之乐而乐”的崇高政治理想，成为中国文学史上光照千古的名篇。\n《岳阳楼记》 庆历四年春，滕子京谪守巴陵郡。越明年，政通人和，百废具兴。乃重修岳阳楼，增其旧制，刻唐贤今人诗赋于其上。属予作文以记之。\n予观夫巴陵胜状，在洞庭一湖。衔远山，吞长江，浩浩汤汤，横无际涯；朝晖夕阴，气象万千。此则岳阳楼之大观也，前人之述备矣。然则北通巫峡，南极潇湘，迁客骚人，多会于此，览物之情，得无异乎？\n若夫霪雨霏霏，连月不开，阴风怒号，浊浪排空；日星隐曜，山岳潜形；商旅不行，樯倾楫摧；薄暮冥冥，虎啸猿啼。登斯楼也，则有去国怀乡，忧谗畏讥，满目萧然，感极而悲者矣。\n至若春和景明，波澜不惊，上下天光，一碧万顷；沙鸥翔集，锦鳞游泳；岸芷汀兰，郁郁青青。而或长烟一空，皓月千里，浮光跃金，静影沉璧；渔歌互答，此乐何极！登斯楼也，则有心旷神怡，宠辱偕忘，把酒临风，其喜洋洋者矣。\n嗟夫！予尝求古仁人之心，或异二者之为，何哉？不以物喜，不以己悲；居庙堂之高则忧其民；处江湖之远则忧其君。是进亦忧，退亦忧。然则何时而乐耶？其必曰“先天下之忧而忧，后天下之乐而乐”乎。噫！微斯人，吾谁与归？\n时六年九月十五日。\n","date":"2025-12-14T09:26:45+08:00","permalink":"http://localhost:1313/post/classic_literature/long_content/yue_yang_lou_ji/","tags":[""],"title":"《岳阳楼记》- 范仲淹"},{"categories":["文学"],"contents":"《过秦论》是西汉政论家、文学家贾谊的代表作，分上、中、下三篇，旨在总结秦朝速亡的历史教训，为汉文帝提供治国借鉴。其中上篇最为经典，流传最广，它以磅礴的史论笔法，剖析秦之兴衰，结尾点明“仁义不施而攻守之势异也”的核心论点。\n秦孝公据崤函之固，拥雍州之地，君臣固守以窥周室，有席卷天下，包举宇内，囊括四海之意，并吞八荒之心。当是时也，商君佐之，内立法度，务耕织，修守战之具，外连衡而斗诸侯。于是秦人拱手而取西河之外。\n孝公既没，惠文、武、昭襄蒙故业，因遗策，南取汉中，西举巴、蜀，东割膏腴之地，北收要害之郡。诸侯恐惧，会盟而谋弱秦，不爱珍器重宝肥饶之地，以致天下之士，合从缔交，相与为一。当此之时，齐有孟尝，赵有平原，楚有春申，魏有信陵。此四君者，皆明智而忠信，宽厚而爱人，尊贤而重士，约从离衡，兼韩、魏、燕、楚、齐、赵、宋、卫、中山之众。于是六国之士，有宁越、徐尚、苏秦、杜赫之属为之谋；齐明、周最、陈轸、召滑、楼缓、翟景、苏厉、乐毅之徒通其意；吴起、孙膑、带佗、倪良、王廖、田忌、廉颇、赵奢之伦制其兵。尝以十倍之地，百万之众，叩关而攻秦。秦人开关延敌，九国之师，逡巡而不敢进。秦无亡矢遗镞之费，而天下诸侯已困矣。于是从散约败，争割地而赂秦。秦有余力而制其弊，追亡逐北，伏尸百万，流血漂橹；因利乘便，宰割天下，分裂山河。强国请服，弱国入朝。延及孝文王、庄襄王，享国之日浅，国家无事。\n及至始皇，奋六世之余烈，振长策而御宇内，吞二周而亡诸侯，履至尊而制六合，执敲扑而鞭笞天下，威振四海。南取百越之地，以为桂林、象郡；百越之君，俯首系颈，委命下吏。乃使蒙恬北筑长城而守藩篱，却匈奴七百余里；胡人不敢南下而牧马，士不敢弯弓而报怨。于是废先王之道，焚百家之言，以愚黔首；隳名城，杀豪杰；收天下之兵，聚之咸阳，销锋镝，铸以为金人十二，以弱天下之民。然后践华为城，因河为池，据亿丈之城，临不测之渊，以为固。良将劲弩守要害之处，信臣精卒陈利兵而谁何。天下已定，始皇之心，自以为关中之固，金城千里，子孙帝王万世之业也。\n始皇既没，余威震于殊俗。然陈涉瓮牖绳枢之子，氓隶之人，而迁徙之徒也；才能不及中人，非有仲尼、墨翟之贤，陶朱、猗顿之富；蹑足行伍之间，而倔起阡陌之中，率疲弊之卒，将数百之众，转而攻秦；斩木为兵，揭竿为旗，天下云集响应，赢粮而景从。山东豪俊遂并起而亡秦族矣。\n且夫天下非小弱也，雍州之地，崤函之固，自若也。陈涉之位，非尊于齐、楚、燕、赵、韩、魏、宋、卫、中山之君也；锄櫌棘矜，非铦于钩戟长铩也；谪戍之众，非抗于九国之师也；深谋远虑，行军用兵之道，非及向时之士也。然而成败异变，功业相反，何也？试使山东之国与陈涉度长絜大，比权量力，则不可同年而语矣。然秦以区区之地，致万乘之势，序八州而朝同列，百有余年矣；然后以六合为家，崤函为宫；一夫作难而七庙隳，身死人手，为天下笑者，何也？仁义不施而攻守之势异也。\n","date":"2025-12-14T09:25:09+08:00","permalink":"http://localhost:1313/post/classic_literature/long_content/guo_qin_lun/","tags":[""],"title":"《过秦论》- 贾谊"},{"categories":["文学"],"contents":"《隆中对》是中国古代历史上著名的战略规划，出自《三国志·蜀书·诸葛亮传》，记录了刘备三顾茅庐时诸葛亮对天下大势的分析和战略构想。\n《隆中对》 亮躬耕陇亩，好为《梁父吟》。身长八尺，每自比于管仲、乐毅，时人莫之许也。惟博陵崔州平、颍川徐庶元直与亮友善，谓为信然。\n时先主屯新野。徐庶见先主，先主器之，谓先主曰：“诸葛孔明者，卧龙也，将军岂愿见之乎？”先主曰：“君与俱来。”庶曰：“此人可就见，不可屈致也。将军宜枉驾顾之。”由是先主遂诣亮，凡三往，乃见。因屏人曰：“汉室倾颓，奸臣窃命，主上蒙尘。孤不度德量力，欲信大义于天下，而智术浅短，遂用猖蹶，至于今日。然志犹未已，君谓计将安出？”\n亮答曰：\n“自董卓已来，豪杰并起，跨州连郡者不可胜数。曹操比于袁绍，则名微而众寡，然操遂能克绍，以弱为强者，非惟天时，抑亦人谋也。今操已拥百万之众，挟天子而令诸侯，此诚不可与争锋。孙权据有江东，已历三世，国险而民附，贤能为之用，此可以为援而不可图也。\n荆州北据汉、沔，利尽南海，东连吴会，西通巴、蜀，此用武之国，而其主不能守，此殆天所以资将军，将军岂有意乎？益州险塞，沃野千里，天府之土，高祖因之以成帝业。刘璋暗弱，张鲁在北，民殷国富而不知存恤，智能之士思得明君。\n将军既帝室之胄，信义著于四海，总揽英雄，思贤如渴，若跨有荆、益，保其岩阻，西和诸戎，南抚夷越，外结好孙权，内修政理；天下有变，则命一上将将荆州之军以向宛、洛，将军身率益州之众出于秦川，百姓孰敢不箪食壶浆以迎将军者乎？诚如是，则霸业可成，汉室可兴矣。”\n先主曰：“善！”于是与亮情好日密。\n关羽、张飞等不悦，先主解之曰：“孤之有孔明，犹鱼之有水也。愿诸君勿复言。”羽、飞乃止。\n背景 东汉末年，群雄割据，刘备虽有匡扶汉室之志，但屡遭挫折，缺乏明确的战略方向。公元207年，刘备在徐庶推荐下，三次拜访隐居隆中（今湖北襄阳）的诸葛亮，请教复兴汉室之策。\n核心内容 诸葛亮在隆中对策中提出了以下关键点：\n天下大势分析 曹操已拥百万之众，挟天子以令诸侯，不可直接争锋。\n孙权据有江东，已历三世，国险而民附，只能作为联盟对象，不可图谋。\n战略突破口 荆州（今湖北、湖南一带）乃用武之地，但其主刘表不能守，建议刘备取荆州作为根基。\n益州（今四川、重庆等地）地势险要，沃野千里，刘璋暗弱，民殷国富而不知存恤，可取之立业。\n长远规划 占据荆、益二州后，外结孙权，内修政理，巩固根基。\n待天下有变，则分兵两路北伐：一路从荆州向宛城、洛阳，另一路从益州出秦川（关中），则霸业可成，汉室可兴。\n历史影响 刘备采纳诸葛亮建议，联合孙权击败曹操于赤壁（208年），随后夺取荆州、益州，建立蜀汉政权，形成三国鼎立局面。\n诸葛亮“三分天下”的战略预判精准，但后续因关羽失荆州、刘备伐吴失败等变故，未能完全实现“两路北伐”的构想。\n《隆中对》体现了诸葛亮的全局眼光和战略智慧，成为中国古代战略分析的典范。\n后世评价 正面：被誉为“未出茅庐，已知三分天下”，展现了诸葛亮卓越的政治军事眼光。\n局限性：荆州作为“四战之地”难以长期固守，同时“跨有荆益”与“结好孙权”存在内在矛盾（孙权亦图荆州），导致后来联盟破裂。\n","date":"2025-12-14T09:21:10+08:00","permalink":"http://localhost:1313/post/classic_literature/long_content/long_zhong_dui/","tags":[""],"title":"《隆中对》- 《三国志·蜀书·诸葛亮传》"},{"categories":["文学"],"contents":"《春江花月夜》是唐代诗人张若虚的代表作，被誉为“孤篇盖全唐”的千古绝唱。全诗以春、江、花、月、夜为背景，描绘了幽美邈远的意境，并融入了对宇宙、人生、情感的深邃哲思，语言清丽，韵律悠扬，极富艺术感染力。\n《春江花月夜》 【唐·张若虚】\n春江潮水连海平，海上明月共潮生。 滟滟随波千万里，何处春江无月明！ 江流宛转绕芳甸，月照花林皆似霰。 空里流霜不觉飞，汀上白沙看不见。 江天一色无纤尘，皎皎空中孤月轮。 江畔何人初见月？江月何年初照人？ 人生代代无穷已，江月年年望相似。 不知江月待何人，但见长江送流水。 白云一片去悠悠，青枫浦上不胜愁。 谁家今夜扁舟子？何处相思明月楼？ 可怜楼上月徘徊，应照离人妆镜台。 玉户帘中卷不去，捣衣砧上拂还来。 此时相望不相闻，愿逐月华流照君。 鸿雁长飞光不度，鱼龙潜跃水成文。 昨夜闲潭梦落花，可怜春半不还家。 江水流春去欲尽，江潭落月复西斜。 斜月沉沉藏海雾，碣石潇湘无限路。 不知乘月几人归，落月摇情满江树。\n","date":"2025-12-14T09:15:16+08:00","permalink":"http://localhost:1313/post/classic_literature/tang/chu_jiang_hua_yue_ye/","tags":[""],"title":"《春江花月夜》- 张若虚"},{"categories":["文学"],"contents":"赤壁赋全文。\n《前赤壁赋》\n壬戌之秋，七月既望，苏子与客泛舟游于赤壁之下。清风徐来，水波不兴。举酒属客，诵明月之诗，歌窈窕之章。少焉，月出于东山之上，徘徊于斗牛之间。白露横江，水光接天。纵一苇之所如，凌万顷之茫然。浩浩乎如冯虚御风，而不知其所止；飘飘乎如遗世独立，羽化而登仙。\n于是饮酒乐甚，扣舷而歌之。歌曰：“桂棹兮兰桨，击空明兮溯流光。渺渺兮予怀，望美人兮天一方。”客有吹洞箫者，倚歌而和之。其声呜呜然，如怨如慕，如泣如诉，余音袅袅，不绝如缕。舞幽壑之潜蛟，泣孤舟之嫠妇。\n苏子愀然，正襟危坐而问客曰：“何为其然也？”客曰：“‘月明星稀，乌鹊南飞’，此非曹孟德之诗乎？西望夏口，东望武昌，山川相缪，郁乎苍苍，此非孟德之困于周郎者乎？方其破荆州，下江陵，顺流而东也，舳舻千里，旌旗蔽空，酾酒临江，横槊赋诗，固一世之雄也，而今安在哉？况吾与子渔樵于江渚之上，侣鱼虾而友麋鹿，驾一叶之扁舟，举匏樽以相属。寄蜉蝣于天地，渺沧海之一粟。哀吾生之须臾，羡长江之无穷。挟飞仙以遨游，抱明月而长终。知不可乎骤得，托遗响于悲风。”\n苏子曰：“客亦知夫水与月乎？逝者如斯，而未尝往也；盈虚者如彼，而卒莫消长也。盖将自其变者而观之，则天地曾不能以一瞬；自其不变者而观之，则物与我皆无尽也，而又何羡乎！且夫天地之间，物各有主，苟非吾之所有，虽一毫而莫取。惟江上之清风，与山间之明月，耳得之而为声，目遇之而成色，取之无禁，用之不竭。是造物者之无尽藏也，而吾与子之所共适。”\n客喜而笑，洗盏更酌。肴核既尽，杯盘狼藉。相与枕藉乎舟中，不知东方之既白。\n","date":"2025-12-14T09:10:03+08:00","permalink":"http://localhost:1313/post/classic_literature/song/sushi/chi_bi_fu/","tags":[""],"title":"《赤壁赋》-苏轼"},{"categories":["文学"],"contents":"《出师表》是三国时期蜀汉丞相诸葛亮在公元227年（蜀汉建兴五年）决定北上伐魏、克复中原之前，写给后主刘禅的奏表。此表言辞恳切，充满了诸葛亮对先帝的忠诚、对蜀汉的责任感以及对后主的殷切期望，是中国古代散文的杰作，被誉为“千古第一忠臣文章”。\n《出师表》 臣亮言：先帝创业未半而中道崩殂，今天下三分，益州疲弊，此诚危急存亡之秋也。然侍卫之臣不懈于内，忠志之士忘身于外者，盖追先帝之殊遇，欲报之于陛下也。诚宜开张圣听，以光先帝遗德，恢弘志士之气，不宜妄自菲薄，引喻失义，以塞忠谏之路也。\n宫中府中，俱为一体，陟罚臧否，不宜异同。若有作奸犯科及为忠善者，宜付有司论其刑赏，以昭陛下平明之理，不宜偏私，使内外异法也。\n侍中、侍郎郭攸之、费祎、董允等，此皆良实，志虑忠纯，是以先帝简拔以遗陛下。愚以为宫中之事，事无大小，悉以咨之，然后施行，必能裨补阙漏，有所广益。\n将军向宠，性行淑均，晓畅军事，试用于昔日，先帝称之曰能，是以众议举宠为督。愚以为营中之事，悉以咨之，必能使行阵和睦，优劣得所。\n亲贤臣，远小人，此先汉所以兴隆也；亲小人，远贤臣，此后汉所以倾颓也。先帝在时，每与臣论此事，未尝不叹息痛恨于桓、灵也。侍中、尚书、长史、参军，此悉贞良死节之臣，愿陛下亲之信之，则汉室之隆，可计日而待也。\n臣本布衣，躬耕于南阳，苟全性命于乱世，不求闻达于诸侯。先帝不以臣卑鄙，猥自枉屈，三顾臣于草庐之中，咨臣以当世之事，由是感激，遂许先帝以驱驰。后值倾覆，受任于败军之际，奉命于危难之间，尔来二十有一年矣。\n先帝知臣谨慎，故临崩寄臣以大事也。受命以来，夙夜忧叹，恐托付不效，以伤先帝之明，故五月渡泸，深入不毛。今南方已定，兵甲已足，当奖率三军，北定中原，庶竭驽钝，攘除奸凶，兴复汉室，还于旧都。此臣所以报先帝而忠陛下之职分也。至于斟酌损益，进尽忠言，则攸之、祎、允之任也。\n愿陛下托臣以讨贼兴复之效，不效，则治臣之罪，以告先帝之灵。若无兴德之言，则责攸之、祎、允等之慢，以彰其咎。陛下亦宜自谋，以谘诹善道，察纳雅言，深追先帝遗诏。臣不胜受恩感激。\n今当远离，临表涕零，不知所言。\n","date":"2025-12-13T23:04:30+08:00","permalink":"http://localhost:1313/post/classic_literature/long_content/chu_shi_biao/","tags":[""],"title":"《出师表》- 诸葛亮"},{"categories":["文学"],"contents":"《观刈麦》\n《观刈麦》 【唐 白居易】 田家少闲月，五月人倍忙。 夜来南风起，小麦覆陇黄。 妇姑荷箪食，童稚携壶浆。 相随饷田去，丁壮在南冈。 足蒸暑土气，背灼炎天光。 力尽不知热，但惜夏日长。 复有贫妇人，抱子在其旁。 右手秉遗穗，左臂悬敝筐。 听其相顾言，闻者为悲伤。 家田输税尽，拾此充饥肠。 今我何功德，曾不事农桑。 吏禄三百石，岁晏有余粮。 念此私自愧，尽日不能忘。\n","date":"2025-12-13T22:43:05+08:00","permalink":"http://localhost:1313/post/classic_literature/tang/baijuyi/guang_yi_mai/","tags":[""],"title":"《观刈麦》- 白居易"},{"categories":["文学"],"contents":"《长恨歌》 【唐 白居易】 汉皇重色思倾国，御宇多年求不得。 杨家有女初长成，养在深闺人未识。 天生丽质难自弃，一朝选在君王侧。 回眸一笑百媚生，六宫粉黛无颜色。 春寒赐浴华清池，温泉水滑洗凝脂。 侍儿扶起娇无力，始是新承恩泽时。 云鬓花颜金步摇，芙蓉帐暖度春宵。 春宵苦短日高起，从此君王不早朝。 承欢侍宴无闲暇，春从春游夜专夜。 后宫佳丽三千人，三千宠爱在一身。 金屋妆成娇侍夜，玉楼宴罢醉和春。 姊妹弟兄皆列土，可怜光彩生门户。 遂令天下父母心，不重生男重生女。\n骊宫高处入青云，仙乐风飘处处闻。 缓歌慢舞凝丝竹，尽日君王看不足。 渔阳鼙鼓动地来，惊破霓裳羽衣曲。 九重城阙烟尘生，千乘万骑西南行。 翠华摇摇行复止，西出都门百余里。 六军不发无奈何，宛转蛾眉马前死。 花钿委地无人收，翠翘金雀玉搔头。 君王掩面救不得，回看血泪相和流。 黄埃散漫风萧索，云栈萦纡登剑阁。 峨嵋山下少人行，旌旗无光日色薄。 蜀江水碧蜀山青，圣主朝朝暮暮情。 行宫见月伤心色，夜雨闻铃肠断声。\n天旋地转回龙驭，到此踌躇不能去。 马嵬坡下泥土中，不见玉颜空死处。 君臣相顾尽沾衣，东望都门信马归。 归来池苑皆依旧，太液芙蓉未央柳。 芙蓉如面柳如眉，对此如何不泪垂？ 春风桃李花开日，秋雨梧桐叶落时。 西宫南内多秋草，落叶满阶红不扫。 梨园弟子白发新，椒房阿监青娥老。 夕殿萤飞思悄然，孤灯挑尽未成眠。 迟迟钟鼓初长夜，耿耿星河欲曙天。 鸳鸯瓦冷霜华重，翡翠衾寒谁与共？ 悠悠生死别经年，魂魄不曾来入梦。\n临邛道士鸿都客，能以精诚致魂魄。 为感君王辗转思，遂教方士殷勤觅。 排空驭气奔如电，升天入地求之遍。 上穷碧落下黄泉，两处茫茫皆不见。 忽闻海上有仙山，山在虚无缥缈间。 楼阁玲珑五云起，其中绰约多仙子。 中有一人字太真，雪肤花貌参差是。 金阙西厢叩玉扃，转教小玉报双成。 闻道汉家天子使，九华帐里梦魂惊。 揽衣推枕起徘徊，珠箔银屏迤逦开。 云鬓半偏新睡觉，花冠不整下堂来。 风吹仙袂飘飘举，犹似霓裳羽衣舞。 玉容寂寞泪阑干，梨花一枝春带雨。\n含情凝睇谢君王，一别音容两渺茫。 昭阳殿里恩爱绝，蓬莱宫中日月长。 回头下望人寰处，不见长安见尘雾。 唯将旧物表深情，钿合金钗寄将去。 钗留一股合一扇，钗擘黄金合分钿。 但教心似金钿坚，天上人间会相见。 临别殷勤重寄词，词中有誓两心知。 七月七日长生殿，夜半无人私语时。 在天愿作比翼鸟，在地愿为连理枝。 天长地久有时尽，此恨绵绵无绝期！\n","date":"2025-12-13T22:38:55+08:00","permalink":"http://localhost:1313/post/classic_literature/tang/baijuyi/chang_hen_ge/","tags":[""],"title":"《长恨歌》-白居易"},{"categories":["文学"],"contents":"琵琶行全文。\n《琵琶行》 【唐 白居易】 浔阳江头夜送客，枫叶荻花秋瑟瑟。 主人下马客在船，举酒欲饮无管弦。 醉不成欢惨将别，别时茫茫江浸月。\n忽闻水上琵琶声，主人忘归客不发。 寻声暗问弹者谁？琵琶声停欲语迟。 移船相近邀相见，添酒回灯重开宴。 千呼万唤始出来，犹抱琵琶半遮面。\n转轴拨弦三两声，未成曲调先有情。 弦弦掩抑声声思，似诉平生不得志。 低眉信手续续弹，说尽心中无限事。 轻拢慢捻抹复挑，初为《霓裳》后《六幺》。 大弦嘈嘈如急雨，小弦切切如私语。 嘈嘈切切错杂弹，大珠小珠落玉盘。 间关莺语花底滑，幽咽泉流冰下难。 冰泉冷涩弦凝绝，凝绝不通声暂歇。 别有幽愁暗恨生，此时无声胜有声。 银瓶乍破水浆迸，铁骑突出刀枪鸣。 曲终收拨当心画，四弦一声如裂帛。 东船西舫悄无言，唯见江心秋月白。\n沉吟放拨插弦中，整顿衣裳起敛容。 自言本是京城女，家在虾蟆陵下住。 十三学得琵琶成，名属教坊第一部。 曲罢曾教善才服，妆成每被秋娘妒。 五陵年少争缠头，一曲红绡不知数。 钿头银篦击节碎，血色罗裙翻酒污。 今年欢笑复明年，秋月春风等闲度。 弟走从军阿姨死，暮去朝来颜色故。 门前冷落鞍马稀，老大嫁作商人妇。 商人重利轻别离，前月浮梁买茶去。 去来江口守空船，绕船月明江水寒。 夜深忽梦少年事，梦啼妆泪红阑干。\n我闻琵琶已叹息，又闻此语重唧唧。 同是天涯沦落人，相逢何必曾相识！ 我从去年辞帝京，谪居卧病浔阳城。 浔阳地僻无音乐，终岁不闻丝竹声。 住近湓江地低湿，黄芦苦竹绕宅生。 其间旦暮闻何物？杜鹃啼血猿哀鸣。 春江花朝秋月夜，往往取酒还独倾。 岂无山歌与村笛？呕哑嘲哳难为听。 今夜闻君琵琶语，如听仙乐耳暂明。 莫辞更坐弹一曲，为君翻作《琵琶行》。\n感我此言良久立，却坐促弦弦转急。 凄凄不似向前声，满座重闻皆掩泣。 座中泣下谁最多？江州司马青衫湿。\n","date":"2025-12-13T22:33:52+08:00","permalink":"http://localhost:1313/post/classic_literature/tang/baijuyi/pi_pa_xing/","tags":[""],"title":"《琵琶行》- 白居易"},{"categories":[""],"contents":"卖炭翁全文\n《卖炭翁》 【唐 白居易】 卖炭翁，伐薪烧炭南山中。 满面尘灰烟火色，两鬓苍苍十指黑。 卖炭得钱何所营？身上衣裳口中食。 可怜身上衣正单，心忧炭贱愿天寒。 夜来城外一尺雪，晓驾炭车辗冰辙。 牛困人饥日已高，市南门外泥中歇。\n翩翩两骑来是谁？黄衣使者白衫儿。 手把文书口称敕，回车叱牛牵向北。 一车炭，千余斤，宫使驱将惜不得。 半匹红纱一丈绫，系向牛头充炭直。\n","date":"2025-12-13T22:31:05+08:00","permalink":"http://localhost:1313/post/classic_literature/tang/baijuyi/mai_tan_weng/","tags":[""],"title":"《卖炭翁》-白居易"},{"categories":["文学"],"contents":"本文搜集白居易诗歌。\n《赋得古原草送别》 【唐 白居易】 离离原上草， 一岁一枯荣。\n野火烧不尽， 春风吹又生。\n远芳侵古道， 晴翠接荒城。\n又送王孙去， 萋萋满别情。\n《大林寺桃花》\n唐·白居易\n人间四月芳菲尽，山寺桃花始盛开。\n长恨春归无觅处，不知转入此中来。\n《钱塘湖春行》\n白居易（唐）\n孤山寺北贾亭西，水面初平云脚低。\n几处早莺争暖树，谁家新燕啄春泥。\n乱花渐欲迷人眼，浅草才能没马蹄。\n最爱湖东行不足，绿杨阴里白沙堤。\n《暮江吟》\n唐·白居易\n一道残阳铺水中，半江瑟瑟半江红。\n可怜九月初三夜，露似真珠月似弓。\n","date":"2025-12-13T22:15:53+08:00","permalink":"http://localhost:1313/post/classic_literature/tang/baijuyi/poetry/","tags":[""],"title":"白居易诗歌"},{"categories":["文学"],"contents":"本文搜集刘禹锡经典诗歌。\n《西塞山怀古》 【唐· 刘禹锡】 王濬楼船下益州，金陵王气黯然收。 千寻铁锁沉江底，一片降幡出石头。 人世几回伤往事，山形依旧枕寒流。 今逢四海为家日，故垒萧萧芦荻秋。\n《乌衣巷》 【唐· 刘禹锡】 朱雀桥边野草花，乌衣巷口夕阳斜。 旧时王谢堂前燕，飞入寻常百姓家。\n《石头城》 【唐· 刘禹锡】 山围故国周遭在，潮打空城寂寞回。 淮水东边旧时月，夜深还过女墙来。\n《戏赠看花诸君子》 【唐· 刘禹锡】 紫陌红尘拂面来，无人不道看花回。 玄都观里桃千树，尽是刘郎去后栽。\n《再游玄都观》 【唐· 刘禹锡】 百亩庭中半是苔，桃花净尽菜花开。 种桃道士归何处？前度刘郎今又来。\n《聚蚊谣》 【唐· 刘禹锡】 沉沉夏夜闲堂开，飞蚊伺暗声如雷。 嘈然歘起初骇听，殷殷若自南山来。 喧腾鼓舞喜昏黑，昧者不分聪者惑。 露华滴沥月上天，利嘴迎人看不得。 我躯七尺尔如芒，我孤尔众能我伤。 天生有时不可遏，为尔设幄潜匡床。 清商一来秋日晓，羞尔微形饲丹鸟。\n《酬乐天扬州初逢席上见赠》 【唐· 刘禹锡】 巴山楚水凄凉地，二十三年弃置身。 怀旧空吟闻笛赋，到乡翻似烂柯人。 沉舟侧畔千帆过，病树前头万木春。 今日听君歌一曲，暂凭杯酒长精神。\n《秋词二首》 【唐· 刘禹锡】 其一 自古逢秋悲寂寥，我言秋日胜春朝。 晴空一鹤排云上，便引诗情到碧霄。\n其二 山明水净夜来霜，数树深红出浅黄。 试上高楼清入骨，岂如春色嗾人狂。\n《浪淘沙九首》（其八） 【唐· 刘禹锡】 莫道谗言如浪深，莫言迁客似沙沉。 千淘万漉虽辛苦，吹尽狂沙始到金。\n《竹枝词二首》（其一） 【唐· 刘禹锡】 杨柳青青江水平，闻郎江上唱歌声。 东边日出西边雨，道是无晴却有晴。\n《望洞庭》 【唐· 刘禹锡】 湖光秋月两相和，潭面无风镜未磨。 遥望洞庭山水翠，白银盘里一青螺。\n《酬乐天咏老见示》 【唐· 刘禹锡】 人谁不顾老，老去有谁怜？ 身瘦带频减，发稀冠自偏。 废书缘惜眼，多灸为随年。 经事还谙事，阅人如阅川。 细思皆幸矣，下此便翛然。 莫道桑榆晚，为霞尚满天。\n《乐天见示伤微之敦诗晦叔三君子皆有深分因成是诗以寄》 【唐· 刘禹锡】 吟君叹逝双绝句，使我伤怀奏短歌。 世上空惊故人少，集中惟觉察文多。 芳林新叶催陈叶，流水前波让后波。 万古到今同此恨，闻琴泪尽欲如何？\n《赠李司空妓》 【唐· 刘禹锡】 高髻云鬟宫样妆，春风一曲杜韦娘。 司空见惯浑闲事，断尽江南刺史肠。\n","date":"2025-12-13T22:07:55+08:00","permalink":"http://localhost:1313/post/classic_literature/tang/liu_yu_xi/","tags":[""],"title":"刘禹锡经典诗歌"},{"categories":["文学"],"contents":"本文搜集毛泽东经典诗词。\n《沁园春·长沙》\n毛泽东 独立寒秋，湘江北去，橘子洲头。 看万山红遍，层林尽染；漫江碧透，百舸争流。 鹰击长空，鱼翔浅底，万类霜天竞自由。 怅寥廓，问苍茫大地，谁主沉浮？\n携来百侣曾游。忆往昔峥嵘岁月稠。 恰同学少年，风华正茂；书生意气，挥斥方遒。 指点江山，激扬文字，粪土当年万户侯。 曾记否，到中流击水，浪遏飞舟？\n《七律·长征》 毛泽东 红军不怕远征难，万水千山只等闲。 五岭逶迤腾细浪，乌蒙磅礴走泥丸。 金沙水拍云崖暖，大渡桥横铁索寒。 更喜岷山千里雪，三军过后尽开颜。\n《沁园春·雪》 毛泽东 北国风光，千里冰封，万里雪飘。 望长城内外，惟余莽莽；大河上下，顿失滔滔。 山舞银蛇，原驰蜡象，欲与天公试比高。 须晴日，看红装素裹，分外妖娆。\n江山如此多娇，引无数英雄竞折腰。 惜秦皇汉武，略输文采；唐宗宋祖，稍逊风骚。 一代天骄，成吉思汗，只识弯弓射大雕。 俱往矣，数风流人物，还看今朝。\n《采桑子·重阳》 毛泽东 人生易老天难老，岁岁重阳。 今又重阳，战地黄花分外香。\n一年一度秋风劲，不似春光。 胜似春光，寥廓江天万里霜。\n《七律·人民解放军占领南京》 毛泽东 钟山风雨起苍黄，百万雄师过大江。 虎踞龙盘今胜昔，天翻地覆慨而慷。 宜将剩勇追穷寇，不可沽名学霸王。 天若有情天亦老，人间正道是沧桑。\n《水调歌头·游泳》 毛泽东 才饮长沙水，又食武昌鱼。 万里长江横渡，极目楚天舒。 不管风吹浪打，胜似闲庭信步，今日得宽馀。 子在川上曰：逝者如斯夫！\n风樯动，龟蛇静，起宏图。 一桥飞架南北，天堑变通途。 更立西江石壁，截断巫山云雨，高峡出平湖。 神女应无恙，当惊世界殊。\n《忆秦娥·娄山关》 毛泽东 西风烈，长空雁叫霜晨月。 霜晨月，马蹄声碎，喇叭声咽。\n雄关漫道真如铁，而今迈步从头越。 从头越，苍山如海，残阳如血。\n《七律·到韶山》 毛泽东 别梦依稀咒逝川，故园三十二年前。 红旗卷起农奴戟，黑手高悬霸主鞭。 为有牺牲多壮志，敢教日月换新天。 喜看稻菽千重浪，遍地英雄下夕烟。\n《水调歌头·重上井冈山》 毛泽东 久有凌云志，重上井冈山。 千里来寻故地，旧貌变新颜。 到处莺歌燕舞，更有潺潺流水，高路入云端。 过了黄洋界，险处不须看。\n风雷动，旌旗奋，是人寰。 三十八年过去，弹指一挥间。 可上九天揽月，可下五洋捉鳖，谈笑凯歌还。 世上无难事，只要肯登攀。\n","date":"2025-12-13T21:54:42+08:00","permalink":"http://localhost:1313/post/classic_literature/mao_ze_dong/","tags":[""],"title":"毛泽东经典诗词"},{"categories":["文学"],"contents":"本文搜集曹操经典诗歌\n《观沧海》 东汉·曹操\n东临碣石，以观沧海。 水何澹澹，山岛竦峙。 树木丛生，百草丰茂。 秋风萧瑟，洪波涌起。 日月之行，若出其中； 星汉灿烂，若出其里。 幸甚至哉，歌以咏志。\n《龟虽寿》 东汉·曹操 神龟虽寿，犹有竟时； 腾蛇乘雾，终为土灰。 老骥伏枥，志在千里； 烈士暮年，壮心不已。 盈缩之期，不但在天； 养怡之福，可得永年。 幸甚至哉，歌以咏志。\n《短歌行》 东汉·曹操 对酒当歌，人生几何！ 譬如朝露，去日苦多。 慨当以慷，忧思难忘。 何以解忧？唯有杜康。 青青子衿，悠悠我心。 但为君故，沉吟至今。 呦呦鹿鸣，食野之苹。 我有嘉宾，鼓瑟吹笙。 明明如月，何时可掇？ 忧从中来，不可断绝。 越陌度阡，枉用相存。 契阔谈讌，心念旧恩。 月明星稀，乌鹊南飞。 绕树三匝，何枝可依？ 山不厌高，海不厌深。 周公吐哺，天下归心。\n《蒿里行》 东汉·曹操 关东有义士，兴兵讨群凶。 初期会盟津，乃心在咸阳。 军合力不齐，踌躇而雁行。 势利使人争，嗣还自相戕。 淮南弟称号，刻玺于北方。 铠甲生虮虱，万姓以死亡。 白骨露于野，千里无鸡鸣。 生民百遗一，念之断人肠。\n《苦寒行》 东汉·曹操 北上太行山，艰哉何巍巍！ 羊肠坂诘屈，车轮为之摧。 树木何萧瑟，北风声正悲。 熊罴对我蹲，虎豹夹路啼。 溪谷少人民，雪落何霏霏！ 延颈长叹息，远行多所怀。 我心何怫郁？思欲一东归。 水深桥梁绝，中路正徘徊。 迷惑失故路，薄暮无宿栖。 行行日已远，人马同时饥。 担囊行取薪，斧冰持作糜。 悲彼《东山》诗，悠悠令我哀。\n","date":"2025-12-13T20:46:39+08:00","permalink":"http://localhost:1313/post/classic_literature/cao_cao/","tags":[""],"title":"曹操诗歌"},{"categories":["文学"],"contents":"本文搜集杜甫经典诗歌。\n《绝句四首》·其三\n【唐·杜甫】\n两个黄鹂鸣翠柳，一行白鹭上青天。\n窗含西岭千秋雪，门泊东吴万里船。\n《登高》 【唐·杜甫】 风急天高猿啸哀，渚清沙白鸟飞回。 无边落木萧萧下，不尽长江滚滚来。 万里悲秋常作客，百年多病独登台。 艰难苦恨繁霜鬓，潦倒新停浊酒杯。\n《蜀相》 【唐·杜甫】 丞相祠堂何处寻？锦官城外柏森森。 映阶碧草自春色，隔叶黄鹂空好音。 三顾频烦天下计，两朝开济老臣心。 出师未捷身先死，长使英雄泪满襟。\n《春望》\n杜甫（唐）\n国破山河在，城春草木深。\n感时花溅泪，恨别鸟惊心。\n烽火连三月，家书抵万金。\n白头搔更短，浑欲不胜簪。\n《春夜喜雨》 【唐·杜甫】 好雨知时节，当春乃发生。 随风潜入夜，润物细无声。 野径云俱黑，江船火独明。 晓看红湿处，花重锦官城。\n《望岳》\n【唐·杜甫】\n岱宗夫如何？齐鲁青未了。\n造化钟神秀，阴阳割昏晓。\n荡胸生曾云，决眦入归鸟。\n会当凌绝顶，一览众山小。\n《旅夜书怀》\n【唐·杜甫】\n细草微风岸，危樯独夜舟。\n星垂平野阔，月涌大江流。\n名岂文章著，官应老病休。\n飘飘何所似？天地一沙鸥。\n《登岳阳楼》 【唐·杜甫】 昔闻洞庭水，今上岳阳楼。 吴楚东南坼，乾坤日夜浮。 亲朋无一字，老病有孤舟。 戎马关山北，凭轩涕泗流。\n《江南逢李龟年》\n【唐·杜甫】\n岐王宅里寻常见，崔九堂前几度闻。\n正是江南好风景，落花时节又逢君。\n《月夜忆舍弟》 【唐·杜甫】 戍鼓断人行，边秋一雁声。 露从今夜白，月是故乡明。 有弟皆分散，无家问死生。 寄书长不达，况乃未休兵。\n《茅屋为秋风所破歌》\n杜甫（唐）\n八月秋高风怒号，卷我屋上三重茅。 茅飞渡江洒江郊，高者挂罥长林梢，下者飘转沉塘坳。 南村群童欺我老无力，忍能对面为盗贼。 公然抱茅入竹去，唇焦口燥呼不得，归来倚杖自叹息。 俄顷风定云墨色，秋天漠漠向昏黑。 布衾多年冷似铁，娇儿恶卧踏里裂。 床头屋漏无干处，雨脚如麻未断绝。 自经丧乱少睡眠，长夜沾湿何由彻！ 安得广厦千万间，大庇天下寒士俱欢颜！风雨不动安如山。 呜呼！何时眼前突兀见此屋，吾庐独破受冻死亦足！\n《兵车行》 【唐·杜甫】 车辚辚，马萧萧，行人弓箭各在腰。 爷娘妻子走相送，尘埃不见咸阳桥。 牵衣顿足拦道哭，哭声直上干云霄。\n道旁过者问行人，行人但云点行频。 或从十五北防河，便至四十西营田。 去时里正与裹头，归来头白还戍边。 边庭流血成海水，武皇开边意未已。 君不闻汉家山东二百州，千村万落生荆杞。 纵有健妇把锄犁，禾生陇亩无东西。 况复秦兵耐苦战，被驱不异犬与鸡。\n长者虽有问，役夫敢申恨？ 且如今年冬，未休关西卒。 县官急索租，租税从何出？ 信知生男恶，反是生女好。 生女犹得嫁比邻，生男埋没随百草。\n君不见青海头，古来白骨无人收。 新鬼烦冤旧鬼哭，天阴雨湿声啾啾。\n《自京赴奉先县咏怀五百字》 【唐·杜甫】 杜陵有布衣，老大意转拙。 许身一何愚，窃比稷与契。 居然成濩落，白首甘契阔。 盖棺事则已，此志常觊豁。 穷年忧黎元，叹息肠内热。 取笑同学翁，浩歌弥激烈。 非无江海志，潇洒送日月。 生逢尧舜君，不忍便永诀。 当今廊庙具，构厦岂云缺？ 葵藿倾太阳，物性固莫夺。 顾惟蝼蚁辈，但自求其穴。 胡为慕大鲸，辄拟偃溟渤？ 以兹悟生理，独耻事干谒。 兀兀遂至今，忍为尘埃没。 终愧巢与由，未能易其节。 沉饮聊自遣，放歌破愁绝。\n岁暮百草零，疾风高冈裂。 天衢阴峥嵘，客子中夜发。 霜严衣带断，指直不能结。 凌晨过骊山，御榻在嵽嵲。 蚩尤塞寒空，蹴踏崖谷滑。 瑶池气郁律，羽林相摩戛。 君臣留欢娱，乐动殷樛嶱。 赐浴皆长缨，与宴非短褐。 彤庭所分帛，本自寒女出。 鞭挞其夫家，聚敛贡城阙。 圣人筐篚恩，实欲邦国活。 臣如忽至理，君岂弃此物？ 多士盈朝廷，仁者宜战栗。 况闻内金盘，尽在卫霍室。 中堂有神仙，烟雾蒙玉质。 煖客貂鼠裘，悲管逐清瑟。 劝客驼蹄羹，霜橙压香橘。 朱门酒肉臭，路有冻死骨。 荣枯咫尺异，惆怅难再述。\n北辕就泾渭，官渡又改辙。 群冰从西下，极目高崒兀。 疑是崆峒来，恐触天柱折。 河梁幸未坼，枝撑声窸窣。 行旅相攀援，川广不可越。 老妻寄异县，十口隔风雪。 谁能久不顾？庶往共饥渴。 入门闻号咷，幼子饥已卒。 吾宁舍一哀？里巷亦呜咽。 所愧为人父，无食致夭折。 岂知秋禾登，贫窭有仓卒。 生常免租税，名不隶征伐。 抚迹犹酸辛，平人固骚屑。 默思失业徒，因念远戍卒。 忧端齐终南，澒洞不可掇。\n《石壕吏》 【唐·杜甫】 暮投石壕村，有吏夜捉人。 老翁逾墙走，老妇出门看。 吏呼一何怒！妇啼一何苦！ 听妇前致词：三男邺城戍。 一男附书至，二男新战死。 存者且偷生，死者长已矣！ 室中更无人，惟有乳下孙。 有孙母未去，出入无完裙。 老妪力虽衰，请从吏夜归。 急应河阳役，犹得备晨炊。 夜久语声绝，如闻泣幽咽。 天明登前途，独与老翁别。\n《新安吏》 【唐·杜甫】 客行新安道，喧呼闻点兵。 借问新安吏：“县小更无丁？” 府帖昨夜下，次选中男行。 “中男绝短小，何以守王城？” 肥男有母送，瘦男独伶俜。 白水暮东流，青山犹哭声。 “莫自使眼枯，收汝泪纵横。 眼枯即见骨，天地终无情！ 我军取相州，日夕望其平。 岂意贼难料，归军星散营。 就粮近故垒，练卒依旧京。 掘壕不到水，牧马役亦轻。 况乃王师顺，抚养甚分明。 送行勿泣血，仆射如父兄。”\n《潼关吏》\n【唐·杜甫】 士卒何草草，筑城潼关道。 大城铁不如，小城万丈余。 借问潼关吏：“修关还备胡？” 要我下马行，为我指山隅： “连云列战格，飞鸟不能逾。 胡来但自守，岂复忧西都。 丈人视要处，窄狭容单车。 艰难奋长戟，万古用一夫。” “哀哉桃林战，百万化为鱼。 请嘱防关将，慎勿学哥舒！”\n《新婚别》 【唐·杜甫】 兔丝附蓬麻，引蔓故不长。 嫁女与征夫，不如弃路旁。 结发为君妻，席不暖君床。 暮婚晨告别，无乃太匆忙！ 君行虽不远，守边赴河阳。 妾身未分明，何以拜姑嫜？ 父母养我时，日夜令我藏。 生女有所归，鸡狗亦得将。 君今往死地，沉痛迫中肠。 誓欲随君去，形势反苍黄。 勿为新婚念，努力事戎行！ 妇人在军中，兵气恐不扬。 自嗟贫家女，久致罗襦裳。 罗襦不复施，对君洗红妆。 仰视百鸟飞，大小必双翔。 人事多错迕，与君永相望。\n《无家别》 【唐·杜甫】 寂寞天宝后，园庐但蒿藜。 我里百余家，世乱各东西。 存者无消息，死者为尘泥。 贱子因阵败，归来寻旧蹊。 久行见空巷，日瘦气惨凄。 但对狐与狸，竖毛怒我啼。 四邻何所有？一二老寡妻。 宿鸟恋本枝，安辞且穷栖。 方春独荷锄，日暮还灌畦。 县吏知我至，召令习鼓鞞。 虽从本州役，内顾无所携。 近行止一身，远去终转迷。 家乡既荡尽，远近理亦齐。 永痛长病母，五年委沟溪。 生我不得力，终身两酸嘶。 人生无家别，何以为蒸黎！\n《垂老别》 【唐·杜甫】 四郊未宁静，垂老不得安。 子孙阵亡尽，焉用身独完！ 投杖出门去，同行为辛酸。 幸有牙齿存，所悲骨髓干。 男儿既介胄，长揖别上官。 老妻卧路啼，岁暮衣裳单。 孰知是死别，且复伤其寒。 此去必不归，还闻劝加餐。 土门壁甚坚，杏园度亦难。 势异邺城下，纵死时犹宽。 人生有离合，岂择衰老端？ 忆昔少壮日，迟回竟长叹。 万国尽征戍，烽火被冈峦。 积尸草木腥，流血川原丹。 何乡为乐土？安敢尚盘桓！ 弃绝蓬室居，塌然摧肺肝。\n","date":"2025-12-13T20:45:23+08:00","permalink":"http://localhost:1313/post/classic_literature/tang/dufu/","tags":[""],"title":"杜甫经典诗歌"},{"categories":["文学"],"contents":"《梦游天姥吟留别》全文。\nmèng yóu tiān mǔ yín liú bié 梦游天姥吟留别 【唐 李白】\nhǎi kè tán yíng zhōu ， yān tāo wēi máng xìn nán qiú ； 海客谈瀛洲，烟涛微茫信难求； yuè rén yǔ tiān mǔ ， yún xiá míng miè huò kě dǔ 。 越人语天姥，云霞明灭或可睹。 tiān mǔ lián tiān xiàng tiān héng ， shì bá wǔ yuè yǎn chì chéng 。 天姥连天向天横，势拔五岳掩赤城。 tiān tāi sì wàn bā qiān zhàng ， duì cǐ yù dǎo dōng nán qīng 。 天台四万八千丈，对此欲倒东南倾。 wǒ yù yīn zhī mèng wú yuè ， yī yè fēi dù jìng hú yuè 。 我欲因之梦吴越，一夜飞度镜湖月。 hú yuè zhào wǒ yǐng ， sòng wǒ zhì shàn xī 。 湖月照我影，送我至剡溪。 xiè gōng sù chù jīn shàng zài ， lù shuǐ dàng yàng qīng yuán tí 。 谢公宿处今尚在，渌水荡漾清猿啼。 jiǎo zhuó xiè gōng jī ， shēn dēng qīng yún tī 。 脚著谢公屐，身登青云梯。 bàn bì jiàn hǎi rì ， kōng zhōng wén tiān jī 。 半壁见海日，空中闻天鸡。 qiān yán wàn zhuǎn lù bù dìng ， mí huā yǐ shí hū yǐ míng 。 千岩万转路不定，迷花倚石忽已暝。 xióng páo lóng yín yǐn yán quán ， lì shēn lín xī jīng céng diān 。 熊咆龙吟殷岩泉，栗深林兮惊层巅。 yún qīng qīng xī yù yǔ ， shuǐ dàn dàn xī shēng yān 。 云青青兮欲雨，水澹澹兮生烟。 liè quē pī lì ， qiū luán bēng cuī 。 列缺霹雳，丘峦崩摧。 dòng tiān shí fēi ， hōng rán zhōng kāi 。 洞天石扉，訇然中开。 qīng míng hào dàng bú jiàn dǐ ， rì yuè zhào yào jīn yín tái 。 青冥浩荡不见底，日月照耀金银台。 ní wéi yī xī fēng wéi mǎ ， yún zhī jūn xī fēn fēn ér lái xià 。 霓为衣兮风为马，云之君兮纷纷而来下。 hǔ gǔ sè xī luán huí chē ， xiān zhī rén xī liè rú má 。 虎鼓瑟兮鸾回车，仙之人兮列如麻。 hū hún jì yǐ pò dòng ， huǎng jīng qǐ ér cháng jiē 。 忽魂悸以魄动，恍惊起而长嗟。 wéi jué shí zhī zhěn xí ， shī xiàng lái zhī yān xiá 。 惟觉时之枕席，失向来之烟霞。 shì jiān xíng lè yì rú cǐ ， gǔ lái wàn shì dōng liú shuǐ 。 世间行乐亦如此，古来万事东流水。 bié jūn qù xī hé shí huán ？ qiě fàng bái lù qīng yá jiān ， xū xíng jí qí fǎng míng shān 。 别君去兮何时还？且放白鹿青崖间，须行即骑访名山。 ān néng cuī méi zhé yāo shì quán guì ， shǐ wǒ bù dé kāi xīn yán ！ 安能摧眉折腰事权贵，使我不得开心颜！\n赏析： 诗人以虚衬实，以瀛洲的“难求”反衬天姥的“可睹”，引出梦境。梦中登高涉险、仙境乍现的瑰丽场景，实为诗人精神世界的投射。 梦醒后慨叹“万事东流水”，最终迸发出 “安能摧眉折腰事权贵，使我不得开心颜！” 这一千古名句，将全诗推向高潮，彰显了诗人蔑视权贵、追求自由人格的傲岸精神。\n此诗与《蜀道难》、《将进酒》同属李白歌行体代表作，想象奇谲，笔力纵横，充分展现了其“笔落惊风雨，诗成泣鬼神”的艺术魅力。\n","date":"2025-12-13T19:53:59+08:00","permalink":"http://localhost:1313/post/classic_literature/tang/libai/meng_you_tian_mu_yin_liu_bie/","tags":[""],"title":"《梦游天姥吟留别》- 李白"},{"categories":["文学"],"contents":"《蜀道难》-唐 李白\nshǔ dào nán 蜀道难\nyī xū xī ， wēi hū gāo zāi ！ shǔ dào zhī nán ， nán yú shàng qīng tiān ！ 噫吁嚱，危乎高哉！蜀道之难，难于上青天！ cán cóng jí yú fú ， kāi guó hé máng rán ！ 蚕丛及鱼凫，开国何茫然！ ěr lái sì wàn bā qiān suì ， bù yǔ qín sāi tōng rén yān 。 尔来四万八千岁，不与秦塞通人烟。 xī dāng tài bái yǒu niǎo dào ， kě yǐ héng jué é méi diān 。 西当太白有鸟道，可以横绝峨眉巅。 dì bēng shān cuī zhuàng shì sǐ ， rán hòu tiān tī shí zhàn xiāng gōu lián 。 地崩山摧壮士死，然后天梯石栈相钩连。 shàng yǒu liù lóng huí rì zhī gāo biāo ， xià yǒu chōng bō nì zhé zhī huí chuān 。 上有六龙回日之高标，下有冲波逆折之回川。 huáng hè zhī fēi shàng bù dé guò ， yuán náo yù dù chóu pān yuán 。 黄鹤之飞尚不得过，猿猱欲度愁攀援。 qīng ní hé pán pán ， bǎi bù jiǔ zhé yíng yán luán 。 青泥何盘盘，百步九折萦岩峦。 mén shēn lì jǐng yǎng xié xī ， yǐ shǒu fǔ yīng zuò cháng tàn 。 扪参历井仰胁息，以手抚膺坐长叹。 wèn jūn xī yóu hé shí huán ？ wèi tú chán yán bù kě pān 。 问君西游何时还？畏途巉岩不可攀。 dàn jiàn bēi niǎo háo gǔ mù ， xióng fēi cí cóng rào lín jiān 。 但见悲鸟号古木，雄飞雌从绕林间。 yòu wén zǐ guī tí yè yuè ， chóu kōng shān 。 又闻子规啼夜月，愁空山。 shǔ dào zhī nán ， nán yú shàng qīng tiān ， shǐ rén tīng cǐ diāo zhū yán ！ 蜀道之难，难于上青天，使人听此凋朱颜！ lián fēng qù tiān bù yíng chǐ ， kū sōng dào guà yǐ jué bì 。 连峰去天不盈尺，枯松倒挂倚绝壁。 fēi tuān pù liú zhēng xuān huī ， pīng yá zhuǎn shí wàn hè léi 。 飞湍瀑流争喧豗，砯崖转石万壑雷。 qí xiǎn yě rú cǐ ， jiē ēr yuǎn dào zhī rén hú wéi hū lái zāi ！ 其险也如此，嗟尔远道之人胡为乎来哉！ jiàn gé zhēng róng ér cuī wéi ， yī fū dāng guān ， wàn fū mò kāi 。 剑阁峥嵘而崔嵬，一夫当关，万夫莫开。 suǒ shǒu huò fěi qīn ， huà wéi láng yǔ chái 。 所守或匪亲，化为狼与豺。 zhāo bì měng hǔ ， xī bì cháng shé ， mó yá shǔn xuè ， shā rén rú má 。 朝避猛虎，夕避长蛇，磨牙吮血，杀人如麻。 jǐn chéng suī yún lè ， bù rú zǎo huán jiā 。 锦城虽云乐，不如早还家。 shǔ dào zhī nán ， nán yú shàng qīng tiān ， cè shēn xī wàng cháng zī jiē ！ 蜀道之难，难于上青天，侧身西望长咨嗟！\n","date":"2025-12-13T19:49:54+08:00","permalink":"http://localhost:1313/post/classic_literature/tang/libai/shu_dao_nan/","tags":[""],"title":"《蜀道难》- 李白"},{"categories":["文学"],"contents":"本文搜集李清照著名宋词。\n《夏日绝句》 【宋·李清照】\n生当作人杰，死亦为鬼雄。\n至今思项羽，不肯过江东。\n《渔家傲·天接云涛连晓雾》\n【宋·李清照】\n天接云涛连晓雾， 星河欲转千帆舞。\n仿佛梦魂归帝所， 闻天语，殷勤问我归何处。\n我报路长嗟日暮， 学诗谩有惊人句。\n九万里风鹏正举。 风休住，蓬舟吹取三山去！\n《如梦令·常记溪亭日暮》\n【宋·李清照】\n常记溪亭日暮，沉醉不知归路。 兴尽晚回舟，误入藕花深处。\n争渡，争渡，惊起一滩鸥鹭。\n","date":"2025-12-13T19:46:26+08:00","permalink":"http://localhost:1313/post/classic_literature/song/li_qing_zhao/","tags":[""],"title":"李清照宋词"},{"categories":["文学"],"contents":"本文搜集陆游诗词。\n《示儿》\n【宋 · 陆游】\n死去元知万事空，但悲不见九州同。\n王师北定中原日，家祭无忘告乃翁。\n《书愤》\n【宋 · 陆游】\n早岁那知世事艰，中原北望气如山。\n楼船夜雪瓜洲渡，铁马秋风大散关。\n塞上长城空自许，镜中衰鬓已先斑。\n出师一表真名世，千载谁堪伯仲间！\n《十一月四日风雨大作（其二）》\n【宋 · 陆游】\n僵卧孤村不自哀，尚思为国戍轮台。\n夜阑卧听风吹雨，铁马冰河入梦来。\n《游山西村》\n【宋 · 陆游】\n莫笑农家腊酒浑，丰年留客足鸡豚。\n山重水复疑无路，柳暗花明又一村。\n箫鼓追随春社近，衣冠简朴古风存。\n从今若许闲乘月，拄杖无时夜叩门。\n《卜算子·咏梅》\n【宋 · 陆游】\n驿外断桥边，寂寞开无主。\n已是黄昏独自愁，更著风和雨。\n无意苦争春，一任群芳妒。\n零落成泥碾作尘，只有香如故。\n《临安春雨初霁》\n【宋 · 陆游】\n世味年来薄似纱，谁令骑马客京华？\n小楼一夜听春雨，深巷明朝卖杏花。\n矮纸斜行闲作草，晴窗细乳戏分茶。\n素衣莫起风尘叹，犹及清明可到家。\n《病起书怀》 【宋 · 陆游】 病骨支离纱帽宽，孤臣万里客江干。 位卑未敢忘忧国，事定犹须待阖棺。 天地神灵扶庙社，京华父老望和銮。 出师一表通今古，夜半挑灯更细看。\n《关山月》 【宋 · 陆游】 和戎诏下十五年，将军不战空临边。 朱门沉沉按歌舞，厩马肥死弓断弦！ 戍楼刁斗催落月，三十从军今白发。 笛里谁知壮士心？沙头空照征人骨。 中原干戈古亦闻，岂有逆胡传子孙！ 遗民忍死望恢复，几处今宵垂泪痕。\n《钗头凤·红酥手》 【宋 · 陆游】 红酥手，黄縢酒，满城春色宫墙柳。 东风恶，欢情薄。一怀愁绪，几年离索。错、错、错！\n春如旧，人空瘦，泪痕红浥鲛绡透。 桃花落，闲池阁。山盟虽在，锦书难托。莫、莫、莫！\n《沈园二首》 【宋 · 陆游】 其一 城上斜阳画角哀，沈园非复旧池台。 伤心桥下春波绿，曾是惊鸿照影来。\n其二 梦断香消四十年，沈园柳老不吹绵。 此身行作稽山土，犹吊遗踪一泫然。\n《冬夜读书示子聿》其三· 【宋 · 陆游】 古人学问无遗力，少壮工夫老始成。 纸上得来终觉浅，绝知此事要躬行。\n《梅花绝句》 【宋 · 陆游】 闻道梅花坼晓风，雪堆遍满四山中。 何方可化身千亿？一树梅花一放翁。\n《文章》 【宋 · 陆游】 文章本天成，妙手偶得之。 粹然无疵瑕，岂复须人为？ 君看古彝器，巧拙两无施。 汉最近先秦，固已殊淳漓。 胡部何为者，豪竹杂哀丝。 后夔不复作，千载谁与期？\n","date":"2025-12-13T19:39:41+08:00","permalink":"http://localhost:1313/post/classic_literature/song/luyou/","tags":[""],"title":"陆游诗词"},{"categories":["文学"],"contents":"将进酒全文。\n《将进酒》\n【唐 李白】 君不见黄河之水天上来，奔流到海不复回。\n君不见高堂明镜悲白发，朝如青丝暮成雪。\n人生得意须尽欢，莫使金樽空对月。\n天生我材必有用，千金散尽还复来。\n烹羊宰牛且为乐，会须一饮三百杯。\n岑夫子，丹丘生，将进酒，杯莫停。\n与君歌一曲，请君为我倾耳听。\n钟鼓馔玉不足贵，但愿长醉不愿醒。\n古来圣贤皆寂寞，惟有饮者留其名。\n陈王昔时宴平乐，斗酒十千恣欢谑。\n主人何为言少钱，径须沽取对君酌。\n五花马，千金裘，呼儿将出换美酒，与尔同销万古愁。\n","date":"2025-12-13T19:33:44+08:00","permalink":"http://localhost:1313/post/classic_literature/tang/libai/qiang_jin_jiu/","tags":[""],"title":"《将进酒》- 李白"},{"categories":["文学"],"contents":"本文搜集李白的经典的古诗词。\n《古朗月行》\n【唐·李白】\n小时不识月，呼作白玉盘。\n又疑瑶台镜，飞在青云端。\n《早发白帝城》\n【唐·李白】\n朝辞白帝彩云间，千里江陵一日还。\n两岸猿声啼不住，轻舟已过万重山。\n《望庐山瀑布》\n【唐·李白】\n日照香炉生紫烟，遥看瀑布挂前川。\n飞流直下三千尺，疑是银河落九天。\n《赠汪伦》 【唐·李白】\n李白乘舟将欲行，忽闻岸上踏歌声。\n桃花潭水深千尺，不及汪伦送我情。\n《闻王昌龄左迁龙标遥有此寄》\n【唐·李白】\n杨花落尽子规啼，闻道龙标过五溪。\n我寄愁心与明月，随君直到夜郎西。\n《峨眉山月歌》 【唐·李白】\n峨眉山月半轮秋，影入平羌江水流。\n夜发清溪向三峡，思君不见下渝州。\n《春夜洛城闻笛》\n【唐·李白】\n谁家玉笛暗飞声，散入春风满洛城。\n此夜曲中闻折柳，何人不起故园情！\n《渡荆门送别》\n【唐·李白】\n渡远荆门外，来从楚国游。\n山随平野尽，江入大荒流。\n月下飞天镜，云生结海楼。\n仍怜故乡水，万里送行舟。\n《送友人》\n【唐·李白】\n青山横北郭，白水绕东城。\n此地一为别，孤蓬万里征。\n浮云游子意，落日故人情。\n挥手自兹去，萧萧班马鸣。\n《行路难·其一》\n【唐·李白】\n金樽清酒斗十千，玉盘珍羞直万钱。\n停杯投箸不能食，拔剑四顾心茫然。\n欲渡黄河冰塞川，将登太行雪满山。\n闲来垂钓碧溪上，忽复乘舟梦日边。\n行路难，行路难，多歧路，今安在？\n长风破浪会有时，直挂云帆济沧海。\n《黄鹤楼送孟浩然之广陵》\n【唐·李白】 故人西辞黄鹤楼，烟花三月下扬州。\n孤帆远影碧空尽，唯见长江天际流。\n《宣州谢朓楼饯别校书叔云》\n【唐·李白】\n弃我去者，昨日之日不可留；\n乱我心者，今日之日多烦忧。\n长风万里送秋雁，对此可以酣高楼。\n蓬莱文章建安骨，中间小谢又清发。\n俱怀逸兴壮思飞，欲上青天揽明月。\n抽刀断水水更流，举杯销愁愁更愁。\n人生在世不称意，明朝散发弄扁舟。\n《月下独酌·其一》\n【唐·李白】\n花间一壶酒，独酌无相亲。\n举杯邀明月，对影成三人。\n月既不解饮，影徒随我身。\n暂伴月将影，行乐须及春。\n我歌月徘徊，我舞影零乱。\n醒时同交欢，醉后各分散。\n永结无情游，相期邈云汉。\n《关山月》\n【唐·李白】\n明月出天山，苍茫云海间。\n长风几万里，吹度玉门关。\n汉下白登道，胡窥青海湾。\n由来征战地，不见有人还。\n戍客望边色，思归多苦颜。\n高楼当此夜，叹息未应闲。\n","date":"2025-12-13T19:25:52+08:00","permalink":"http://localhost:1313/post/classic_literature/tang/libai/poetry/","tags":[""],"title":"李白古诗"},{"categories":["文学"],"contents":"本文搜集经典的古诗。\n古诗 《画》\n远看山有色，近听水无声。 春去花还在，人来鸟不惊。\n《咏鹅》\n【唐 骆宾王】\n鹅，鹅，鹅，曲项向天歌。\n白毛浮绿水，红掌拨清波。\n《悯农》\n【唐·李绅】\n锄禾日当午，汗滴禾下土。\n谁知盘中餐，粒粒皆辛苦。\n《春晓》\n【唐 孟浩然】\n春眠不觉晓，处处闻啼鸟。\n夜来风雨声，花落知多少。\n《寻隐者不遇》\n【唐·贾岛】\n松下问童子，言师采药去。\n只在此山中，云深不知处。\n《村居》\n【清·高鼎】\n草长莺飞二月天，拂堤杨柳醉春烟。\n儿童散学归来早，忙趁东风放纸鸢。\n《咏柳》\n【唐·贺知章】\n碧玉妆成一树高，万条垂下绿丝绦。\n不知细叶谁裁出，二月春风似剪刀。\n《晓出净慈寺送林子方》\n【宋·杨万里】\n毕竟西湖六月中，风光不与四时同。\n接天莲叶无穷碧，映日荷花别样红。\n《舟夜书所见》\n【清·查慎行】\n月黑见渔灯，孤光一点萤。\n微微风簇浪，散作满河星。\n《所见》\n清·袁枚\n牧童骑黄牛，歌声振林樾。\n意欲捕鸣蝉，忽然闭口立。\n《山行》\n唐·杜牧\n远上寒山石径斜，白云生处有人家。\n停车坐爱枫林晚，霜叶红于二月花。\n《赠刘景文》\n宋·苏轼\n荷尽已无擎雨盖，菊残犹有傲霜枝。\n一年好景君须记，最是橙黄橘绿时。\n《夜书所见》\n宋·叶绍翁\n萧萧梧叶送寒声，江上秋风动客情。\n知有儿童挑促织，夜深篱落一灯明。\n《元日》\n宋·王安石\n爆竹声中一岁除，春风送暖入屠苏。\n千门万户曈曈日，总把新桃换旧符。\n《清明》\n唐·杜牧\n清明时节雨纷纷，路上行人欲断魂。\n借问酒家何处有？牧童遥指杏花村。\n《九月九日忆山东兄弟》\n唐·王维\n独在异乡为异客，每逢佳节倍思亲。\n遥知兄弟登高处，遍插茱萸少一人。\n《滁州西涧》\n唐·韦应物\n独怜幽草涧边生，上有黄鹂深树鸣。\n春潮带雨晚来急，野渡无人舟自横。\n《鹿柴》\n唐·王维\n空山不见人，但闻人语响。\n返景入深林，复照青苔上。\n《题西林壁》\n宋·苏轼\n横看成岭侧成峰，远近高低各不同。\n不识庐山真面目，只缘身在此山中。\n《雪梅》\n宋·卢钺\n梅雪争春未肯降，骚人搁笔费评章。\n梅须逊雪三分白，雪却输梅一段香。\n《出塞》\n唐·王昌龄\n秦时明月汉时关，万里长征人未还。\n但使龙城飞将在，不教胡马度阴山。\n《凉州词》\n唐·王翰\n葡萄美酒夜光杯，欲饮琵琶马上催。\n醉卧沙场君莫笑，古来征战几人回？\n《四时田园杂兴》（其二十五）\n宋·范成大\n梅子金黄杏子肥，麦花雪白菜花稀。\n日长篱落无人过，惟有蜻蜓蛱蝶飞。\n《宿新市徐公店》\n宋·杨万里\n篱落疏疏一径深，树头新绿未成阴。\n儿童急走追黄蝶，飞入菜花无处寻。\n《清平乐·村居》\n宋·辛弃疾\n茅檐低小，溪上青青草。\n醉里吴音相媚好，白发谁家翁媪？\n大儿锄豆溪东，中儿正织鸡笼。\n最喜小儿亡赖，溪头卧剥莲蓬。\n《芙蓉楼送辛渐》\n唐·王昌龄\n寒雨连江夜入吴，平明送客楚山孤。\n洛阳亲友如相问，一片冰心在玉壶。\n《塞下曲》\n唐·卢纶\n月黑雁飞高，单于夜遁逃。\n欲将轻骑逐，大雪满弓刀。\n《墨梅》\n元·王冕\n我家洗砚池头树，朵朵花开淡墨痕。\n不要人夸好颜色，只留清气满乾坤。\n《题临安邸》\n宋·林升 山外青山楼外楼，西湖歌舞几时休？\n暖风熏得游人醉，直把杭州作汴州。\n《己亥杂诗》（其二百二十）\n清·龚自珍\n九州生气恃风雷，万马齐喑究可哀。\n我劝天公重抖擞，不拘一格降人材。\n《山居秋暝》\n唐·王维\n空山新雨后，天气晚来秋。\n明月松间照，清泉石上流。\n竹喧归浣女，莲动下渔舟。\n随意春芳歇，王孙自可留。\n《枫桥夜泊》\n唐·张继\n月落乌啼霜满天，江枫渔火对愁眠。\n姑苏城外寒山寺，夜半钟声到客船。\n《宿建德江》\n唐·孟浩然\n移舟泊烟渚，日暮客愁新。\n野旷天低树，江清月近人。\n《六月二十七日望湖楼醉书》\n宋·苏轼\n黑云翻墨未遮山，白雨跳珠乱入船。\n卷地风来忽吹散，望湖楼下水如天。\n《西江月·夜行黄沙道中》\n宋·辛弃疾\n明月别枝惊鹊，清风半夜鸣蝉。\n稻花香里说丰年，听取蛙声一片。\n七八个星天外，两三点雨山前。\n旧时茅店社林边，路转溪桥忽见。\n《浪淘沙》（其一）\n唐·刘禹锡\n九曲黄河万里沙，浪淘风簸自天涯。\n如今直上银河去，同到牵牛织女家。\n《江南春》\n唐·杜牧\n千里莺啼绿映红，水村山郭酒旗风。\n南朝四百八十寺，多少楼台烟雨中。\n《书湖阴先生壁》\n宋·王安石\n茅檐长扫净无苔，花木成畦手自栽。\n一水护田将绿绕，两山排闼送青来。\n《寒食》\n唐·韩翃\n春城无处不飞花，寒食东风御柳斜。\n日暮汉宫传蜡烛，轻烟散入五侯家。\n《迢迢牵牛星》\n东汉·无名氏（选自《古诗十九首》）\n迢迢牵牛星，皎皎河汉女。\n纤纤擢素手，札札弄机杼。\n终日不成章，泣涕零如雨。 河汉清且浅，相去复几许？\n盈盈一水间，脉脉不得语。\n《十五夜望月》\n唐·王建\n中庭地白树栖鸦，冷露无声湿桂花。\n今夜月明人尽望，不知秋思落谁家。\n《长歌行》\n汉·乐府诗（选自《乐府诗集》）\n青青园中葵，朝露待日晞。\n阳春布德泽，万物生光辉。\n常恐秋节至，焜黄华叶衰。\n百川东到海，何时复西归？\n少壮不努力，老大徒伤悲！\n《马诗》（其五）\n唐·李贺\n大漠沙如雪，燕山月似钩。\n何当金络脑，快走踏清秋。\n《石灰吟》\n明·于谦\n千锤万凿出深山，烈火焚烧若等闲。\n粉骨碎身浑不怕，要留清白在人间。\n《竹石》\n清·郑燮（郑板桥）\n咬定青山不放松，立根原在破岩中。\n千磨万击还坚劲，任尔东西南北风。\n《次北固山下》 唐·王湾\n客路青山外，行舟绿水前。\n潮平两岸阔，风正一帆悬。\n海日生残夜，江春入旧年。\n乡书何处达？归雁洛阳边。\n《天净沙·秋思》 元·马致远\n枯藤老树昏鸦，小桥流水人家，古道西风瘦马。\n夕阳西下，断肠人在天涯。\n《行军九日思长安故园》\n唐·岑参\n强欲登高去，无人送酒来。\n遥怜故园菊，应傍战场开。\n《夜上受降城闻笛》\n唐·李益\n回乐烽前沙似雪，受降城外月如霜。\n不知何处吹芦管，一夜征人尽望乡。\n《秋词（其一）》\n唐·刘禹锡\n自古逢秋悲寂寥，我言秋日胜春朝。\n晴空一鹤排云上，便引诗情到碧霄。\n《夜雨寄北》 唐·李商隐\n君问归期未有期，巴山夜雨涨秋池。 何当共剪西窗烛，却话巴山夜雨时。\n《潼关》\n清·谭嗣同\n终古高云簇此城，秋风吹散马蹄声。\n河流大野犹嫌束，山入潼关不解平。\n《竹里馆》 唐·王维\n独坐幽篁里，弹琴复长啸。 深林人不知，明月来相照。\n《逢入京使》\n唐·岑参\n故园东望路漫漫，双袖龙钟泪不干。\n马上相逢无纸笔，凭君传语报平安。\n《晚春》\n唐·韩愈\n草树知春不久归，百般红紫斗芳菲。\n杨花榆荚无才思，惟解漫天作雪飞。\n《登幽州台歌》\n唐·陈子昂\n前不见古人，后不见来者。\n念天地之悠悠，独怆然而涕下！\n《登飞来峰》\n北宋·王安石\n飞来山上千寻塔，闻说鸡鸣见日升。\n不畏浮云遮望眼，自缘身在最高层。\n《己亥杂诗（其五）》\n清·龚自珍\n浩荡离愁白日斜，吟鞭东指即天涯。\n落红不是无情物，化作春泥更护花。\n《泊秦淮》\n唐·杜牧\n烟笼寒水月笼沙，夜泊秦淮近酒家。\n商女不知亡国恨，隔江犹唱后庭花。\n《贾生》\n唐·李商隐\n宣室求贤访逐臣，贾生才调更无伦。\n可怜夜半虚前席，不问苍生问鬼神。\n《过松源晨炊漆公店（其五）》\n南宋·杨万里\n莫言下岭便无难，赚得行人错喜欢。\n正入万山围子里，一山放出一山拦。\n《约客》\n南宋·赵师秀\n黄梅时节家家雨，青草池塘处处蛙。\n有约不来过夜半，闲敲棋子落灯花。\n《野望》\n王绩（唐）\n东皋薄暮望，徙倚欲何依。\n树树皆秋色，山山唯落晖。\n牧人驱犊返，猎马带禽归。\n相顾无相识，长歌怀采薇。\n《黄鹤楼》\n崔颢（唐）\n昔人已乘黄鹤去，此地空余黄鹤楼。\n黄鹤一去不复返，白云千载空悠悠。\n晴川历历汉阳树，芳草萋萋鹦鹉洲。\n日暮乡关何处是？烟波江上使人愁。\n《使至塞上》\n王维（唐）\n单车欲问边，属国过居延。\n征蓬出汉塞，归雁入胡天。\n大漠孤烟直，长河落日圆。\n萧关逢候骑，都护在燕然。\n《庭中有奇树》 《古诗十九首》\n庭中有奇树，绿叶发华滋。\n攀条折其荣，将以遗所思。\n馨香盈怀袖，路远莫致之。\n此物何足贵？但感别经时。\n《赠从弟（其二）》\n刘桢（东汉）\n亭亭山上松，瑟瑟谷中风。\n风声一何盛，松枝一何劲！\n冰霜正惨凄，终岁常端正。\n岂不罹凝寒？松柏有本性。\n《梁甫行》\n曹植（三国）\n八方各异气，千里殊风雨。\n剧哉边海民，寄身于草野。\n妻子象禽兽，行止依林阻。\n柴门何萧条，狐兔翔我宇。\n《饮酒（其五）》\n陶渊明（东晋）\n结庐在人境，而无车马喧。\n问君何能尔？心远地自偏。\n采菊东篱下，悠然见南山。\n山气日夕佳，飞鸟相与还。\n此中有真意，欲辨已忘言。\n《雁门太守行》 李贺（唐）\n黑云压城城欲摧，甲光向日金鳞开。\n角声满天秋色里，塞上燕脂凝夜紫。\n半卷红旗临易水，霜重鼓寒声不起。\n报君黄金台上意，提携玉龙为君死。\n《赤壁》\n杜牧（唐）\n折戟沉沙铁未销，自将磨洗认前朝。\n东风不与周郎便，铜雀春深锁二乔。\n《浣溪沙·一曲新词酒一杯》 晏殊（宋）\n一曲新词酒一杯，\n去年天气旧亭台。\n夕阳西下几时回？\n无可奈何花落去，\n似曾相识燕归来。\n小园香径独徘徊。\n《采桑子·轻舟短棹西湖好》\n欧阳修（宋）\n轻舟短棹西湖好，\n绿水逶迤，芳草长堤，\n隐隐笙歌处处随。 无风水面琉璃滑，\n不觉船移，微动涟漪，\n惊起沙禽掠岸飞。\n《相见欢·金陵城上西楼》 朱敦儒（宋）\n金陵城上西楼，倚清秋。\n万里夕阳垂地，大江流。 中原乱，簪缨散，几时收？\n试倩悲风吹泪，过扬州。\n《关雎》 《诗经·周南》\n关关雎鸠，在河之洲。窈窕淑女，君子好逑。\n参差荇菜，左右流之。窈窕淑女，寤寐求之。\n求之不得，寤寐思服。悠哉悠哉，辗转反侧。\n参差荇菜，左右采之。窈窕淑女，琴瑟友之。\n参差荇菜，左右芼之。窈窕淑女，钟鼓乐之。\n《蒹葭》\n《诗经·秦风》\n蒹葭苍苍，白露为霜。所谓伊人，在水一方。\n溯洄从之，道阻且长。溯游从之，宛在水中央。\n蒹葭萋萋，白露未晞。所谓伊人，在水之湄。\n溯洄从之，道阻且跻。溯游从之，宛在水中坻。\n蒹葭采采，白露未已。所谓伊人，在水之涘。\n溯洄从之，道阻且右。溯游从之，宛在水中沚。\n《式微》\n《诗经·邶风》\n式微，式微，胡不归？\n微君之故，胡为乎中露！\n式微，式微，胡不归？\n微君之躬，胡为乎泥中！\n《子衿》\n《诗经·郑风》\n青青子衿，悠悠我心。纵我不往，子宁不嗣音？\n青青子佩，悠悠我思。纵我不往，子宁不来？\n挑兮达兮，在城阙兮。一日不见，如三月兮！\n《送杜少府之任蜀州》\n王勃（唐）\n城阙辅三秦，风烟望五津。\n与君离别意，同是宦游人。\n海内存知己，天涯若比邻。\n无为在歧路，儿女共沾巾。\n《望洞庭湖赠张丞相》 孟浩然（唐）\n八月湖水平，涵虚混太清。\n气蒸云梦泽，波撼岳阳城。\n欲济无舟楫，端居耻圣明。\n坐观垂钓者，徒有羡鱼情。\n《题破山寺后禅院》\n常建（唐）\n清晨入古寺，初日照高林。\n曲径通幽处，禅房花木深。\n山光悦鸟性，潭影空人心。\n万籁此都寂，但余钟磬音。\n《卜算子·黄州定慧院寓居作》 – 苏轼（宋） 全文 缺月挂疏桐，漏断人初静。谁见幽人独往来，缥缈孤鸿影。 惊起却回头，有恨无人省。拣尽寒枝不肯栖，寂寞沙洲冷。 注释：漏断 – 夜将尽；省（xǐng）– 理解。 赏析：以孤鸿自喻，写贬谪黄州后的孤高自许、不愿苟合之心，“寂寞沙洲冷”收结悲凉而坚守。 ","date":"2025-12-12T21:18:19+08:00","permalink":"http://localhost:1313/post/classic_literature/poetry/","tags":["诗词"],"title":"经典诗歌"},{"categories":["操作系统"],"contents":"本文记录阅读book-riscv-rec3.pdf的笔记\n1 operatiing system interface System Call Descriptor int fork() Create a process, return child’s PID. int exit(int status) Terminate the current process; status reported to wait(). No return. int wait(int *status) Wait for a child to exit; exit status in *status; returns child PID. int kill(int pid) Terminate process PID. Returns 0, or -1 for error. int getpid() Return the current process’s PID. int sleep(int n) Pause for n clock ticks. int exec(char *file, char *argv[]) Load a file and execute it with arguments; only returns if error. char *sbrk(int n) Grow process’s memory by n bytes. Returns start of new memory. int open(char *file, int flags) Open a file; flags indicate read/write; returns an fd (file descriptor). int write(int fd, char *buf, int n) Write n bytes from buf to file descriptor fd; returns n. int read(int fd, char *buf, int n) Read n bytes into buf; returns number read; or 0 if end of file. int close(int fd) Release open file fd. int dup(int fd) Return a new file descriptor referring to the same file as fd. int pipe(int p[]) Create a pipe, put read/write file descriptors in p[0] and p[1]. int chdir(char *dir) Change the current directory. int mkdir(char *dir) Create a new directory. int mknod(char *file, int, int) Create a device file. int fstat(int fd, struct stat *st) Place info about an open file into *st. int stat(char *file, struct stat *st) Place info about a named file into *st. int link(char *file1, char *file2) Create another name (file2) for the file file1. int unlink(char *file) Remove a file. xv6使用fork()系统调用创建子进程。\nfork()调用一次，返回两次。父进程接受到的fork()的返回值是子进程的pid。子进程接收到的返回值是0。\n因此根据fork()的返回值就可以判断出fork()的返回点。\nwait()系统调用作用是等待子进程结束。\n1.2 I/O and File descriptors xv6 kernel中使用正整数作为文件描述符。系统中通过文件描述符来统一管理系统中的文件、块设备等。进程启动时默认已打开如下三个文件描述符：\n0表示标准输入\n1表示标准输出\n2表示标准错误输出\n操作文件最关键的几个系统调用有：open(), read(), write(), close().\ndup()系统调用的作用是复制一个已经存在的文件描述符并且共享文件描述对应的offset信息，操作dup()复制的文件描述符等同于操作原始文件描述符。\n1.3 pipes 1.4 File system 1.5 Real world","date":"2025-12-05T20:34:16+08:00","permalink":"http://localhost:1313/post/operating_system/xv6/read-book-riscv/","tags":["xv6","riscv"],"title":"Read Book Riscv"},{"categories":[""],"contents":"该页为的文学相关内容导航页。\n文学 经典古文 《阿房宫赋》- 杜牧\n《过秦论》- 贾谊 《六国论》- 苏洵 《寡人之于国也》- 孟子\n《庖丁解牛》- 庄子\n《劝学》- 荀子\n《师说》- 韩愈\n《完璧归赵》- 司马迁\n《鸿门宴》- 司马迁\n《烛之武退秦师》- 左传 《荆轲刺秦》- 司马迁\n《逍遥游》- 老子\n《归去来兮辞》- 陶渊明\n《木兰诗》- 汉乐府民歌\n《孔雀东南飞》- 汉乐府民歌\n《离骚》- 屈原\n《滕王阁序》- 王勃 《岳阳楼记》- 范仲淹\n《游褒禅山记》- 王安石\n《小石潭记》- 欧阳修\n《醉翁亭记》- 欧阳修\n《兰亭集序》- 王羲之\n《种树郭橐驼传》- 柳宗元\n《项脊轩志》- 归有光 《陈情表》- 李密 《出师表》- 诸葛亮 《隆中对》- 陈寿\n唐诗 李白古诗词 李白古诗\n梦游天姥吟留别\n将进酒\n蜀道难\n杜甫诗歌\n白居易 白居易古诗 长恨歌 观刈麦 卖炭翁 琵琶行\n春江花月夜\n宋词 李清照\n陆游\n苏轼诗词 赤壁赋\n石钟山记\n","date":"2025-11-13T17:57:26+08:00","permalink":"http://localhost:1313/index/content_literature/","tags":[""],"title":"文学导航页"},{"categories":["操作系统"],"contents":"该页面记录配置xv6-riscv的方法。\nUbuntu 2404配置xv6编译环境 1 安装软件 1.1 安装编译qemu依赖的基础软件 1 2 3 4 5 6 7 sudo apt-get install -y git build-essential ninja-build pkg-config \\ libglib2.0-dev libpixman-1-dev libfdt-dev zlib1g-dev \\ libaio-dev libbz2-dev libcap-ng-dev libcurl4-gnutls-dev \\ libgtk-3-dev libncurses5-dev libnfs-dev libsdl2-dev \\ libseccomp-dev libspice-server-dev libusb-1.0-0-dev \\ libusbredirparser-dev libvdeplug-dev python3 python3-pip \\ flex bison 1.2 源码编译qemu 8.1.5 1 2 3 4 5 6 7 # 安装依赖软件包 mkdir build cd build ../configure --prefix=/usr/local/qemu-8.1.5 --target-list=riscv64-softmmu \\ --enable-virtfs \\ --enable-tools --enable-debug 1.3 创建qemu链接 1 ln -sf /opt/qemu-8.1.5/build/qemu-system-riscv64 /usr/local/bin/qemu-system-riscv64 2 配置riscv64 toolchain 1 2 3 4 5 6 7 8 9 10 11 12 # 下载riscv64 toolchanin # riscv64-elf-ubuntu-24.04-gcc-nightly-2025.07.16-nightly.tar.xz https://github.com/riscv-collab/riscv-gnu-toolchain/releases # 解压riscv-gnu-toolchain tar -Jxvf riscv64-elf-ubuntu-24.04-gcc-nightly-2025.07.16-nightly.tar.xz # 配置环境变量 # 在 ~/.bashrc中添加以下内容： export PATH=\u0026#34;$PATH:/opt/riscv/bin\u0026#34; source ~/.bashrc 3 编译xv6-riscv 3.1 下载xv6-riscv 1 git clone https://github.com/mit-pdos/xv6-riscv.git 3.2 编译xv6-riscv 1 2 3 cd xv6-riscv-path make clean make qemu 3.3 调试xv6 1 2 3 cd xv6-riscv-path make clean make qemu-gdb 然后再另外一个窗口：\n1 2 cd xv6-riscv-path riscv64-unknown-elf-gdb -q kernel/kernel 若在gdb client加载过程提示：\nwarning: File \u0026ldquo;xv6-path/.gdbinit\u0026rdquo; auto-loading has been declined by your auto-load safe-path\u0026rsquo; set to \u0026ldquo;$debugdir:$datadir/auto-load\u0026rdquo;. 则编辑文件~/.config/gdb/gdbinit，按照提示添加：add-auto-load-safe-path xxx即可。 例如我的环境,在文件/home/alvin/.config/gdb/gdbinit中添加内容如下：add-auto-load-safe-path /opt/xv6-riscv/.gdbinit即可。\n","date":"2025-08-03T18:25:40+08:00","permalink":"http://localhost:1313/post/operating_system/linux_kernel/configure_xv6_environment/","tags":["XV6","RISCV","QEMU"],"title":"xv6编译环境的配置方法"},{"categories":[""],"contents":"本文总结docker的安装和使用方法\n1 docker的安装和使用方法 1 2 3 4 5 6 7 8 9 10 11 12 13 # Add Docker\u0026#39;s official GPG key: sudo apt-get update sudo apt-get install ca-certificates curl sudo install -m 0755 -d /etc/apt/keyrings sudo curl -fsSL https://download.docker.com/linux/ubuntu/gpg -o /etc/apt/keyrings/docker.asc sudo chmod a+r /etc/apt/keyrings/docker.asc # Add the repository to Apt sources: echo \\ \u0026#34;deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu \\ $(. /etc/os-release \u0026amp;\u0026amp; echo \u0026#34;${UBUNTU_CODENAME:-$VERSION_CODENAME}\u0026#34;) stable\u0026#34; | \\ sudo tee /etc/apt/sources.list.d/docker.list \u0026gt; /dev/null sudo apt-get update 1.1 安装docker相关软件包 1 sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin 1.2 测试docker是否正常 1 2 sudo service docker start sudo docker run hello-world 1.3 修改docker工作路径 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 # 查看docker默认路径 sudo docker info | grep \u0026#34;Docker Root Dir\u0026#34; # 停止docker服务 sudo systemctl stop docker sudo systemctl stop docker.socket # Copy the files to your new docker directory. sudo rsync -axPS /var/lib/docker/ /data/docker/ # edit file:/etc/docker/daemon.json and add content as follow,if file not exit, create. { \u0026#34;data-root\u0026#34;: \u0026#34;/path/to/new/docker-data\u0026#34; } # 启动docker sudo systemctl daemon-reload sudo systemctl start docker # 确认路径是否已更新 docker info | grep \u0026#39;Docker Root Dir docker ps # remove old file sudo rm -r /var/lib/docker 2.4 配置docker镜像源 在配置文件/etc/docker/daemon.json中增加docker镜像源。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026#34;registry-mirrors\u0026#34;: [ \u0026#34;https://docker.1panel.live\u0026#34;, \u0026#34;https://docker.1ms.run\u0026#34;, \u0026#34;https://dytt.online\u0026#34;, \u0026#34;https://docker-0.unsee.tech\u0026#34;, \u0026#34;https://lispy.org\u0026#34;, \u0026#34;https://docker.xiaogenban1993.com\u0026#34;, \u0026#34;https://666860.xyz\u0026#34;, \u0026#34;https://hub.rat.dev\u0026#34;, \u0026#34;https://docker.m.daocloud.io\u0026#34;, \u0026#34;https://demo.52013120.xyz\u0026#34;, \u0026#34;https://proxy.vvvv.ee\u0026#34;, \u0026#34;https://registry.cyou\u0026#34; ] 添加完成后，执行如下命令容器docker:\n1 2 sudo systemctl daemon-reload sudo systemctl start docker 2.5 下载docker镜像 1 2 3 4 5 6 7 docker image pull zuojxin/xv6 # 查询docker镜像 sudo docker images -a # 删除镜像 sudo docker image rm 2.6 运行docker镜像 1 2 cd /opt/xv6-riscv docker run -it --rm -v $(pwd):/home/xv6-riscv zuojxin/xv6 2.4 卸载docker 1 2 3 4 5 6 7 sudo apt-get purge docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin docker-ce-rootless-extras sudo rm -rf /var/lib/docker sudo rm -rf /var/lib/containerd sudo rm /etc/apt/sources.list.d/docker.list sudo rm /etc/apt/keyrings/docker.asc ","date":"2025-08-02T23:09:18+08:00","permalink":"http://localhost:1313/post/tools/docker_setting_tips/","tags":["docker"],"title":"docker的安装和使用方法"},{"categories":[""],"contents":"记录如何在Linux环境中使用gtest进行单元测试。\n1 环境\u0026amp;工具说明 环境工具版本说明：\nLinux系统版本： GCC版本：7.5.0 G++版本：7.5.0 CMake版本：3.10.2 gtest版本：1.12.1 2 安装工具 2.1 安装cmake 1 2 sudo apt update sudo apt install build-essential cmake 2.2 安装gtest 2.2.1 下载gtest gtest下载链接：gtest-1.12.1\n2.2.2 安装gtest 1 2 3 4 5 6 7 mkdir build cd build cmake .. -DCMAKE_CXX_STANDARD=11 # 指定C++标准 make # 安装到系统目录（可选，需sudo权限） sudo make install 3 代码框架说明 1 2 3 4 5 6 7 8 9 10 11 #. #├── CMakeLists.txt #└── src # ├── includ # │ └── add.h # ├── add.c # ├── test # ├── CMakeLists.txt # ├── test_main.cpp # └── test_add.cpp # 3.1 add.c 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026#34;add.h\u0026#34; static int counter = 0; int add(int a, int b) { counter++; return a + b; } void reset_counter() { counter = 0; } int get_counter() { return counter; } 3.2 add.h 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // include/add.h #ifndef ADD_H #define ADD_H #ifdef __cplusplus extern \u0026#34;C\u0026#34; { // 确保C++编译器正确处理C函数 #endif int add(int a, int b); void reset_counter(); int get_counter(); #ifdef __cplusplus } #endif #endif 3.3 test_main.cpp 1 2 3 4 5 6 #include \u0026lt;gtest/gtest.h\u0026gt; int main(int argc, char **argv) { ::testing::InitGoogleTest(\u0026amp;argc, argv); return RUN_ALL_TESTS(); } 3.4 test_add.cpp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026lt;gtest/gtest.h\u0026gt; #include \u0026#34;add.h\u0026#34; // 包含C头文件 // 测试 add 函数 TEST(CCodeTest, AddFunction) { EXPECT_EQ(add(2, 3), 5); // 调用C函数 EXPECT_EQ(add(-1, 1), 0); } // 测试计数器逻辑 TEST(CCodeTest, CounterLogic) { reset_counter(); // 调用C函数重置计数器 ASSERT_EQ(get_counter(), 0); add(1, 2); // 调用C函数 EXPECT_EQ(get_counter(), 1); } 4 编写cmake 4.1 根目录下的CMakeLists.txt 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 cmake_minimum_required(VERSION 3.10) project(CProjectWithGTest) # 设置C标准 set(CMAKE_C_STANDARD 11) # 添加C源代码为静态库 add_library(add STATIC src/add.c ) # 包含头文件目录 target_include_directories(add PUBLIC src/include) # 包含Google Test find_package(GTest REQUIRED) enable_testing() # 添加测试子目录 add_subdirectory(src/test) 4.2 test目录下的CMakeList.txt 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 cmake_minimum_required(VERSION 3.10) find_package(GTest REQUIRED) include_directories(${GTEST_INCLUDE_DIRS}) # Var managed by CMake message(STATUS \u0026#34;C Compiler: ${CMAKE_C_COMPILER}\u0026#34;) message(STATUS \u0026#34;C++ Compiler: ${CMAKE_CXX_COMPILER}\u0026#34;) # 测试代码使用C++编译器 add_executable(test_add test_main.cpp test_add.cpp ) set(PROG_ROOT \u0026#34;/opt/code\u0026#34;) target_include_directories(test_add PRIVATE ${PROG_ROOT}/include) # 链接C库和GTest库 target_link_libraries(test_add add ${GTEST_LIBRARIES} pthread ) 5 编译代码 1 2 3 4 5 6 7 8 9 # 生成makefile cd /opt/code # 假设该目录为src所在目录 rm -rf build mkdir build cd build cmake .. # 编译代码，生成测试二进制文件 make 6 运行测试用例代码 若步骤5执行成功，则会在目录/opt/code/build/src/test下生成二进制文件test_add。\n1 2 cd /opt/code/build/src/test ./test_add 运行结果如下：\n1 2 3 4 5 6 7 8 9 10 11 12 # [==========] Running 2 tests from 1 test suite. # [----------] Global test environment set-up. # [----------] 2 tests from CCodeTest # [ RUN ] CCodeTest.AddFunction # [ OK ] CCodeTest.AddFunction (0 ms) # [ RUN ] CCodeTest.CounterLogic # [ OK ] CCodeTest.CounterLogic (0 ms) # [----------] 2 tests from CCodeTest (2 ms total) # # [----------] Global test environment tear-down # [==========] 2 tests from 1 test suite ran. (5 ms total) # [ PASSED ] 2 tests. ","date":"2025-05-22T20:44:30+08:00","permalink":"http://localhost:1313/post/tools/how_to_config_gtest/","tags":[""],"title":"配置gtest的方法"},{"categories":["others"],"contents":"经典音乐 经典钢琴曲 Name Author discription 命运交响曲 贝多芬 蓝色多瑙河 经典古筝曲 经典萨克斯曲 经典交响乐 Name Author discription victory Two Steps From Hell 《英雄联盟》背景音乐 Star Sky Two Steps From Hell Strength of a Thousand Men Two Steps From Hell Empire of Angels Two Steps From Hell El Dorado Two Steps From Hell Breath and Life Audiomachine Electric Romeo Immediate Music Revelations Audiomachine The Dawn 亡灵序曲 He’s a Pirate Klaus Badelt 《加勒比海盗》主题曲 七剑战歌 川井宪次 Rise Epic Music Freedom Is Ours Dragon Rider Two Steps From Hell Disappear Audiomachine Time Hans Zimmer 《盗梦空间》 Cornfield Chase Hans Zimmer 《星际穿越》 Guardians at the Gate Future World Music 经典英语歌曲 Name Author discription Apologize Timbaland OneRepublic Baby One More Time britney spears 布兰妮·斯皮尔斯演唱的一首歌曲, 为世界畅销单曲之一 Because I Love You Shakin Stevens Shakin\u0026rsquo; Stevens，英国及欧洲的超级巨星 Because Of You kelly clarkson 《Because of You》是美国流行摇滚女歌手凯莉·克莱森演唱的一首流行歌曲 Bressanone Matthew Lien Casablanca Bertie Higgins 《Casablanca》是《北非谍影》的主题曲 Careless Whisper Wham 《英国组合威猛乐队（Wham）的一首歌曲，由乔治·迈克尔演唱 dream it possible OneRepublic Edelweiss James Lord Pierpont Edelweiss是美国电影和音乐剧《音乐之声》中的著名歌曲。 I Will Always Love You Whitney Houston 电影《保镖》的主题曲 My Heart Will Go On Celine Dion 1997年著名电影《泰坦尼克号》的主题曲。 Right Here Waiting Richard Marx 电影《终有一天感动你》(Bed of Roses)主题曲 Say You Say Me Lionel Richie 电影《飞越苏联》的主题曲 Take My Breath Away Jessica Simpson 1986年美国影片《壮志凌云》的主题曲 Take me to your heart Michael Learns To Rock The day you went away M2M The Color Of My Love Celine Dion 席琳·迪翁出生于加拿大魁北克省，是最著名的法语和英语流行女歌手，有流行天后之称。 Yesterday Once More The carpenters Yesterday Once More是卡朋特乐队演唱的歌曲，始创于1973年。 The Sound Of Silence Paul Simon,Garfunkel 美国电影《毕业生》的主题歌 We Will Rock You Queen 歌曲词曲由乐队吉他手布赖恩·梅制作，于1977年发行 Remember When Avril Ramona Lavigne Whibley God Is A Girl Groove Coverage 德国2001年创立的乐队Groove Coverage演唱的 Can You Feel The Love Tonight Elton John 动画电影《狮子王》的插曲，由英国歌手艾尔顿·约翰演唱 Complicated Avril Lavigne 《Complicated》是加拿大唱作女歌手艾薇儿·拉维尼演唱的一首流行歌曲 Love More Than I Can Say Bobby Vee 《《More Than I Can Say》是香港艺人许冠英的粤语歌曲《虾妹共你》的原曲 Love More Than I Can Say Bobby Vee 《《More Than I Can Say》是香港艺人许冠英的粤语歌曲《虾妹共你》的原曲 Pretty Young Thing Michael Jackson 这是《Thriller》专辑发行的第六支单曲，也是第六支热门100单曲榜上的Top 10金曲 Unchained Melod The Righteous Brothers 因电影《人鬼情未了》而流行的著名歌曲 I See You Leona Lewis 2010年为电影《阿凡达》献唱主题曲《I See You》风靡全球。 Lemon Tree Fool\u0026rsquo;s Garden 流行音乐之王的迈克尔·杰克逊于1982年发行《颤栗》专辑的主打歌曲之一 Pretty Boy M2M M2M（窈窕美眉）是由两个来自挪威的小女孩Marit及Marion所组成的团体 One Love blue 英国blue乐队发行了第二张专辑《OneLove》里的歌曲，以R\u0026amp;B曲风为主 Auld Lang Syne Robert Burns 在中国各地普遍称为友谊地久天长，是《魂断蓝桥》《Its.A.Wonderful.Life》《When Harry Met Sally》中的电影主题曲 Dangerous Michael Jackson 世界流行天王Michael Jackson（迈克尔·杰克逊）于1991年11月26日发行的专辑 Beat It Michael Jackson 《Beat It》是一首反对社会暴力音乐作品 As Long As You Love Me Backstreet Boys 后街男孩代表作之一，也是其最脍炙人口的歌曲之一 Love Story Taylor Swift 后街男孩代表作之一，也是其最脍炙人口的歌曲之一 Lonely NANA 中间唱RAP的男声才是Nana，才是主角，女声是Sibela Speak Softly Love Andy williams 电影《教父》的主题曲 Big big world Emilia Rydberg 500 miles Journeymen See You Again Wiz Khalifa，Charlie Puth 这首歌在电影中是为了缅怀因车祸逝世的速度与激情的演员Paul Walker而创作的。 Let It Go Idina Menzel /Demi Lovato 2013年动画作品《冰雪奇缘》当中的主题曲 Satisfaction The Rolling Stones 英国著名乐队滚石乐队（The Rolling Stones)演唱歌曲，居于最伟大的100首英文歌曲第二名 The Rose Amanda McBroom 《The Rose》(歌声泪痕)中作为片尾曲首唱 Oh My Love JOHN LENON Scarborough Fair Paul Simon, Art Garfunkel 1968年奥斯卡获奖片《毕业生》中的主题曲 Tears in Heaven Eric Clapton dragostea din tei O-Zone 郭美美演唱的《不怕不怕》的来源。 Gloomy Sunday Billie Holiday Tom\u0026rsquo;s Diner Suzanne Vega Hotel California The Eagles Eyes on me 王菲 I Want It That way Backstreet Boys Every Body Backstreet Boys Never Grow Old The Cranberries Dying in The Sun The Cranberries Spancil Hill The Corrs Complicated 艾薇儿 That\u0026rsquo;s Why (You Go Away) Michael Learns to Rock Show Me The Meaning Of Being Lonely Backstreet Boys Juliet LMNT Gigolo 两只蝴蝶英文版 I Feel Close To You 仓木麻衣和孙燕姿合唱 Are You The One Timo Tolkki you don\u0026rsquo;t have to say you love me M2M Numb Linkin Park The phoenix Fall Out Boy Move your body Sia Counting Stars OneRepublic 数星星 That girl Olly Murs Try Colbie Caillat Better Man Robbie Williams Canon Flamenco JerryC Beautiful Ones Suede Stand Rascal Flatts Yeah Usher ft. Lil Jon, Ludacris Yellow Coldplay Shape Of My Heart Backstreet Boys / Sting All About Us t.A.T.u. In the End Linkin Park Never Had A Dream Come True S Club 7 Anyone Of Us Gareth Gates Don\u0026rsquo;t Tell Me Avril Lavigne Crazy Frog Crazy Frog Far Away From Home Groove Coverage Thank You Dido Kiss The Rain Yiruma Earphones Victon Heal The World Michael Jackson Long Long Way To Go Def Leppard Hall Of Fame The Script ft. will.i.am Lone Ranger Rachel Platten La La La Naughty Boy ft. Sam Smith My Stupid Heart Walk Off the Earth Hymn for the Weekend Coldplay In the End Linkin Park Rolling in the Deep Adele Uptown Funk Mark Ronson ft. Bruno Mars Salt Ava Max Whataya Want from Me Adam Lambert Natural Imagine Dragons Believer Imagine Dragons Sold Out Hardy New Divide Linkin Park DJ Got Us Fallin\u0026rsquo; in Love Usher ft. Pitbull Da Da Da Trio Whistle Flo Rida Dream It Possible Delacey Talking to the Moon Bruno Mars Legends Never Die Against The Current Rise Katy Perry This is What You Asked For Bring Me The Horizon My Songs Sting Run Away Aurora Señorita Shawn Mendes \u0026amp; Camila Cabello Dance Monkey Tones and I Stronger Kanye West What Makes You Beautiful One Direction Right Now Akon The Nights Avicii Waiting for Love Avicii Beautiful Now Zedd ft. Jon Bellion Faded Alan Walker We Don’t Talk Anymore Charlie Puth ft. Selena Gomez Here With You Lost Frequencies \u0026amp; Netsky Wake Hillsong Young \u0026amp; Free Children of the Dark Mono Inc. Something Just Like This The Chainsmokers \u0026amp; Coldplay Someone Like You Adele Shape of You Ed Sheeran Sugar Maroon 5 Good Time Owl City \u0026amp; Carly Rae Jepsen I Am You Stray Kids Let Me Down Slowly Alec Benjamin Poker Face Lady Gaga Baby Justin Bieber ft. Ludacris Diamonds Rihanna Be What You Wanna Be Darin It\u0026rsquo;s My Life Bon Jovi Jealousy Martin Solveig Just One Last Dance Sarah Connor Cry on My Shoulder Supertramp /DeutschlandSuchtDenSuperstar You Raise Me Up Josh Groban /Westlife My Love Westlife All Rise Blue Smooth Criminal Michael Jackson / Alien Ant Farm Free Loop Daniel Powter 其他经典歌曲\nName Author discription Je m\u0026rsquo;appelle Hélène 伊莲·罗莱斯 法国连续25周的冠军单曲 El Cóndor Pasa (If I Could) Daniel Alomía Robles 是一首秘鲁歌曲，世界名曲 背景旋律\nName Author discription Classic River You Young Suk 最早出自2003年韩国电影《假如爱有天意》，是贯穿全片的主题旋律 ","date":"2025-03-28T20:38:00+08:00","permalink":"http://localhost:1313/post/others/music/","tags":[""],"title":"Music"},{"categories":["CPP"],"contents":"1 常用关键字的用法 1.1 typedef的用法 typedef提供了一种给数据类型命名的方式。这样可以极大的提高代码的可读性。\n格式大致为typedef innner_type alias_type，示例：\n1 2 3 typedef int* int_pointer; typedef unsigned char U8; typedef unsigned short U16; ","date":"2025-03-25T21:34:33+08:00","permalink":"http://localhost:1313/post/cpp/c_common_tips/","tags":[""],"title":"C_common_tips"},{"categories":["CSAPP"],"contents":"本文总结计算机中信息的表示和处理方法。\n2 信息的处理和表示 2.1 信息的存储 2.1.0 数字的编码 2.1.0.1 无符号数 无符号数是基于传统的二进制标识法，可以表示大于等于0的数字。\n2.1.0.2 二进制补码(two\u0026rsquo;s-complement) 二进制补码用来表示有符号整数的常见形式。\n2.1.0.3 浮点数 浮点数是以二进制为基数的实数科学计数法形式。\n2.1.1 进制转换 2.1.1.1 十进制的转换 十进制转换为其他进制的方法均使用辗转相除法即可。例如： 一个十进制数x要转换为十六进制数，可以表示为：x = q * 16 + r 。然后通过q反复进行这个过程，直到q为0为止。\n2.1.1.1.1 十进制转十六进制 例如：\nq subprocess r 314156 = 19634 * 16 + 12 (C) 19634 = 1227 * 16 + 2 (2) 1227 = 76 * 16 + 11 (B) 76 = 4 * 16 + 12 (C) 4 = 0 * 16 + 4 (4) 最终得到结果：314156 = 0x4CB2C。\n2.1.1.1.2 十进制转二进制 例如：\nq subprocess r 29 = 14 * 2 + 1 (1) 14 = 7 * 2 + 0 (0) 7 = 3 * 2 + 1 (1) 3 = 1 * 2 + 1 (1) 1 = 0 * 2 + 1 (1) 最终得到结果：29 = 11101。\n2.1.1.2 十六进制的转换 2.1.1.2.1 十六进制转十进制 十六进制数转换为十进制数，只需要将对应的十六进制位乘以16的幂，然后相加即可。例如： $ 0xACB = 10 * 16^2 + 12 * 16^1 + 11 * 16^0 = 10 * 256 + 12 * 16 + 11 = 2763$\n2.1.1.2.2 十六进制转二进制 十六机制和二进制之间的对应关系如下： 每位十六机制数对应4bit二进制。可以使用如下两种方法进行转换。\n方法1：切分法。即使用如下对照表进行转换即可。 Hex Bin Hex Bin 0 0000 8 1000 1 0001 9 1001 2 0010 A 1010 3 0011 B 1011 4 0100 C 1100 5 0101 D 1101 6 0110 E 1110 7 0111 F 1111 例如： 针对0x2DFB，转换方法如下：\n2 -\u0026gt; 0010\nD -\u0026gt; 1101\nF -\u0026gt; 1111\nB -\u0026gt; 1011\n因此0x2DFB(H) = 0010 1101 1111 1011(B)\n方法2：先将十六机制转换为十进制，然后再将十进制转换为二进制。\n十六进制转换为十进制的方法见2.1.1.2.1节。\n十进制转换为二进制的方法见2.1.1.1.2节。 温馨提示：推荐使用方法1，简单快捷。\n2.1.1.3 二进制的换换 2.1.1.3.1 二进制转十进制 二进制转换为十进制的方法和十六进制转换为10进制的方法类似。例如：\n$ 1111 1011 $\n$ = 1 * 2^7 + 1 * 2^6 + 1 * 2^5 + 1 * 2^4 + 1 * 2^3 + 0 * 2^2 + 1 * 2^1 + 1 * 2^0 $\n$ = 1 * 128 + 1 * 64 + 1 * 32 + 1 * 16 + 1 * 8 + 0 * 4 + 1 * 2 + 1 * 1 $\n$ = 128 + 64 + 32 + 16 + 8 + 0 + 2 + 1 $\n$ = 251 $\n2.1.1.3.2 二进制转十六进制 二进制转换为十六进制的方法为十六进制转换为二进制的逆过程，方法参考2.1.1.2.2节。\n唯一需要注意的地方就是：\n若使用切分法二进制转换为十六进制的时候，需要从右往进行切分，每4bit二进制对应一位十六进制数。不足4位的在左侧补0。\n例如：针对二进制数1 1010 1001 0001\n先将二进制数的数位补为4的整数倍。1 1010 1001 0001 -\u0026gt; 0001 1010 1001 0001 按照对照表进行转换：\n0001 -\u0026gt; 1(H)\n1010 -\u0026gt; A(H)\n1001 -\u0026gt; 9(H)\n0001 -\u0026gt; 1(H) 最终得到结果为： 1 1010 1001 0001 = 0x1A91(H) 2.2 整数的表示 2.3 整数的运算 2.4 浮点数 2.5 总结","date":"2025-03-07T22:13:37+08:00","permalink":"http://localhost:1313/post/linux/csapp/representing_manipulating_information/","tags":[""],"title":"信息的表示和处理"},{"categories":[""],"contents":"本文介绍前缀树这种数据结构。\n1 前缀树简介 前缀树是一种用于存储和查询字典或者集合中的字符串的数据结构。\n前缀树和普通的二叉树不同的是，它的结点中存储的是从根结点到当前结点的路径上的字符。\n因此每个结点的子结点都拥有相同的前缀，根结点表示空字符串。\n前缀树主要用于代码补全、拼写检查和IP路由。\n2 前缀树的代码实现","date":"2025-01-23T21:41:39+08:00","permalink":"http://localhost:1313/post/data_structure/tree/prefix_tree/","tags":[""],"title":"前缀树"},{"categories":[""],"contents":"VirtualBox实现宿主机访问虚拟机以及虚拟机联网的方法。\nVirtualBox实现宿主机访问虚拟机以及虚拟机联网的方法 1 VirtualBox初始设置 1.1 创建NAT网络 选中虚拟机中的系统(系统应处于关闭状态)(①),然后选择【管理\u0026ndash;\u0026gt;全局设定】（②③）。如图 1-1所示。 图 1-1\n通过图 1-1的操作打开VirtualBox全局设定对话框。然后选择【网络】（①），定位到网络子选项， 选择【NAT网络】(②),点击右侧的【添加】按钮(③)，创建一个NAT虚拟网络(④)。如图 1-2所示。单击【修改】按钮(⑤)，可以修改NAT网络的参数,如图 1-3所示：\n图 1-2\n图 1-3\n1.2 创建Host-Only网卡 类似于图 1-2，点击【仅主机（host-only）网络】（②），默认情况下，系统已经创建了一个Host-Only网卡（③）。若没有可以点击【添加】按钮（⑤），添加一个Host-Only网络。 图 1-4\n选中已经添加的Host-Only网卡，然后点击【编辑】按钮，打开【仅主机（Host-Only）网络明细】对话框，就可以对Host-Only网卡进行编辑，如图 1 5所示。Ipv4地址和子网掩码可以保持不变。 图 1-5\n点击【DHCP服务器】子选项卡，取消【启用服务器】选项，即不适用动态IP，如图 1 6所示。\n图 1-6\n1.3 VirtualBox 7.x版本配置网路的方法 图 1-7\n2 CentOS系统网络参数设置 2.1 网络连接设置 选中虚拟机中的系统(①),然后点击【设置】（②）,打开虚拟系统的设置对话框（③），如图 2 1所示： 图 2-1\n2.1.1 网卡1设置 选择【网络】（①），勾选网络连接，然后点击【网卡1】（②），连接方式选择【网络地址转换（NAT）】,其他设置同图 2 2所示即可。 图 2-2\n2.1.2 网卡2设置 点击【网卡2】（②），勾选网络连接，连接方式选择【仅主机（Host-Only）网络】（③），界面名称选择【Virtual Host-Only Ethernet Adapter】（4），其他设置同图 2 3所示即可。 图 2-3\n","date":"2025-01-23T20:41:27+08:00","permalink":"http://localhost:1313/post/tools/virtualbox_set_network_interface/","tags":[""],"title":"VirtualBox实现宿主机访问虚拟机以及虚拟机联网的方法"},{"categories":[""],"contents":"面试问题汇总\n1 技术类问题 1.1 使用STAR法则描述项目 STAR法则是Situation（情况）、Task（任务）、Action（行动）、Result（结果）。\n具体含义为:\nSituation：当时的背景情况是什么？ Task：当时的目标任务是什么？ Action：针对当时的情况，你采用了什么方法？ Result：结果怎样，你学习到了什么？ 2 非技术类问题 2.1 离职原因 2.2 你的职业规划是啥？ 2.3 能接受加班吗/对加班的看法？ 2.4 你的优点？ 2.5 你的缺点？ 2.6 做过的最满意/最值得骄傲的项目是什么？ 2.7 谈一谈你的一次失败经历？ 2.8 与上级意见不一致时，你将怎么办? 思路：\n1. 一般可以这样回答“我会给上级以必要的解释和提醒，在这种情况下，我会服从上级的意见。”\n2. 如果面试你的是总经理，而你所应聘的职位另有一位经理且这位经理当时不在场，可以这样回答：“对于非原则性问题，我会服从上级的意见，对于涉及公司利益的重大问题，我希望能向更高层领导反映。”\n2.9 你有什么想问面试官的吗？ 2.10 我们为什么要录用你/你的优势是什么？ 2.11 你为什么选择我们公司? 2.12 对这项工作，你有哪些可预见的困难? 2.13 你有什么业余爱好？ 回答思路：\n业余爱好能在一定程度上反映应聘者的性格、观念、心态，这是招聘单位问该问题的主要原因。 最好不要说自己没有业余爱好。 不要说自己有那些庸俗的、令人感觉不好的爱好。 最好不要说自己仅限于读书、听音乐、上网，否则可能令面试官怀疑应聘者性格孤僻。 最好能有一些户外的业余爱好来“点缀”你的形象。 2.14 谈谈你的家庭情况？","date":"2025-01-21T17:32:40+08:00","permalink":"http://localhost:1313/post/tools/iterview_questions/","tags":[""],"title":"面试问题汇总"},{"categories":["storage"],"contents":"本文介绍分布式系统中经典的一致性哈希算法。\n文章转载至：《16 张图解一致性哈希算法》作者：小林coding\n1 服务器集群分配请求的策略 大多数网站背后肯定不是只有一台服务器提供服务，因为单机的并发量和数据量都是有限的，所以都会用多台服务器构成集群来对外提供服务。 但是问题来了，现在有那么多个节点（后面统称服务器为节点，因为少一个字），要如何分配客户端的请求呢？\n其实这个问题就是「负载均衡问题」。解决负载均衡问题的算法很多，不同的负载均衡算法，对应的就是不同的分配策略，适应的业务场景也不同。 最简单的方式，引入一个中间的负载均衡层，让它将外界的请求「轮流」的转发给内部的集群。比如集群有 3 个节点，外界请求有 3 个，那么每个节点都会处理 1 个请求，达到了分配请求的目的。\n考虑到每个节点的硬件配置有所区别，我们可以引入权重值，将硬件配置更好的节点的权重值设高，然后根据各个节点的权重值，按照一定比重分配在不同的节点上，让硬件配置更好的节点承担更多的请求，这种算法叫做加权轮询。\n加权轮询算法使用场景是建立在每个节点存储的数据都是相同的前提。所以，每次读数据的请求，访问任意一个节点都能得到结果。 但是，加权轮询算法是无法应对「分布式系统」的，因为分布式系统中，每个节点存储的数据是不同的。\n当我们想提高系统的容量，就会将数据水平切分到不同的节点来存储，也就是将数据分布到了不同的节点。比如一个分布式 KV（key-valu） 缓存系统，某个 key 应该到哪个或者哪些节点上获得，应该是确定的，不是说任意访问一个节点都可以得到缓存结果的。\n因此，我们要想一个能应对分布式系统的负载均衡算法。\n2 哈希算法 有的同学可能很快就想到了：哈希算法。因为对同一个关键字进行哈希计算，每次计算都是相同的值，这样就可以将某个 key 确定到一个节点了，可以满足分布式系统的负载均衡需求。 哈希算法最简单的做法就是进行取模运算，比如分布式系统中有 3 个节点，基于 hash(key) % 3 公式对数据进行了映射。 如果客户端要获取指定 key 的数据，通过下面的公式可以定位节点：hash(key) % 3 如果经过上面这个公式计算后得到的值是 0，就说明该 key 需要去第一个节点获取。\n但是有一个很致命的问题，如果节点数量发生了变化，也就是在对系统做扩容或者缩容时，必须迁移改变了映射关系的数据，否则会出现查询不到数据的问题。\n举个例子，假设我们有一个由 A、B、C 三个节点组成分布式 KV 缓存系统，基于计算公式 hash(key) % 3 将数据进行了映射，每个节点存储了不同的数据：\n现在有 3 个查询 key 的请求，分别查询 key-01，key-02，key-03 的数据，这三个 key 分别经过 hash() 函数计算后的值为 hash( key-01) = 6、hash( key-02) = 7、hash(key-03) = 8，然后再对这些值进行取模运算。\n通过这样的哈希算法，每个 key 都可以定位到对应的节点。\n当 3 个节点不能满足业务需求了，这时我们增加了一个节点，节点的数量从 3 变化为 4，意味取模哈希函数中基数的变化，这样会导致大部分映射关系改变，如下图：\n比如，之前的 hash(key-01) % 3 = 0，就变成了 hash(key-01) % 4 = 2，查询 key-01 数据时，寻址到了节点 C，而 key-01 的数据是存储在节点 A 上的，不是在节点 C，所以会查询不到数据。\n同样的道理，如果我们对分布式系统进行缩容，比如移除一个节点，也会因为取模哈希函数中基数的变化，可能出现查询不到数据的问题。\n要解决这个问题的办法，就需要我们进行迁移数据，比如节点的数量从 3 变化为 4 时，要基于新的计算公式 hash(key) % 4 ，重新对数据和节点做映射。\n假设总数据条数为 M，哈希算法在面对节点数量变化时，最坏情况下所有数据都需要迁移，所以它的数据迁移规模是 O(M)，这样数据的迁移成本太高了。\n所以，我们应该要重新想一个新的算法，来避免分布式系统在扩容或者缩容时，发生过多的数据迁移。\n3 一致性哈希算法 一致性哈希算法就很好地解决了分布式系统在扩容或者缩容时，发生过多的数据迁移的问题。 一致哈希算法也用了取模运算，但与哈希算法不同的是，哈希算法是对节点的数量进行取模运算，而一致哈希算法是对 2^32 进行取模运算，是一个固定的值。 我们可以把一致哈希算法是对 2^32 进行取模运算的结果值组织成一个圆环，就像钟表一样，钟表的圆可以理解成由 60 个点组成的圆，而此处我们把这个圆想象成由 2^32 个点组成的圆，这个圆环被称为哈希环，如下图：\n一致性哈希要进行两步哈希：\n对存储节点进行哈希计算，也就是对存储节点做哈希映射，比如根据节点的 IP 地址进行哈希； 当对数据进行存储或访问时，对数据进行哈希映射； 所以，一致性哈希是指将「存储节点」和「数据」都映射到一个首尾相连的哈希环上。 问题来了，对「数据」进行哈希映射得到一个结果要怎么找到存储该数据的节点呢？\n答案是，映射的结果值往顺时针的方向的找到第一个节点，就是存储该数据的节点。\n举个例子，有 3 个节点经过哈希计算，映射到了如下图的位置： 接着，对要查询的 key-01 进行哈希计算，确定此 key-01 映射在哈希环的位置，然后从这个位置往顺时针的方向找到第一个节点，就是存储该 key-01 数据的节点。\n比如，下图中的 key-01 映射的位置，往顺时针的方向找到第一个节点就是节点 A。 所以，当需要对指定 key 的值进行读写的时候，要通过下面 2 步进行寻址：\n首先，对 key 进行哈希计算，确定此 key 在环上的位置； 然后，从这个位置沿着顺时针方向走，遇到的第一节点就是存储 key 的节点。 知道了一致哈希寻址的方式，我们来看看，如果增加一个节点或者减少一个节点会发生大量的数据迁移吗？\n假设节点数量从 3 增加到了 4，新的节点 D 经过哈希计算后映射到了下图中的位置：\n你可以看到，key-01、key-03 都不受影响，只有 key-02 需要被迁移节点 D。\n假设节点数量从 3 减少到了 2，比如将节点 A 移除： 你可以看到，key-02 和 key-03 不会受到影响，只有 key-01 需要被迁移节点 B。\n因此，在一致哈希算法中，如果增加或者移除一个节点，仅影响该节点在哈希环上顺时针相邻的后继节点，其它数据也不会受到影响。\n上面这些图中 3 个节点映射在哈希环还是比较分散的，所以看起来请求都会「均衡」到每个节点。\n但是一致性哈希算法并不保证节点能够在哈希环上分布均匀，这样就会带来一个问题，会有大量的请求集中在一个节点上。\n比如，下图中 3 个节点的映射位置都在哈希环的右半边： 这时候有一半以上的数据的寻址都会找节点 A，也就是访问请求主要集中的节点 A 上，这肯定不行的呀，说好的负载均衡呢，这种情况一点都不均衡。\n另外，在这种节点分布不均匀的情况下，进行容灾与扩容时，哈希环上的相邻节点容易受到过大影响，容易发生雪崩式的连锁反应。\n比如，上图中如果节点 A 被移除了，当节点 A 宕机后，根据一致性哈希算法的规则，其上数据应该全部迁移到相邻的节点 B 上，这样，节点 B 的数据量、访问量都会迅速增加很多倍，一旦新增的压力超过了节点 B 的处理能力上限，就会导致节点 B 崩溃，进而形成雪崩式的连锁反应。\n所以，一致性哈希算法虽然减少了数据迁移量，但是存在节点分布不均匀的问题。\n4 增加虚拟节点的一致性哈希算法 要想解决节点能在哈希环上分配不均匀的问题，就是要有大量的节点，节点数越多，哈希环上的节点分布的就越均匀。\n但问题是，实际中我们没有那么多节点。所以这个时候我们就加入虚拟节点，也就是对一个真实节点做多个副本。\n具体做法是，不再将真实节点映射到哈希环上，而是将虚拟节点映射到哈希环上，并将虚拟节点映射到实际节点，所以这里有「两层」映射关系。\n比如对每个节点分别设置 3 个虚拟节点：\n对节点 A 加上编号来作为虚拟节点：A-01、A-02、A-03 对节点 B 加上编号来作为虚拟节点：B-01、B-02、B-03 对节点 C 加上编号来作为虚拟节点：C-01、C-02、C-03 引入虚拟节点后，原本哈希环上只有 3 个节点的情况，就会变成有 9 个虚拟节点映射到哈希环上，哈希环上的节点数量多了 3 倍。 你可以看到，节点数量多了后，节点在哈希环上的分布就相对均匀了。这时候，如果有访问请求寻址到「A-01」这个虚拟节点，接着再通过「A-01」虚拟节点找到真实节点 A，这样请求就能访问到真实节点 A 了。 上面为了方便你理解，每个真实节点仅包含 3 个虚拟节点，这样能起到的均衡效果其实很有限。而在实际的工程中，虚拟节点的数量会大很多，比如 Nginx 的一致性哈希算法，每个权重为 1 的真实节点就含有160 个虚拟节点。 另外，虚拟节点除了会提高节点的均衡度，还会提高系统的稳定性。当节点变化时，会有不同的节点共同分担系统的变化，因此稳定性更高。 比如，当某个节点被移除时，对应该节点的多个虚拟节点均会移除，而这些虚拟节点按顺时针方向的下一个虚拟节点，可能会对应不同的真实节点，即这些不同的真实节点共同分担了节点变化导致的压力。 而且，有了虚拟节点后，还可以为硬件配置更好的节点增加权重，比如对权重更高的节点增加更多的虚拟机节点即可。 因此，带虚拟节点的一致性哈希方法不仅适合硬件配置不同的节点的场景，而且适合节点规模会发生变化的场景。\n5 总结 不同的负载均衡算法适用的业务场景也不同的。\n轮询这类的策略只能适用与每个节点的数据都是相同的场景，访问任意节点都能请求到数据。\n但是不适用分布式系统，因为分布式系统意味着数据水平切分到了不同的节点上，访问数据的时候，一定要寻址存储该数据的节点。\n哈希算法虽然能建立数据和节点的映射关系，但是每次在节点数量发生变化的时候，最坏情况下所有数据都需要迁移，这样太麻烦了。\n所以不适用节点数量变化的场景。为了减少迁移的数据量，就出现了一致性哈希算法。\n一致性哈希是指将「存储节点」和「数据」都映射到一个首尾相连的哈希环上。 如果增加或者移除一个节点，仅影响该节点在哈希环上顺时针相邻的后继节点，其它数据也不会受到影响。但是一致性哈希算法不能够均匀的分布节点，会出现大量请求都集中在一个节点的情况，在这种情况下进行容灾与扩容时，容易出现雪崩的连锁反应。\n为了解决一致性哈希算法不能够均匀的分布节点的问题，就需要引入虚拟节点，对一个真实节点做多个副本。\n不再将真实节点映射到哈希环上，而是将虚拟节点映射到哈希环上，并将虚拟节点映射到实际节点，所以这里有「两层」映射关系。引入虚拟节点后，可以会提高节点的均衡度，还会提高系统的稳定性。所以，带虚拟节点的一致性哈希方法不仅适合硬件配置不同的节点的场景，而且适合节点规模会发生变化的场景。\n","date":"2025-01-15T19:29:13+08:00","permalink":"http://localhost:1313/post/storage_system/consistent_hash/","tags":["consistent_hash"],"title":"一致性哈希算法"},{"categories":["storage"],"contents":"本文介绍raft协议。转载自：https://github.com/maemual/raft-zh_cn\n摘要 Raft 是一种为了管理复制日志的一致性算法。它提供了和 Paxos 算法相同的功能和性能，但是它的算法结构和 Paxos 不同，使得 Raft 算法更加容易理解并且更容易构建实际的系统。为了提升可理解性，Raft 将一致性算法分解成了几个关键模块，例如领导人选举、日志复制和安全性。同时它通过实施一个更强的一致性来减少需要考虑的状态的数量。一项用户研究的结果表明，对于学生而言，Raft 算法比 Paxos 算法更加容易学习。Raft 算法还包括一个新的机制来允许集群成员的动态改变，它利用重叠的大多数来保证安全性。\n1 介绍 一致性算法允许一组机器像一个整体一样工作，即使其中一些机器出现故障也能够继续工作下去。正因为如此，一致性算法在构建可信赖的大规模软件系统中扮演着重要的角色。在过去的 10 年里，Paxos 算法统治着一致性算法这一领域：绝大多数的实现都是基于 Paxos 或者受其影响。同时 Paxos 也成为了教学领域里讲解一致性问题时的示例。\n但是不幸的是，尽管有很多工作都在尝试降低它的复杂性，但是 Paxos 算法依然十分难以理解。并且，Paxos 自身的算法结构需要进行大幅的修改才能够应用到实际的系统中。因此工业界和学术界都对 Paxos 算法感到十分头疼。\n努力研究过 Paxos 算法之后，我们开始寻找一种新的一致性算法，可以为构建实际的系统和教学提供更好的基础。与 Paxos 不同，我们的首要目标是可理解性：我们是否可以在实际系统中定义一个一致性算法，并且比 Paxos 算法更容易学习。此外，我们希望该算法方便系统构建者的直觉的发展。重要的不仅仅是算法能够工作，更重要的是能够很清楚地知道它为什么能工作。\nRaft 一致性算法就是这些工作的结果。在设计 Raft 算法的时候，我们使用一些特别的技巧来提升它的可理解性，包括算法分解（Raft 主要被分成了领导人选举，日志复制和安全三个模块）和减少状态机的状态（相对于 Paxos，Raft 减少了非确定性和服务器互相处于非一致性的方式）。一份针对两所大学 43 个学生的研究表明 Raft 明显比 Paxos 算法更加容易理解。在这些学生同时学习了这两种算法之后，和 Paxos 比起来，其中 33 个学生能够回答有关于 Raft 的问题。\nRaft 算法在许多方面和现有的一致性算法都很相似（主要是 Oki 和 Liskov 的 Viewstamped Replication），但是它也有一些独特的特性：\n强领导人：和其他一致性算法相比，Raft 使用一种更强的领导能力形式。比如，日志条目只从领导人发送给其他的服务器。这种方式简化了对复制日志的管理并且使得 Raft 算法更加易于理解。 领导选举：Raft 算法使用一个随机计时器来选举领导人。这种方式只是在任何一致性算法都必须实现的心跳机制上增加了一点机制。在解决冲突的时候会更加简单快捷。 成员关系调整：Raft 使用一种共同一致的方法来处理集群成员变换的问题，在这种方法下，处于调整过程中的两种不同的配置集群中大多数机器会有重叠，这就使得集群在成员变换的时候依然可以继续工作。 我们相信，Raft 算法不论出于教学目的还是作为实践项目的基础都是要比 Paxos 或者其他一致性算法要优异的。它比其他算法更加简单，更加容易理解；它的算法描述足以实现一个现实的系统；它有好多开源的实现并且在很多公司里使用；它的安全特性已经被正式定义和证明；它的效率和其他算法比起来也不相上下。\n接下来，这篇论文会介绍以下内容：复制状态机问题（第 2 节），讨论 Paxos 的优点和缺点（第 3 节），讨论我们为了可理解性而采取的方法（第 4 节），阐述 Raft 一致性算法（第 5-8 节），评价 Raft 算法（第 9 节），以及一些相关的工作（第 10 节）。\n2 复制状态机 一致性算法是从复制状态机的背景下提出的（参考英文原文引用37）。在这种方法中，一组服务器上的状态机产生相同状态的副本，并且在一些机器宕掉的情况下也可以继续运行。复制状态机在分布式系统中被用于解决很多容错的问题。例如，大规模的系统中通常都有一个集群领导人，像 GFS、HDFS 和 RAMCloud，典型应用就是一个独立的复制状态机去管理领导选举和存储配置信息并且在领导人宕机的情况下也要存活下来。比如 Chubby 和 ZooKeeper。\n图 1 ：复制状态机的结构。一致性算法管理着来自客户端指令的复制日志。状态机从日志中处理相同顺序的相同指令，所以产生的结果也是相同的。\n复制状态机通常都是基于复制日志实现的，如图 1。每一个服务器存储一个包含一系列指令的日志，并且按照日志的顺序进行执行。每一个日志都按照相同的顺序包含相同的指令，所以每一个服务器都执行相同的指令序列。因为每个状态机都是确定的，每一次执行操作都产生相同的状态和同样的序列。\n一致性算法的任务是保证复制日志的一致性。服务器上的一致性模块接收客户端发送的指令然后添加到自己的日志中。它和其他服务器上的一致性模块进行通信来保证每一个服务器上的日志最终都以相同的顺序包含相同的请求，即使有些服务器发生故障。一旦指令被正确的复制，每一个服务器的状态机按照日志顺序处理他们，然后输出结果被返回给客户端。因此，服务器集群看起来形成了一个高可靠的状态机。\n实际系统中使用的一致性算法通常含有以下特性：\n安全性保证（绝对不会返回一个错误的结果）：在非拜占庭错误情况下，包括网络延迟、分区、丢包、重复和乱序等错误都可以保证正确。 可用性：集群中只要有大多数的机器可运行并且能够相互通信、和客户端通信，就可以保证可用。因此，一个典型的包含 5 个节点的集群可以容忍两个节点的失败。服务器被停止就认为是失败。它们稍后可能会从可靠存储的状态中恢复并重新加入集群。 不依赖时序来保证一致性：物理时钟错误或者极端的消息延迟只有在最坏情况下才会导致可用性问题。 通常情况下，一条指令可以尽可能快的在集群中大多数节点响应一轮远程过程调用时完成。小部分比较慢的节点不会影响系统整体的性能。 3 Paxos 算法的问题 在过去的 10 年里，Leslie Lamport 的 Paxos 算法几乎已经成为一致性的代名词：Paxos 是在课程教学中最经常使用的算法，同时也是大多数一致性算法实现的起点。Paxos 首先定义了一个能够达成单一决策一致的协议，比如单条的复制日志项。我们把这一子集叫做单决策 Paxos。然后通过组合多个 Paxos 协议的实例来促进一系列决策的达成。Paxos 保证安全性和活性，同时也支持集群成员关系的变更。Paxos 的正确性已经被证明，在通常情况下也很高效。\n不幸的是，Paxos 有两个明显的缺点。第一个缺点是 Paxos 算法特别的难以理解。完整的解释是出了名的不透明；通过极大的努力之后，也只有少数人成功理解了这个算法。因此，有了几次用更简单的术语来解释 Paxos 的尝试。尽管这些解释都只关注了单决策的子集问题，但依然很具有挑战性。在 2012 年 NSDI 的会议中的一次调查显示，很少有人对 Paxos 算法感到满意，甚至在经验老道的研究者中也是如此。我们自己也尝试去理解 Paxos；我们一直没能理解 Paxos 直到我们读了很多对 Paxos 的简化解释并且设计了我们自己的算法之后，这一过程花了近一年时间。\n我们假设 Paxos 的不透明性来自它选择单决策问题作为它的基础。单决策 Paxos 是晦涩微妙的，它被划分成了两种没有简单直观解释和无法独立理解的情景。因此，这导致了很难建立起直观的感受为什么单决策 Paxos 算法能够工作。构成多决策 Paxos 增加了很多错综复杂的规则。我们相信，在多决策上达成一致性的问题（一份日志而不是单一的日志记录）能够被分解成其他的方式并且更加直接和明显。\nPaxos算法的第二个问题就是它没有提供一个足够好的用来构建一个现实系统的基础。一个原因是还没有一种被广泛认同的多决策问题的算法。Lamport 的描述基本上都是关于单决策 Paxos 的；他简要描述了实施多决策 Paxos 的方法，但是缺乏很多细节。当然也有很多具体化 Paxos 的尝试，但是他们都互相不一样，和 Paxos 的概述也不同。例如 Chubby 这样的系统实现了一个类似于 Paxos 的算法，但是大多数的细节并没有被公开。\n而且，Paxos 算法的结构也不是十分易于构建实践的系统；单决策分解也会产生其他的结果。例如，独立地选择一组日志条目然后合并成一个序列化的日志并没有带来太多的好处，仅仅增加了不少复杂性。围绕着日志来设计一个系统是更加简单高效的；新日志条目以严格限制的顺序增添到日志中去。另一个问题是，Paxos 使用了一种对等的点对点的方式作为它的核心（尽管它最终提议了一种弱领导人的方法来优化性能）。在只有一个决策会被制定的简化世界中是很有意义的，但是很少有现实的系统使用这种方式。如果有一系列的决策需要被制定，首先选择一个领导人，然后让他去协调所有的决议，会更加简单快速。\n因此，实际的系统中很少有和 Paxos 相似的实践。每一种实现都是从 Paxos 开始研究，然后发现很多实现上的难题，再然后开发了一种和 Paxos 明显不一样的结构。这样是非常费时和容易出错的，并且理解 Paxos 的难度使得这个问题更加糟糕。Paxos 算法在理论上被证明是正确可行的，但是现实的系统和 Paxos 差别是如此的大，以至于这些证明没有什么太大的价值。下面来自 Chubby 实现非常典型：\n在Paxos算法描述和实现现实系统中间有着巨大的鸿沟。最终的系统建立在一种没有经过证明的算法之上。\n由于以上问题，我们认为 Paxos 算法既没有提供一个良好的基础给实践的系统，也没有给教学很好的帮助。基于一致性问题在大规模软件系统中的重要性，我们决定看看我们是否可以设计一个拥有更好特性的替代 Paxos 的一致性算法。Raft 算法就是这次实验的结果。\n4 为了可理解性的设计 设计 Raft 算法我们有几个初衷：它必须提供一个完整的实际的系统实现基础，这样才能大大减少开发者的工作；它必须在任何情况下都是安全的并且在大多数的情况下都是可用的；并且它的大部分操作必须是高效的。但是我们最重要也是最大的挑战是可理解性。它必须保证对于普遍的人群都可以十分容易的去理解。另外，它必须能够让人形成直观的认识，这样系统的构建者才能够在现实中进行必然的扩展。\n在设计 Raft 算法的时候，有很多的点需要我们在各种备选方案中进行选择。在这种情况下，我们评估备选方案基于可理解性原则：解释各个备选方案有多大的难度（例如，Raft 的状态空间有多复杂，是否有微妙的暗示）？对于一个读者而言，完全理解这个方案和暗示是否容易？\n我们意识到对这种可理解性分析上具有高度的主观性；尽管如此，我们使用了两种通常适用的技术来解决这个问题。第一个技术就是众所周知的问题分解：我们尽可能地将问题分解成几个相对独立的，可被解决的、可解释的和可理解的子问题。例如，Raft 算法被我们分成领导人选举，日志复制，安全性和成员变更几个部分。\n我们使用的第二个方法是通过减少状态的数量来简化需要考虑的状态空间，使得系统更加连贯并且在可能的时候消除不确定性。特别的，所有的日志是不允许有空洞的，并且 Raft 限制了日志之间变成不一致状态的可能。尽管在大多数情况下我们都试图消除不确定性，但是也有一些情况下不确定性可以提升可理解性。尤其是，随机化方法增加了不确定性，但是他们有利于减少状态空间数量，通过处理所有可能选择时使用相似的方法。我们使用随机化来简化 Raft 中领导人选举算法。\n5 Raft 一致性算法 Raft 是一种用来管理章节 2 中描述的复制日志的算法。图 2 为了参考之用，总结这个算法的简略版本，图 3 列举了这个算法的一些关键特性。图中的这些元素会在剩下的章节逐一介绍。\nRaft 通过选举一个杰出的领导人，然后给予他全部的管理复制日志的责任来实现一致性。领导人从客户端接收日志条目（log entries），把日志条目复制到其他服务器上，并告诉其他的服务器什么时候可以安全地将日志条目应用到他们的状态机中。拥有一个领导人大大简化了对复制日志的管理。例如，领导人可以决定新的日志条目需要放在日志中的什么位置而不需要和其他服务器商议，并且数据都从领导人流向其他服务器。一个领导人可能会发生故障，或者和其他服务器失去连接，在这种情况下一个新的领导人会被选举出来。\n通过领导人的方式，Raft 将一致性问题分解成了三个相对独立的子问题，这些问题会在接下来的子章节中进行讨论：\n领导选举：当现存的领导人发生故障的时候, 一个新的领导人需要被选举出来（章节 5.2） 日志复制：领导人必须从客户端接收日志条目（log entries）然后复制到集群中的其他节点，并强制要求其他节点的日志和自己保持一致。 安全性：在 Raft 中安全性的关键是在图 3 中展示的状态机安全：如果有任何的服务器节点已经应用了一个确定的日志条目到它的状态机中，那么其他服务器节点不能在同一个日志索引位置应用一个不同的指令。章节 5.4 阐述了 Raft 算法是如何保证这个特性的；这个解决方案涉及到选举机制（5.2 节）上的一个额外限制。 在展示一致性算法之后，这一章节会讨论一些可用性的问题和计时在系统中的作用。\n状态：\n所有服务器上的持久性状态 (在响应 RPC 请求之前，已经更新到了稳定的存储设备)\n参数 解释 currentTerm 服务器已知最新的任期（在服务器首次启动时初始化为0，单调递增） votedFor 当前任期内收到选票的 candidateId，如果没有投给任何候选人 则为空 log[] 日志条目；每个条目包含了用于状态机的命令，以及领导人接收到该条目时的任期（初始索引为1） 所有服务器上的易失性状态\n参数 解释 commitIndex 已知已提交的最高的日志条目的索引（初始值为0，单调递增） lastApplied 已经被应用到状态机的最高的日志条目的索引（初始值为0，单调递增） 领导人（服务器）上的易失性状态 (选举后已经重新初始化)\n参数 解释 nextIndex[] 对于每一台服务器，发送到该服务器的下一个日志条目的索引（初始值为领导人最后的日志条目的索引+1） matchIndex[] 对于每一台服务器，已知的已经复制到该服务器的最高日志条目的索引（初始值为0，单调递增） 追加条目（AppendEntries）RPC：\n由领导人调用，用于日志条目的复制，同时也被当做心跳使用\n参数 解释 term 领导人的任期 leaderId 领导人 ID 因此跟随者可以对客户端进行重定向（译者注：跟随者根据领导人 ID 把客户端的请求重定向到领导人，比如有时客户端把请求发给了跟随者而不是领导人） prevLogIndex 紧邻新日志条目之前的那个日志条目的索引 prevLogTerm 紧邻新日志条目之前的那个日志条目的任期 entries[] 需要被保存的日志条目（被当做心跳使用时，则日志条目内容为空；为了提高效率可能一次性发送多个） leaderCommit 领导人的已知已提交的最高的日志条目的索引 返回值 解释 term 当前任期，对于领导人而言 它会更新自己的任期 success 如果跟随者所含有的条目和 prevLogIndex 以及 prevLogTerm 匹配上了，则为 true 接收者的实现：\n返回假 如果领导人的任期小于接收者的当前任期（译者注：这里的接收者是指跟随者或者候选人）（5.1 节） 返回假 如果接收者日志中没有包含这样一个条目 即该条目的任期在 prevLogIndex 上能和 prevLogTerm 匹配上 （译者注：在接收者日志中 如果能找到一个和 prevLogIndex 以及 prevLogTerm 一样的索引和任期的日志条目 则继续执行下面的步骤 否则返回假）（5.3 节） 如果一个已经存在的条目和新条目（译者注：即刚刚接收到的日志条目）发生了冲突（因为索引相同，任期不同），那么就删除这个已经存在的条目以及它之后的所有条目 （5.3 节） 追加日志中尚未存在的任何新条目 如果领导人的已知已提交的最高日志条目的索引大于接收者的已知已提交最高日志条目的索引（leaderCommit \u0026gt; commitIndex），则把接收者的已知已经提交的最高的日志条目的索引commitIndex 重置为 领导人的已知已经提交的最高的日志条目的索引 leaderCommit 或者是 上一个新条目的索引 取两者的最小值 请求投票（RequestVote）RPC：\n由候选人负责调用用来征集选票（5.2 节）\n参数 解释 term 候选人的任期号 candidateId 请求选票的候选人的 ID lastLogIndex 候选人的最后日志条目的索引值 lastLogTerm 候选人最后日志条目的任期号 返回值 解释 term 当前任期号，以便于候选人去更新自己的任期号 voteGranted 候选人赢得了此张选票时为真 接收者实现：\n如果term \u0026lt; currentTerm返回 false （5.2 节） 如果 votedFor 为空或者为 candidateId，并且候选人的日志至少和自己一样新，那么就投票给他（5.2 节，5.4 节） 所有服务器需遵守的规则：\n所有服务器：\n如果commitIndex \u0026gt; lastApplied，则 lastApplied 递增，并将log[lastApplied]应用到状态机中（5.3 节） 如果接收到的 RPC 请求或响应中，任期号T \u0026gt; currentTerm，则令 currentTerm = T，并切换为跟随者状态（5.1 节） 跟随者（5.2 节）：\n响应来自候选人和领导人的请求 如果在超过选举超时时间的情况之前没有收到当前领导人（即该领导人的任期需与这个跟随者的当前任期相同）的心跳/附加日志，或者是给某个候选人投了票，就自己变成候选人 候选人（5.2 节）：\n在转变成候选人后就立即开始选举过程 自增当前的任期号（currentTerm） 给自己投票 重置选举超时计时器 发送请求投票的 RPC 给其他所有服务器 如果接收到大多数服务器的选票，那么就变成领导人 如果接收到来自新的领导人的附加日志（AppendEntries）RPC，则转变成跟随者 如果选举过程超时，则再次发起一轮选举 领导人：\n一旦成为领导人：发送空的附加日志（AppendEntries）RPC（心跳）给其他所有的服务器；在一定的空余时间之后不停的重复发送，以防止跟随者超时（5.2 节） 如果接收到来自客户端的请求：附加条目到本地日志中，在条目被应用到状态机后响应客户端（5.3 节） 如果对于一个跟随者，最后日志条目的索引值大于等于 nextIndex（lastLogIndex ≥ nextIndex），则发送从 nextIndex 开始的所有日志条目： 如果成功：更新相应跟随者的 nextIndex 和 matchIndex 如果因为日志不一致而失败，则 nextIndex 递减并重试 假设存在 N 满足N \u0026gt; commitIndex，使得大多数的 matchIndex[i] ≥ N以及log[N].term == currentTerm 成立，则令 commitIndex = N（5.3 和 5.4 节） 图 2：一个关于 Raft 一致性算法的浓缩总结（不包括成员变换和日志压缩）。\n特性 解释 选举安全特性 对于一个给定的任期号，最多只会有一个领导人被选举出来（5.2 节） 领导人只附加原则 领导人绝对不会删除或者覆盖自己的日志，只会增加（5.3 节） 日志匹配原则 如果两个日志在某一相同索引位置日志条目的任期号相同，那么我们就认为这两个日志从头到该索引位置之间的内容完全一致（5.3 节） 领导人完全特性 如果某个日志条目在某个任期号中已经被提交，那么这个条目必然出现在更大任期号的所有领导人中（5.4 节） 状态机安全特性 如果某一服务器已将给定索引位置的日志条目应用至其状态机中，则其他任何服务器在该索引位置不会应用不同的日志条目（5.4.3 节） 图 3：Raft 在任何时候都保证以上的各个特性。\n5.1 Raft 基础 一个 Raft 集群包含若干个服务器节点；5 个服务器节点是一个典型的例子，这允许整个系统容忍 2 个节点失效。在任何时刻，每一个服务器节点都处于这三个状态之一：领导人、跟随者或者候选人。在通常情况下，系统中只有一个领导人并且其他的节点全部都是跟随者。跟随者都是被动的：他们不会发送任何请求，只是简单的响应来自领导人或者候选人的请求。领导人处理所有的客户端请求（如果一个客户端和跟随者联系，那么跟随者会把请求重定向给领导人）。第三种状态，候选人，是用来在 5.2 节描述的选举新领导人时使用。图 4 展示了这些状态和他们之间的转换关系；这些转换关系会在接下来进行讨论。\n图 4：服务器状态。跟随者只响应来自其他服务器的请求。如果跟随者接收不到消息，那么他就会变成候选人并发起一次选举。获得集群中大多数选票的候选人将成为领导人。在一个任期内，领导人一直都会是领导人，直到自己宕机了。\n图 5：时间被划分成一个个的任期，每个任期始于一次选举。在选举成功后，领导人会管理整个集群直到任期结束。有时候选举会失败，那么这个任期就会没有领导人而结束。任期之间的切换可以在不同的时间不同的服务器上观察到。\nRaft 把时间分割成任意长度的任期，如图 5。任期用连续的整数标记。每一段任期从一次选举开始，就像章节 5.2 描述的一样，一个或者多个候选人尝试成为领导人。 如果一个候选人赢得选举，然后他就在接下来的任期内充当领导人的职责。 在某些情况下，一次选举过程会造成选票的瓜分。在这种情况下，这一任期会以没有领导人结束；一个新的任期（和一次新的选举）会很快重新开始。\nRaft 保证了在一个给定的任期内，最多只有一个领导人。\n不同的服务器节点可能多次观察到任期之间的转换，但在某些情况下，一个节点也可能观察不到任何一次选举或者整个任期全程。任期在 Raft 算法中充当逻辑时钟的作用，任期使得服务器可以检测一些过期的信息：比如过期的领导人。 每个节点存储一个当前任期号，这一编号在整个时期内单调递增。\n每当服务器之间通信的时候都会交换当前任期号；如果一个服务器的当前任期号比其他人小，那么他会更新自己的任期号到较大的任期号值。\n如果一个候选人或者领导人发现自己的任期号过期了，那么他会立即恢复成跟随者状态。\n如果一个节点接收到一个包含过期的任期号的请求，那么他会直接拒绝这个请求。\nRaft 算法中服务器节点之间通信使用远程过程调用（RPCs），并且基本的一致性算法只需要两种类型的 RPCs。请求投票（RequestVote） RPCs 由候选人在选举期间发起（章节 5.2），然后附加条目（AppendEntries）RPCs 由领导人发起，用来复制日志和提供一种心跳机制（章节 5.3）。第 7 节为了在服务器之间传输快照增加了第三种 RPC。当服务器没有及时的收到 RPC 的响应时，会进行重试， 并且他们能够并行的发起 RPCs 来获得最佳的性能。\n5.2 领导人选举 Raft 使用一种心跳机制来触发领导人选举。\n当服务器程序启动时，他们都是跟随者身份。\n一个服务器节点继续保持着跟随者状态只要他从领导人或者候选人处接收到有效的 RPCs。 领导人周期性的向所有跟随者发送心跳包（即不包含日志项内容的附加条目（AppendEntries） RPCs）来维持自己的权威。\n如果一个跟随者在一段时间里没有接收到任何消息，也就是选举超时，那么他就会认为系统中没有可用的领导人,并且发起选举以选出新的领导人。\n要开始一次选举过程，跟随者先要增加自己的当前任期号并且转换到候选人状态。然后他会并行地向集群中的其他服务器节点发送请求投票的 RPCs 来给自己投票。\n候选人会继续保持着当前状态直到以下三件事情之一发生：\n(a) 他自己赢得了这次的选举，\n(b) 其他的服务器成为领导人，\n(c) 一段时间之后没有任何一个获胜的人。这些结果会分别的在下面的段落里进行讨论。\n当一个候选人从整个集群的大多数服务器节点获得了针对同一个任期号的选票，那么他就赢得了这次选举并成为领导人。每一个服务器最多会对一个任期号投出一张选票，按照先来先服务的原则（注意：5.4 节在投票上增加了一点额外的限制）。要求大多数选票的规则确保了最多只会有一个候选人赢得此次选举（图 3 中的选举安全性）。一旦候选人赢得选举，他就立即成为领导人。然后他会向其他的服务器发送心跳消息来建立自己的权威并且阻止发起新的选举。\n在等待投票的时候，候选人可能会从其他的服务器接收到声明它是领导人的附加条目（AppendEntries）RPC。如果这个领导人的任期号（包含在此次的 RPC中）不小于候选人当前的任期号，那么候选人会承认领导人合法并回到跟随者状态。 如果此次 RPC 中的任期号比自己小，那么候选人就会拒绝这次的 RPC 并且继续保持候选人状态。\n第三种可能的结果是候选人既没有赢得选举也没有输：如果有多个跟随者同时成为候选人，那么选票可能会被瓜分以至于没有候选人可以赢得大多数人的支持。当这种情况发生的时候，每一个候选人都会超时，然后通过增加当前任期号来开始一轮新的选举。然而，没有其他机制的话，选票可能会被无限的重复瓜分。\nRaft 算法使用随机选举超时时间的方法来确保很少会发生选票瓜分的情况，就算发生也能很快的解决。为了阻止选票起初就被瓜分，选举超时时间是从一个固定的区间（例如 150-300 毫秒）随机选择。这样可以把服务器都分散开以至于在大多数情况下只有一个服务器会选举超时；然后他赢得选举并在其他服务器超时之前发送心跳包。同样的机制被用在选票瓜分的情况下。每一个候选人在开始一次选举的时候会重置一个随机的选举超时时间，然后在超时时间内等待投票的结果；这样减少了在新的选举中另外的选票瓜分的可能性。9.3 节展示了这种方案能够快速的选出一个领导人。\n领导人选举这个例子，体现了可理解性原则是如何指导我们进行方案设计的。起初我们计划使用一种排名系统：每一个候选人都被赋予一个唯一的排名，供候选人之间竞争时进行选择。如果一个候选人发现另一个候选人拥有更高的排名，那么他就会回到跟随者状态，这样高排名的候选人能够更加容易的赢得下一次选举。但是我们发现这种方法在可用性方面会有一点问题（如果高排名的服务器宕机了，那么低排名的服务器可能会超时并再次进入候选人状态。而且如果这个行为发生得足够快，则可能会导致整个选举过程都被重置掉）。我们针对算法进行了多次调整，但是每次调整之后都会有新的问题。最终我们认为随机重试的方法是更加明显和易于理解的。\n5.3 日志复制 一旦一个领导人被选举出来，他就开始为客户端提供服务。\n客户端的每一个请求都包含一条被复制状态机执行的指令。\n领导人把这条指令作为一条新的日志条目附加到日志中去，然后并行地发起附加条目 RPCs 给其他的服务器，让他们复制这条日志条目。当这条日志条目被安全地复制（下面会介绍），领导人会应用这条日志条目到它的状态机中然后把执行的结果返回给客户端。如果跟随者崩溃或者运行缓慢，再或者网络丢包，领导人会不断的重复尝试附加日志条目 RPCs （尽管已经回复了客户端）直到所有的跟随者都最终存储了所有的日志条目。\n图 6：日志由有序序号标记的条目组成。每个条目都包含创建时的任期号（图中框中的数字），和一个状态机需要执行的指令。一个条目当可以安全地被应用到状态机中去的时候，就认为是可以提交了。\n日志以图 6 展示的方式组织。每一个日志条目存储一条状态机指令和从领导人收到这条指令时的任期号。日志中的任期号用来检查是否出现不一致的情况，同时也用来保证图 3 中的某些性质。每一条日志条目同时也都有一个整数索引值来表明它在日志中的位置。\n领导人来决定什么时候把日志条目应用到状态机中是安全的；这种日志条目被称为已提交。Raft 算法保证所有已提交的日志条目都是持久化的并且最终会被所有可用的状态机执行。在领导人将创建的日志条目复制到大多数的服务器上的时候，日志条目就会被提交（例如在图 6 中的条目 7）。同时，领导人的日志中之前的所有日志条目也都会被提交，包括由其他领导人创建的条目。5.4 节会讨论某些当在领导人改变之后应用这条规则的隐晦内容，同时他也展示了这种提交的定义是安全的。领导人跟踪了最大的将会被提交的日志项的索引，并且索引值会被包含在未来的所有附加日志 RPCs （包括心跳包），这样其他的服务器才能最终知道领导人的提交位置。一旦跟随者知道一条日志条目已经被提交，那么他也会将这个日志条目应用到本地的状态机中（按照日志的顺序）。\n我们设计了 Raft 的日志机制来维护不同服务器日志之间的高层次的一致性。这么做不仅简化了系统的行为也使其更具有可预测性，同时它也是安全性保证的一个重要组件。Raft 维护着以下的特性，这些特性共同组成了图 3 中的日志匹配特性（Log Matching Property）：\n如果在不同的日志中的两个条目拥有相同的索引和任期号，那么他们存储了相同的指令。 如果在不同的日志中的两个条目拥有相同的索引和任期号，那么他们之前的所有日志条目也全部相同。 第一个特性来自这样的一个事实，领导人最多在一个任期里在指定的一个日志索引位置创建一条日志条目，同时日志条目在日志中的位置也从来不会改变。第二个特性由附加日志 RPC 的一个简单的一致性检查所保证。在发送附加日志 RPC 的时候，领导人会把新的日志条目前紧挨着的条目的索引位置和任期号包含在日志内。如果跟随者在它的日志中找不到包含相同索引位置和任期号的条目，那么他就会拒绝接收新的日志条目。一致性检查就像一个归纳步骤：一开始空的日志状态肯定是满足日志匹配特性的，然后一致性检查在日志扩展的时候保护了日志匹配特性。因此，每当附加日志 RPC 返回成功时，领导人就知道跟随者的日志一定是和自己相同的了。\n在正常的操作中，领导人和跟随者的日志保持一致性，所以附加日志 RPC 的一致性检查从来不会失败。然而，领导人崩溃的情况会使得日志处于不一致的状态（老的领导人可能还没有完全复制所有的日志条目）。这种不一致问题会在领导人和跟随者的一系列崩溃下加剧。图 7 展示了跟随者的日志可能和新的领导人不同。跟随者可能会丢失一些在新的领导人中存在的日志条目，他也可能拥有一些领导人没有的日志条目，或者两者都发生。丢失或者多出日志条目可能会持续多个任期。\n图 7：当一个领导人成功当选时，跟随者可能是任何情况（a-f）。每一个盒子表示是一个日志条目；里面的数字表示任期号。跟随者可能会缺少一些日志条目（a-b），可能会有一些未被提交的日志条目（c-d），或者两种情况都存在（e-f）。例如，场景 f 可能会这样发生，某服务器在任期 2 的时候是领导人，已附加了一些日志条目到自己的日志中，但在提交之前就崩溃了；很快这个机器就被重启了，在任期 3 重新被选为领导人，并且又增加了一些日志条目到自己的日志中；在任期 2 和任期 3 的日志被提交之前，这个服务器又宕机了，并且在接下来的几个任期里一直处于宕机状态。\n在 Raft 算法中，领导人是通过强制跟随者直接复制自己的日志来处理不一致问题的。这意味着在跟随者中的冲突的日志条目会被领导人的日志覆盖。5.4 节会阐述如何通过增加一些限制来使得这样的操作是安全的。\n要使得跟随者的日志进入和自己一致的状态，领导人必须找到最后两者达成一致的地方，然后删除跟随者从那个点之后的所有日志条目，并发送自己在那个点之后的日志给跟随者。所有的这些操作都在进行附加日志 RPCs 的一致性检查时完成。领导人针对每一个跟随者维护了一个 nextIndex，这表示下一个需要发送给跟随者的日志条目的索引地址。当一个领导人刚获得权力的时候，他初始化所有的 nextIndex 值为自己的最后一条日志的 index 加 1（图 7 中的 11）。如果一个跟随者的日志和领导人不一致，那么在下一次的附加日志 RPC 时的一致性检查就会失败。在被跟随者拒绝之后，领导人就会减小 nextIndex 值并进行重试。最终 nextIndex 会在某个位置使得领导人和跟随者的日志达成一致。当这种情况发生，附加日志 RPC 就会成功，这时就会把跟随者冲突的日志条目全部删除并且加上领导人的日志。一旦附加日志 RPC 成功，那么跟随者的日志就会和领导人保持一致，并且在接下来的任期里一直继续保持。\n如果需要的话，算法可以通过减少被拒绝的附加日志 RPCs 的次数来优化。例如，当附加日志 RPC 的请求被拒绝的时候，跟随者可以(返回)冲突条目的任期号和该任期号对应的最小索引地址。借助这些信息，领导人可以减小 nextIndex 一次性越过该冲突任期的所有日志条目；这样就变成每个任期需要一次附加条目 RPC 而不是每个条目一次。在实践中，我们十分怀疑这种优化是否是必要的，因为失败是很少发生的并且也不大可能会有这么多不一致的日志。\n通过这种机制，领导人在获得权力的时候就不需要任何特殊的操作来恢复一致性。他只需要进行正常的操作，然后日志就能在回复附加日志 RPC 的一致性检查失败的时候自动趋于一致。领导人从来不会覆盖或者删除自己的日志（图 3 的领导人只附加特性）。\n日志复制机制展示出了第 2 节中形容的一致性特性：Raft 能够接受，复制并应用新的日志条目只要大部分的机器是工作的；在通常的情况下，新的日志条目可以在一次 RPC 中被复制给集群中的大多数机器；并且单个的缓慢的跟随者不会影响整体的性能。\n5.4 安全性 前面的章节里描述了 Raft 算法是如何选举和复制日志的。然而，到目前为止描述的机制并不能充分的保证每一个状态机会按照相同的顺序执行相同的指令。例如，一个跟随者可能会进入不可用状态同时领导人已经提交了若干的日志条目，然后这个跟随者可能会被选举为领导人并且覆盖这些日志条目；因此，不同的状态机可能会执行不同的指令序列。\n这一节通过在领导选举的时候增加一些限制来完善 Raft 算法。这一限制保证了任何的领导人对于给定的任期号，都拥有了之前任期的所有被提交的日志条目（图 3 中的领导人完整特性）。增加这一选举时的限制，我们对于提交时的规则也更加清晰。最终，我们将展示对于领导人完整特性（Leader Completeness Property） 的简要证明，并且说明该特性是如何引导复制状态机做出正确行为的。\n5.4.1 选举限制 在任何基于领导人的一致性算法中，领导人都必须存储所有已经提交的日志条目。在某些一致性算法中，例如 Viewstamped Replication，某个节点即使是一开始并没有包含所有已经提交的日志条目，它也能被选为领导人。这些算法都包含一些额外的机制来识别丢失的日志条目并把他们传送给新的领导人，要么是在选举阶段要么在之后很快进行。不幸的是，这种方法会导致相当大的额外的机制和复杂性。Raft 使用了一种更加简单的方法，它可以保证在选举的时候新的领导人拥有所有之前任期中已经提交的日志条目，而不需要传送这些日志条目给领导人。这意味着日志条目的传送是单向的，只从领导人传给跟随者，并且领导人从不会覆盖自身本地日志中已经存在的条目。\nRaft 使用投票的方式来阻止一个候选人赢得选举，除非这个候选人包含了所有已经提交的日志条目。\n候选人为了赢得选举必须联系集群中的大部分节点，这意味着每一个已经提交的日志条目在这些服务器节点中肯定存在于至少一个节点上。如果候选人的日志至少和大多数的服务器节点一样新（这个新的定义会在下面讨论），那么他一定持有了所有已经提交的日志条目。\n请求投票（RequestVote） RPC 实现了这样的限制：RPC 中包含了候选人的日志信息，然后投票人会拒绝掉那些日志没有自己新的投票请求。\nRaft 通过比较两份日志中最后一条日志条目的索引值和任期号定义谁的日志比较新。\n如果两份日志最后的条目的任期号不同，那么任期号大的日志更加新。\n如果两份日志最后的条目任期号相同，那么日志比较长的那个就更加新。\n5.4.2 提交之前任期内的日志条目 如同 5.3 节介绍的那样，领导人知道一条当前任期内的日志记录是可以被提交的，只要它被存储到了大多数的服务器上。如果一个领导人在提交日志条目之前崩溃了，未来后续的领导人会继续尝试复制这条日志记录。然而，一个领导人不能断定一个之前任期里的日志条目被保存到大多数服务器上的时候就一定已经提交了。图 8 展示了一种情况，一条已经被存储到大多数节点上的老日志条目，也依然有可能会被未来的领导人覆盖掉。\n图 8：如图的时间序列展示了为什么领导人无法决定对老任期号的日志条目进行提交。在 (a) 中，S1 是领导人，部分的(跟随者)复制了索引位置 2 的日志条目。在 (b) 中，S1 崩溃了，然后 S5 在任期 3 里通过 S3、S4 和自己的选票赢得选举，然后从客户端接收了一条不一样的日志条目放在了索引 2 处。然后到 (c)，S5 又崩溃了；S1 重新启动，选举成功，开始复制日志。在这时，来自任期 2 的那条日志已经被复制到了集群中的大多数机器上，但是还没有被提交。如果 S1 在 (d) 中又崩溃了，S5 可以重新被选举成功（通过来自 S2，S3 和 S4 的选票），然后覆盖了他们在索引 2 处的日志。反之，如果在崩溃之前，S1 把自己主导的新任期里产生的日志条目复制到了大多数机器上，就如 (e) 中那样，那么在后面任期里面这些新的日志条目就会被提交（因为 S5 就不可能选举成功）。 这样在同一时刻就同时保证了，之前的所有老的日志条目就会被提交。\n为了消除图 8 里描述的情况，Raft 永远不会通过计算副本数目的方式去提交一个之前任期内的日志条目。只有领导人当前任期里的日志条目通过计算副本数目可以被提交；一旦当前任期的日志条目以这种方式被提交，那么由于日志匹配特性，之前的日志条目也都会被间接的提交。在某些情况下，领导人可以安全的知道一个老的日志条目是否已经被提交（例如，该条目是否存储到所有服务器上），但是 Raft 为了简化问题使用一种更加保守的方法。\n当领导人复制之前任期里的日志时，Raft 会为所有日志保留原始的任期号, 这在提交规则上产生了额外的复杂性。在其他的一致性算法中，如果一个新的领导人要重新复制之前的任期里的日志时，它必须使用当前新的任期号。Raft 使用的方法更加容易辨别出日志，因为它可以随着时间和日志的变化对日志维护着同一个任期编号。另外，和其他的算法相比，Raft 中的新领导人只需要发送更少日志条目（其他算法中必须在他们被提交之前发送更多的冗余日志条目来为他们重新编号）。\n5.4.3 安全性论证 在给定了完整的 Raft 算法之后，我们现在可以更加精确的讨论领导人完整性特性（这一讨论基于 9.2 节的安全性证明）。我们假设领导人完全性特性是不存在的，然后我们推出矛盾来。假设任期 T 的领导人（领导人 T）在任期内提交了一条日志条目，但是这条日志条目没有被存储到未来某个任期的领导人的日志中。设大于 T 的最小任期 U 的领导人 U 没有这条日志条目。\n图 9：如果 S1 （任期 T 的领导人）在它的任期里提交了一条新的日志，然后 S5 在之后的任期 U 里被选举为领导人，那么至少会有一个机器，如 S3，既拥有来自 S1 的日志，也给 S5 投票了。\n在领导人 U 选举的时候一定没有那条被提交的日志条目（领导人从不会删除或者覆盖任何条目）。 领导人 T 复制这条日志条目给集群中的大多数节点，同时，领导人 U 从集群中的大多数节点赢得了选票。因此，至少有一个节点（投票者、选民）同时接受了来自领导人 T 的日志条目，并且给领导人 U 投票了，如图 9。这个投票者是产生这个矛盾的关键。 这个投票者必须在给领导人 U 投票之前先接受了从领导人 T 发来的已经被提交的日志条目；否则他就会拒绝来自领导人 T 的附加日志请求（因为此时他的任期号会比 T 大）。 投票者在给领导人 U 投票时依然保存有这条日志条目，因为任何中间的领导人都包含该日志条目（根据上述的假设），领导人从不会删除条目，并且跟随者只有在和领导人冲突的时候才会删除条目。 投票者把自己选票投给领导人 U 时，领导人 U 的日志必须和投票者自己一样新。这就导致了两者矛盾之一。 首先，如果投票者和领导人 U 的最后一条日志的任期号相同，那么领导人 U 的日志至少和投票者一样长，所以领导人 U 的日志一定包含所有投票者的日志。这是另一处矛盾，因为投票者包含了那条已经被提交的日志条目，但是在上述的假设里，领导人 U 是不包含的。 除此之外，领导人 U 的最后一条日志的任期号就必须比投票人大了。此外，他也比 T 大，因为投票人的最后一条日志的任期号至少和 T 一样大（他包含了来自任期 T 的已提交的日志）。创建了领导人 U 最后一条日志的之前领导人一定已经包含了那条被提交的日志（根据上述假设，领导人 U 是第一个不包含该日志条目的领导人）。所以，根据日志匹配特性，领导人 U 一定也包含那条被提交的日志，这里产生矛盾。 这里完成了矛盾。因此，所有比 T 大的领导人一定包含了所有来自 T 的已经被提交的日志。 日志匹配原则保证了未来的领导人也同时会包含被间接提交的条目，例如图 8 (e) 中的索引 2。 通过领导人完全特性，我们就能证明图 3 中的状态机安全特性，即如果服务器已经在某个给定的索引值应用了日志条目到自己的状态机里，那么其他的服务器不会应用一个不一样的日志到同一个索引值上。在一个服务器应用一条日志条目到他自己的状态机中时，他的日志必须和领导人的日志，在该条目和之前的条目上相同，并且已经被提交。现在我们来考虑在任何一个服务器应用一个指定索引位置的日志的最小任期；日志完全特性保证拥有更高任期号的领导人会存储相同的日志条目，所以之后的任期里应用某个索引位置的日志条目也会是相同的值。因此，状态机安全特性是成立的。\n最后，Raft 要求服务器按照日志中索引位置顺序应用日志条目。和状态机安全特性结合起来看，这就意味着所有的服务器会应用相同的日志序列集到自己的状态机中，并且是按照相同的顺序。\n5.5 跟随者和候选人崩溃 到目前为止，我们都只关注了领导人崩溃的情况。跟随者和候选人崩溃后的处理方式比领导人要简单的多，并且他们的处理方式是相同的。如果跟随者或者候选人崩溃了，那么后续发送给他们的 RPCs 都会失败。Raft 中处理这种失败就是简单地通过无限的重试；如果崩溃的机器重启了，那么这些 RPC 就会完整的成功。如果一个服务器在完成了一个 RPC，但是还没有响应的时候崩溃了，那么在他重新启动之后就会再次收到同样的请求。Raft 的 RPCs 都是幂等的，所以这样重试不会造成任何问题。例如一个跟随者如果收到附加日志请求但是他已经包含了这一日志，那么他就会直接忽略这个新的请求。\n5.6 时间和可用性 Raft 的要求之一就是安全性不能依赖时间：整个系统不能因为某些事件运行的比预期快一点或者慢一点就产生了错误的结果。但是，可用性（系统可以及时的响应客户端）不可避免的要依赖于时间。例如，如果消息交换比服务器故障间隔时间长，候选人将没有足够长的时间来赢得选举；没有一个稳定的领导人，Raft 将无法工作。\n领导人选举是 Raft 中对时间要求最为关键的方面。Raft 可以选举并维持一个稳定的领导人,只要系统满足下面的时间要求：\n广播时间（broadcastTime） \u0026laquo; 选举超时时间（electionTimeout） \u0026laquo; 平均故障间隔时间（MTBF）\n在这个不等式中，广播时间指的是从一个服务器并行的发送 RPCs 给集群中的其他服务器并接收响应的平均时间；选举超时时间就是在 5.2 节中介绍的选举的超时时间限制；然后平均故障间隔时间就是对于一台服务器而言，两次故障之间的平均时间。广播时间必须比选举超时时间小一个量级，这样领导人才能够发送稳定的心跳消息来阻止跟随者开始进入选举状态；通过随机化选举超时时间的方法，这个不等式也使得选票瓜分的情况变得不可能。选举超时时间应该要比平均故障间隔时间小上几个数量级，这样整个系统才能稳定的运行。当领导人崩溃后，整个系统会大约相当于选举超时的时间里不可用；我们希望这种情况在整个系统的运行中很少出现。\n广播时间和平均故障间隔时间是由系统决定的，但是选举超时时间是我们自己选择的。Raft 的 RPCs 需要接收方将信息持久化的保存到稳定存储中去，所以广播时间大约是 0.5 毫秒到 20 毫秒，取决于存储的技术。因此，选举超时时间可能需要在 10 毫秒到 500 毫秒之间。大多数的服务器的平均故障间隔时间都在几个月甚至更长，很容易满足时间的需求。\n6 集群成员变化 到目前为止，我们都假设集群的配置（加入到一致性算法的服务器集合）是固定不变的。但是在实践中，偶尔是会改变集群的配置的，例如替换那些宕机的机器或者改变复制级别。尽管可以通过暂停整个集群，更新所有配置，然后重启整个集群的方式来实现，但是在更改的时候集群会不可用。另外，如果存在手工操作步骤，那么就会有操作失误的风险。为了避免这样的问题，我们决定自动化配置改变并且将其纳入到 Raft 一致性算法中来。\n为了让配置修改机制能够安全，那么在转换的过程中不能够存在任何时间点使得两个领导人在同一个任期里同时被选举成功。不幸的是，任何服务器直接从旧的配置直接转换到新的配置的方案都是不安全的。一次性原子地转换所有服务器是不可能的，所以在转换期间整个集群存在划分成两个独立的大多数群体的可能性（见图 10）。\n图 10：直接从一种配置转到新的配置是十分不安全的，因为各个机器可能在任何的时候进行转换。在这个例子中，集群配额从 3 台机器变成了 5 台。不幸的是，存在这样的一个时间点，两个不同的领导人在同一个任期里都可以被选举成功。一个是通过旧的配置，一个通过新的配置。\n为了保证安全性，配置更改必须使用两阶段方法。目前有很多种两阶段的实现。例如，有些系统在第一阶段停掉旧的配置所以集群就不能处理客户端请求；然后在第二阶段在启用新的配置。在 Raft 中，集群先切换到一个过渡的配置，我们称之为共同一致（joint consensus)；一旦共同一致已经被提交了，那么系统就切换到新的配置上。共同一致是老配置和新配置的结合：\n日志条目被复制给集群中新、老配置的所有服务器。 新、旧配置的服务器都可以成为领导人。 达成一致（针对选举和提交）需要分别在两种配置上获得大多数的支持。 共同一致允许独立的服务器在不影响安全性的前提下，在不同的时间进行配置转换过程。此外，共同一致可以让集群在配置转换的过程中依然响应客户端的请求。\n集群配置在复制日志中以特殊的日志条目来存储和通信；图 11 展示了配置转换的过程。当一个领导人接收到一个改变配置从 C-old 到 C-new 的请求，他会为了共同一致存储配置（图中的 C-old,new），以前面描述的日志条目和副本的形式。一旦一个服务器将新的配置日志条目增加到它的日志中，他就会用这个配置来做出未来所有的决定（服务器总是使用最新的配置，无论他是否已经被提交）。这意味着领导人要使用 C-old,new 的规则来决定日志条目 C-old,new 什么时候需要被提交。如果领导人崩溃了，被选出来的新领导人可能是使用 C-old 配置也可能是 C-old,new 配置，这取决于赢得选举的候选人是否已经接收到了 C-old,new 配置。在任何情况下， C-new 配置在这一时期都不会单方面的做出决定。\n一旦 C-old,new 被提交，那么无论是 C-old 还是 C-new，如果不经过另一个配置的允许都不能单独做出决定，并且领导人完全特性保证了只有拥有 C-old,new 日志条目的服务器才有可能被选举为领导人。这个时候，领导人创建一条关于 C-new 配置的日志条目并复制给集群就是安全的了。再者，每个服务器在见到新的配置的时候就会立即生效。当新的配置在 C-new 的规则下被提交，旧的配置就变得无关紧要，同时不使用新的配置的服务器就可以被关闭了。如图 11，C-old 和 C-new 没有任何机会同时做出单方面的决定；这保证了安全性。\n图 11：一个配置切换的时间线。虚线表示已经被创建但是还没有被提交的配置日志条目，实线表示最后被提交的配置日志条目。领导人首先创建了 C-old,new 的配置条目在自己的日志中，并提交到 C-old,new 中（C-old 的大多数和 C-new 的大多数）。然后他创建 C-new 条目并提交到 C-new 中的大多数。这样就不存在 C-new 和 C-old 可以同时做出决定的时间点。\n在关于重新配置还有三个问题需要提出。第一个问题是，新的服务器可能初始化没有存储任何的日志条目。当这些服务器以这种状态加入到集群中，那么他们需要一段时间来更新追赶，这时还不能提交新的日志条目。为了避免这种可用性的间隔时间，Raft 在配置更新之前使用了一种额外的阶段，在这个阶段，新的服务器以没有投票权身份加入到集群中来（领导人复制日志给他们，但是不考虑他们是大多数）。一旦新的服务器追赶上了集群中的其他机器，重新配置可以像上面描述的一样处理。\n第二个问题是，集群的领导人可能不是新配置的一员。在这种情况下，领导人就会在提交了 C-new 日志之后退位（回到跟随者状态）。这意味着有这样的一段时间，领导人管理着集群，但是不包括他自己；他复制日志但是不把他自己算作是大多数之一。当 C-new 被提交时，会发生领导人过渡，因为这时是最早新的配置可以独立工作的时间点（将总是能够在 C-new 配置下选出新的领导人）。在此之前，可能只能从 C-old 中选出领导人。\n第三个问题是，移除不在 C-new 中的服务器可能会扰乱集群。这些服务器将不会再接收到心跳，所以当选举超时，他们就会进行新的选举过程。他们会发送拥有新的任期号的请求投票 RPCs，这样会导致当前的领导人回退成跟随者状态。新的领导人最终会被选出来，但是被移除的服务器将会再次超时，然后这个过程会再次重复，导致整体可用性大幅降低。\n为了避免这个问题，当服务器确认当前领导人存在时，服务器会忽略请求投票 RPCs。确切地说，当服务器在当前最小选举超时时间内收到一个请求投票 RPC，他不会更新当前的任期号或者投出选票。这不会影响正常的选举，每个服务器在开始一次选举之前，至少等待一个最小选举超时时间。然而，这有利于避免被移除的服务器扰乱：如果领导人能够发送心跳给集群，那么他就不会被更大的任期号废黜。\n7 日志压缩 Raft 的日志在正常操作中不断地增长，但是在实际的系统中，日志不能无限制地增长。随着日志不断增长，他会占用越来越多的空间，花费越来越多的时间来重置。如果没有一定的机制去清除日志里积累的陈旧的信息，那么会带来可用性问题。\n快照是最简单的压缩方法。在快照系统中，整个系统的状态都以快照的形式写入到稳定的持久化存储中，然后到那个时间点之前的日志全部丢弃。快照技术被使用在 Chubby 和 ZooKeeper 中，接下来的章节会介绍 Raft 中的快照技术。\n增量压缩的方法，例如日志清理或者日志结构合并树，都是可行的。这些方法每次只对一小部分数据进行操作，这样就分散了压缩的负载压力。首先，他们先选择一个已经积累的大量已经被删除或者被覆盖对象的区域，然后重写那个区域还活跃的对象，之后释放那个区域。和简单操作整个数据集合的快照相比，需要增加复杂的机制来实现。状态机可以实现 LSM tree 使用和快照相同的接口，但是日志清除方法就需要修改 Raft 了。\n图 12：一个服务器用新的快照替换了从 1 到 5 的条目，快照值存储了当前的状态。快照中包含了最后的索引位置和任期号。\n图 12 展示了 Raft 中快照的基础思想。每个服务器独立地创建快照，只包括已经被提交的日志。主要的工作包括将状态机的状态写入到快照中。Raft 也包含一些少量的元数据到快照中：最后被包含索引指的是被快照取代的最后的条目在日志中的索引值（状态机最后应用的日志），最后被包含的任期指的是该条目的任期号。保留这些数据是为了支持快照后紧接着的第一个条目的附加日志请求时的一致性检查，因为这个条目需要前一日志条目的索引值和任期号。为了支持集群成员更新（第 6 节），快照中也将最后的一次配置作为最后一个条目存下来。一旦服务器完成一次快照，他就可以删除最后索引位置之前的所有日志和快照了。\n尽管通常服务器都是独立地创建快照，但是领导人必须偶尔的发送快照给一些落后的跟随者。这通常发生在当领导人已经丢弃了下一条需要发送给跟随者的日志条目的时候。幸运的是这种情况不是常规操作：一个与领导人保持同步的跟随者通常都会有这个条目。然而一个运行非常缓慢的跟随者或者新加入集群的服务器（第 6 节）将不会有这个条目。这时让这个跟随者更新到最新的状态的方式就是通过网络把快照发送给他们。\n安装快照 RPC：\n由领导人调用以将快照的分块发送给跟随者。领导人总是按顺序发送分块。\n参数 解释 term 领导人的任期号 leaderId 领导人的 ID，以便于跟随者重定向请求 lastIncludedIndex 快照中包含的最后日志条目的索引值 lastIncludedTerm 快照中包含的最后日志条目的任期号 offset 分块在快照中的字节偏移量 data[] 从偏移量开始的快照分块的原始字节 done 如果这是最后一个分块则为 true 结果 解释 term 当前任期号（currentTerm），便于领导人更新自己 接收者实现：\n如果term \u0026lt; currentTerm就立即回复 如果是第一个分块（offset 为 0）就创建一个新的快照 在指定偏移量写入数据 如果 done 是 false，则继续等待更多的数据 保存快照文件，丢弃具有较小索引的任何现有或部分快照 如果现存的日志条目与快照中最后包含的日志条目具有相同的索引值和任期号，则保留其后的日志条目并进行回复 丢弃整个日志 使用快照重置状态机（并加载快照的集群配置） 图 13：一个关于安装快照的简要概述。为了便于传输，快照都是被分成分块的；每个分块都给了跟随者生命的迹象，所以跟随者可以重置选举超时计时器。\n在这种情况下领导人使用一种叫做安装快照的新的 RPC 来发送快照给太落后的跟随者；见图 13。当跟随者通过这种 RPC 接收到快照时，他必须自己决定对于已经存在的日志该如何处理。通常快照会包含没有在接收者日志中存在的信息。在这种情况下，跟随者丢弃其整个日志；它全部被快照取代，并且可能包含与快照冲突的未提交条目。如果接收到的快照是自己日志的前面部分（由于网络重传或者错误），那么被快照包含的条目将会被全部删除，但是快照后面的条目仍然有效，必须保留。\n这种快照的方式背离了 Raft 的强领导人原则，因为跟随者可以在不知道领导人情况下创建快照。但是我们认为这种背离是值得的。领导人的存在，是为了解决在达成一致性的时候的冲突，但是在创建快照的时候，一致性已经达成，这时不存在冲突了，所以没有领导人也是可以的。数据依然是从领导人传给跟随者，只是跟随者可以重新组织他们的数据了。\n我们考虑过一种替代的基于领导人的快照方案，即只有领导人创建快照，然后发送给所有的跟随者。但是这样做有两个缺点。第一，发送快照会浪费网络带宽并且延缓了快照处理的时间。每个跟随者都已经拥有了所有产生快照需要的信息，而且很显然，自己从本地的状态中创建快照比通过网络接收别人发来的要经济。第二，领导人的实现会更加复杂。例如，领导人需要发送快照的同时并行的将新的日志条目发送给跟随者，这样才不会阻塞新的客户端请求。\n还有两个问题影响了快照的性能。首先，服务器必须决定什么时候应该创建快照。如果快照创建的过于频繁，那么就会浪费大量的磁盘带宽和其他资源；如果创建快照频率太低，他就要承受耗尽存储容量的风险，同时也增加了从日志重建的时间。一个简单的策略就是当日志大小达到一个固定大小的时候就创建一次快照。如果这个阈值设置的显著大于期望的快照的大小，那么快照对磁盘压力的影响就会很小了。\n第二个影响性能的问题就是写入快照需要花费显著的一段时间，并且我们还不希望影响到正常操作。解决方案是通过写时复制的技术，这样新的更新就可以被接收而不影响到快照。例如，具有函数式数据结构的状态机天然支持这样的功能。另外，操作系统的写时复制技术的支持（如 Linux 上的 fork）可以被用来创建完整的状态机的内存快照（我们的实现就是这样的）。\n8 客户端交互 这一节将介绍客户端是如何和 Raft 进行交互的，包括客户端如何发现领导人和 Raft 是如何支持线性化语义的。这些问题对于所有基于一致性的系统都存在，并且 Raft 的解决方案和其他的也差不多。\nRaft 中的客户端发送所有请求给领导人。当客户端启动的时候，他会随机挑选一个服务器进行通信。如果客户端第一次挑选的服务器不是领导人，那么那个服务器会拒绝客户端的请求并且提供他最近接收到的领导人的信息（附加条目请求包含了领导人的网络地址）。如果领导人已经崩溃了，那么客户端的请求就会超时；客户端之后会再次重试随机挑选服务器的过程。\n我们 Raft 的目标是要实现线性化语义（每一次操作立即执行，只执行一次，在他调用和收到回复之间）。但是，如上述，Raft 是可能执行同一条命令多次的：例如，如果领导人在提交了这条日志之后，但是在响应客户端之前崩溃了，那么客户端会和新的领导人重试这条指令，导致这条命令就被再次执行了。解决方案就是客户端对于每一条指令都赋予一个唯一的序列号。然后，状态机跟踪每条指令最新的序列号和相应的响应。如果接收到一条指令，它的序列号已经被执行了，那么就立即返回结果，而不重新执行指令。\n只读的操作可以直接处理而不需要记录日志。但是，在不增加任何限制的情况下，这么做可能会冒着返回脏数据的风险，因为响应客户端请求的领导人可能在他不知道的时候已经被新的领导人取代了。线性化的读操作必须不能返回脏数据，Raft 需要使用两个额外的措施在不使用日志的情况下保证这一点。首先，领导人必须有关于被提交日志的最新信息。领导人完全特性保证了领导人一定拥有所有已经被提交的日志条目，但是在他任期开始的时候，他可能不知道哪些是已经被提交的。为了知道这些信息，他需要在他的任期里提交一条日志条目。Raft 中通过领导人在任期开始的时候提交一个空白的没有任何操作的日志条目到日志中去来实现。第二，领导人在处理只读的请求之前必须检查自己是否已经被废黜了（他自己的信息已经变脏了如果一个更新的领导人被选举出来）。Raft 中通过让领导人在响应只读请求之前，先和集群中的大多数节点交换一次心跳信息来处理这个问题。可选的，领导人可以依赖心跳机制来实现一种租约的机制，但是这种方法依赖时间来保证安全性（假设时间误差是有界的）。\n9 算法实现和评估 我们已经为 RAMCloud 实现了 Raft 算法作为存储配置信息的复制状态机的一部分，并且帮助 RAMCloud 协调故障转移。这个 Raft 实现包含大约 2000 行 C++ 代码，其中不包括测试、注释和空行。这些代码是开源的。同时也有大约 25 个其他独立的第三方的基于这篇论文草稿的开源实现，针对不同的开发场景。同时，很多公司已经部署了基于 Raft 的系统。\n这一节会从三个方面来评估 Raft 算法：可理解性、正确性和性能。\n9.1 可理解性 为了和 Paxos 比较 Raft 算法的可理解能力，我们针对高层次的本科生和研究生，在斯坦福大学的高级操作系统课程和加州大学伯克利分校的分布式计算课程上，进行了一次学习的实验。我们分别拍了针对 Raft 和 Paxos 的视频课程，并准备了相应的小测验。Raft 的视频讲课覆盖了这篇论文的所有内容除了日志压缩；Paxos 讲课包含了足够的资料来创建一个等价的复制状态机，包括单决策 Paxos，多决策 Paxos，重新配置和一些实际系统需要的性能优化（例如领导人选举）。小测验测试一些对算法的基本理解和解释一些边角的示例。每个学生都是看完第一个视频，回答相应的测试，再看第二个视频，回答相应的测试。大约有一半的学生先进行 Paxos 部分，然后另一半先进行 Raft 部分，这是为了说明两者从第一部分的算法学习中获得的表现和经验的差异。我们计算参加人员的每一个小测验的得分来看参与者是否在 Raft 算法上更加容易理解。\n我们尽可能的使得 Paxos 和 Raft 的比较更加公平。这个实验偏爱 Paxos 表现在两个方面：43 个参加者中有 15 个人在之前有一些 Paxos 的经验，并且 Paxos 的视频要长 14%。如表格 1 总结的那样，我们采取了一些措施来减轻这种潜在的偏见。我们所有的材料都可供审查。\n关心 缓和偏见采取的手段 可供查看的材料 相同的讲课质量 两者使用同一个讲师。Paxos 使用的是现在很多大学里经常使用的。Paxos 会长 14%。 视频 相同的测验难度 问题以难度分组，在两个测验里成对出现。 小测验 公平评分 使用评价量规。随机顺序打分，两个测验交替进行。 评价量规（rubric） 表 1：考虑到可能会存在的偏见，对于每种情况的解决方法，和相应的材料。\n参加者平均在 Raft 的测验中比 Paxos 高 4.9 分（总分 60，那么 Raft 的平均得分是 25.7，而 Paxos 是 20.8）；图 14 展示了每个参与者的得分。配置t-检验（又称student‘s t-test）表明，在 95% 的可信度下，真实的 Raft 分数分布至少比 Paxos 高 2.5 分。\n图 14：一个散点图表示了 43 个学生在 Paxos 和 Raft 的小测验中的成绩。在对角线之上的点表示在 Raft 获得了更高分数的学生。\n我们也建立了一个线性回归模型来预测一个新的学生的测验成绩，基于以下三个因素：他们使用的是哪个小测验，之前对 Paxos 的经验，和学习算法的顺序。模型预测，对小测验的选择会产生 12.5 分的差别。这显著的高于之前的 4.9 分，因为很多学生在之前都已经有了对于 Paxos 的经验，这相当明显的帮助 Paxos，对 Raft 就没什么太大影响了。但是奇怪的是，模型预测对于先进行 Paxos 小测验的人而言，Raft的得分低了6.3分; 虽然我们不知道为什么，这似乎在统计上是有意义的。\n我们同时也在测验之后调查了参与者，他们认为哪个算法更加容易实现和解释；这个的结果在图 15 上。压倒性的结果表明 Raft 算法更加容易实现和解释（41 人中的 33个）。但是，这种自己报告的结果不如参与者的成绩更加可信，并且参与者可能因为我们的 Raft 更加易于理解的假说而产生偏见。\n图 15：通过一个 5 分制的问题，参与者（左边）被问哪个算法他们觉得在一个高效正确的系统里更容易实现，右边被问哪个更容易向学生解释。\n关于 Raft 用户学习有一个更加详细的讨论。\n9.2 正确性 在第 5 节，我们已经制定了正式的规范，和对一致性机制的安全性证明。这个正式规范使用 TLA+ 规范语言使图 2 中总结的信息非常清晰。它长约400行，并作为证明的主题。同时对于任何想实现 Raft 的人也是十分有用的。我们通过 TLA 证明系统非常机械的证明了日志完全特性。然而，这个证明依赖的约束前提还没有被机械证明（例如，我们还没有证明规范的类型安全）。而且，我们已经写了一个非正式的证明关于状态机安全性是完备的，并且是相当清晰的（大约 3500 个词）。\n9.3 性能 Raft 和其他一致性算法例如 Paxos 有着差不多的性能。在性能方面，最重要的关注点是，当领导人被选举成功时，什么时候复制新的日志条目。Raft 通过很少数量的消息包（一轮从领导人到集群大多数机器的消息）就达成了这个目的。同时，进一步提升 Raft 的性能也是可行的。例如，很容易通过支持批量操作和管道操作来提高吞吐量和降低延迟。对于其他一致性算法已经提出过很多性能优化方案；其中有很多也可以应用到 Raft 中来，但是我们暂时把这个问题放到未来的工作中去。\n我们使用我们自己的 Raft 实现来衡量 Raft 领导人选举的性能并且回答两个问题。首先，领导人选举的过程收敛是否快速？第二，在领导人宕机之后，最小的系统宕机时间是多久？\n图 16：发现并替换一个已经崩溃的领导人的时间。上面的图考察了在选举超时时间上的随机化程度，下面的图考察了最小选举超时时间。每条线代表了 1000 次实验（除了 150-150 毫秒只试了 100 次），和相应的确定的选举超时时间。例如，150-155 毫秒意思是，选举超时时间从这个区间范围内随机选择并确定下来。这个实验在一个拥有 5 个节点的集群上进行，其广播时延大约是 15 毫秒。对于 9 个节点的集群，结果也差不多。\n为了衡量领导人选举，我们反复的使一个拥有五个节点的服务器集群的领导人宕机，并计算需要多久才能发现领导人已经宕机并选出一个新的领导人（见图 16）。为了构建一个最坏的场景，在每一的尝试里，服务器都有不同长度的日志，意味着有些候选人是没有成为领导人的资格的。另外，为了促成选票瓜分的情况，我们的测试脚本在终止领导人之前同步的发送了一次心跳广播（这大约和领导人在崩溃前复制一个新的日志给其他机器很像）。领导人均匀的随机的在心跳间隔里宕机，也就是最小选举超时时间的一半。因此，最小宕机时间大约就是最小选举超时时间的一半。\n图 16 中上面的图表明，只需要在选举超时时间上使用很少的随机化就可以大大避免选票被瓜分的情况。在没有随机化的情况下，在我们的测试里，选举过程往往都需要花费超过 10 秒钟由于太多的选票瓜分的情况。仅仅增加 5 毫秒的随机化时间，就大大的改善了选举过程，现在平均的宕机时间只有 287 毫秒。增加更多的随机化时间可以大大改善最坏情况：通过增加 50 毫秒的随机化时间，最坏的完成情况（1000 次尝试）只要 513 毫秒。\n图 16 中下面的图显示，通过减少选举超时时间可以减少系统的宕机时间。在选举超时时间为 12-24 毫秒的情况下，只需要平均 35 毫秒就可以选举出新的领导人（最长的一次花费了 152 毫秒）。然而，进一步降低选举超时时间的话就会违反 Raft 的时间不等式需求：在选举新领导人之前，领导人就很难发送完心跳包。这会导致没有意义的领导人改变并降低了系统整体的可用性。我们建议使用更为保守的选举超时时间，比如 150-300 毫秒；这样的时间不大可能导致没有意义的领导人改变，而且依然提供不错的可用性。\n10 相关工作 已经有很多关于一致性算法的工作被发表出来，其中很多都可以归到下面的类别中：\nLamport 关于 Paxos 的原始描述，和尝试描述的更清晰。 关于 Paxos 的更详尽的描述，补充遗漏的细节并修改算法，使得可以提供更加容易的实现基础。 实现一致性算法的系统，例如 Chubby，ZooKeeper 和 Spanner。对于 Chubby 和 Spanner 的算法并没有公开发表其技术细节，尽管他们都声称是基于 Paxos 的。ZooKeeper 的算法细节已经发表，但是和 Paxos 着实有着很大的差别。 Paxos 可以应用的性能优化。 Oki 和 Liskov 的 Viewstamped Replication（VR），一种和 Paxos 差不多的替代算法。原始的算法描述和分布式传输协议耦合在了一起，但是核心的一致性算法在最近的更新里被分离了出来。VR 使用了一种基于领导人的方法，和 Raft 有很多相似之处。 Raft 和 Paxos 最大的不同之处就在于 Raft 的强领导特性：Raft 使用领导人选举作为一致性协议里必不可少的部分，并且将尽可能多的功能集中到了领导人身上。这样就可以使得算法更加容易理解。例如，在 Paxos 中，领导人选举和基本的一致性协议是正交的：领导人选举仅仅是性能优化的手段，而且不是一致性所必须要求的。但是，这样就增加了多余的机制：Paxos 同时包含了针对基本一致性要求的两阶段提交协议和针对领导人选举的独立的机制。相比较而言，Raft 就直接将领导人选举纳入到一致性算法中，并作为两阶段一致性的第一步。这样就减少了很多机制。\n像 Raft 一样，VR 和 ZooKeeper 也是基于领导人的，因此他们也拥有一些 Raft 的优点。但是，Raft 比 VR 和 ZooKeeper 拥有更少的机制因为 Raft 尽可能的减少了非领导人的功能。例如，Raft 中日志条目都遵循着从领导人发送给其他人这一个方向：附加条目 RPC 是向外发送的。在 VR 中，日志条目的流动是双向的（领导人可以在选举过程中接收日志）；这就导致了额外的机制和复杂性。根据 ZooKeeper 公开的资料看，它的日志条目也是双向传输的，但是它的实现更像 Raft。\n和上述我们提及的其他基于一致性的日志复制算法中，Raft 的消息类型更少。例如，我们数了一下 VR 和 ZooKeeper 使用的用来基本一致性需要和成员改变的消息数（排除了日志压缩和客户端交互，因为这些都比较独立且和算法关系不大）。VR 和 ZooKeeper 都分别定义了 10 种不同的消息类型，相对的，Raft 只有 4 种消息类型（两种 RPC 请求和对应的响应）。Raft 的消息都稍微比其他算法的要信息量大，但是都很简单。另外，VR 和 ZooKeeper 都在领导人改变时传输了整个日志；所以为了能够实践中使用，额外的消息类型就很必要了。\nRaft 的强领导人模型简化了整个算法，但是同时也排斥了一些性能优化的方法。例如，平等主义 Paxos （EPaxos）在某些没有领导人的情况下可以达到很高的性能。平等主义 Paxos 充分发挥了在状态机指令中的交换性。任何服务器都可以在一轮通信下就提交指令，除非其他指令同时被提出了。然而，如果指令都是并发的被提出，并且互相之间不通信沟通，那么 EPaxos 就需要额外的一轮通信。因为任何服务器都可以提交指令，所以 EPaxos 在服务器之间的负载均衡做的很好，并且很容易在 WAN 网络环境下获得很低的延迟。但是，他在 Paxos 上增加了非常明显的复杂性。\n一些集群成员变换的方法已经被提出或者在其他的工作中被实现，包括 Lamport 的原始的讨论，VR 和 SMART。我们选择使用共同一致的方法因为他对一致性协议的其他部分影响很小，这样我们只需要很少的一些机制就可以实现成员变换。Lamport 的基于 α 的方法之所以没有被 Raft 选择是因为它假设在没有领导人的情况下也可以达到一致性。和 VR 和 SMART 相比较，Raft 的重新配置算法可以在不限制正常请求处理的情况下进行；相比较的，VR 需要停止所有的处理过程，SMART 引入了一个和 α 类似的方法，限制了请求处理的数量。Raft 的方法同时也需要更少的额外机制来实现，和 VR、SMART 比较而言。\n11 结论 算法的设计通常会把正确性，效率或者简洁作为主要的目标。尽管这些都是很有意义的目标，但是我们相信，可理解性也是一样的重要。在开发者把算法应用到实际的系统中之前，这些目标没有一个会被实现，这些都会必然的偏离发表时的形式。除非开发人员对这个算法有着很深的理解并且有着直观的感觉，否则将会对他们而言很难在实现的时候保持原有期望的特性。\n在这篇论文中，我们尝试解决分布式一致性问题，但是一个广为接受但是十分令人费解的算法 Paxos 已经困扰了无数学生和开发者很多年了。我们创造了一种新的算法 Raft，显而易见的比 Paxos 要容易理解。我们同时也相信，Raft 也可以为实际的实现提供坚实的基础。把可理解性作为设计的目标改变了我们设计 Raft 的方式；随着设计的进展，我们发现自己重复使用了一些技术，比如分解问题和简化状态空间。这些技术不仅提升了 Raft 的可理解性，同时也使我们坚信其正确性。\n12 raft协议的动画演示 raft协议动画演示\n13 raft常见面试问题汇总","date":"2025-01-15T15:22:33+08:00","permalink":"http://localhost:1313/post/storage_system/raft/","tags":[""],"title":"Raft协议"},{"categories":["Tools"],"contents":"本文介绍网络相关的工具的使用方法\n1 使用ncat模拟服务 使用前提：需要在UNIX系统中已经安装ncat软件而且shell可以正常使用。\n1.1 The discard service 1 2 3 4 5 # TCP discard server ncat -l --keep-open 9 --recv-only \u0026gt; /dev/null # UDP discard server ncat --udp -l --keep-open 9 --recv-only \u0026gt; /dev/null 1.2 echo service The echo service is defined in RFC 862. It runs on TCP or UDP port 7. One step more advanced than discard, it sends back any data received until the connection is closed. How do you instruct Ncat to return what it receives? One easy way is to run everything through /bin/cat.\n1 2 3 4 5 # TCP echo server ncat -l 7 --keep-open --exec \u0026#34;/bin/cat\u0026#34; # UDP echo server ncat -l 7 --keep-open --udp --exec \u0026#34;/bin/cat\u0026#34; 1.3 daytime service The daytime service, defined in RFC 867, sends a human-readable date and time string over TCP or UDP port 13. It ignores any input. The format of the date and time string is left unspecified, so we are free to use the output of /bin/date. Because we are not interested in anything sent by the client we use the \u0026ndash;send-only option.\n1 2 3 4 5 # TCP daytime server ncat -l 13 --keep-open --send-only --exec \u0026#34;/bin/date\u0026#34; # UDP daytime server ncat -l 13 --keep-open --udp --send-only --exec \u0026#34;/bin/date\u0026#34; 1.4 qotd server The qotd (quote of the day) service is defined in RFC 865. When a connection is made to TCP or UDP port 17, it sends back a short message, ignoring any input. Ncat can do this by invoking a program that generates messages. A traditional choice is /usr/games/fortune, though there are many possibilities. /usr/bin/uptime, for example, could be useful.\n1 2 3 4 TCP qotd server ncat -l 17 --keep-open --send-only --exec \u0026#34;/usr/games/fortune\u0026#34; UDP qotd server do ncat -l 17 --keep-open --udp --send-only --exec \u0026#34;/usr/games/fortune\u0026#34; 1.5 chargen service The chargen service from RFC 864 rounds out our tour of diagnostic services. It runs on TCP and UDP port 19. With TCP, chargen ignores any input and sends a never-ending stream of data. Never-ending, that is, until the connection is closed by the user, who the RFC suggests may have “had enough”. There are many ways of generating the characters; reading from /dev/zero and running yes come to mind.\n1 2 3 4 5 6 # TCP chargen server yes \u0026#34;chargenchargenchargen\u0026#34; | ncat -l --keep-open 19 --send-only # UDP chargen server ncat -l 19 --keep-open --udp --send-only --sh-exec \\ \u0026#34;yes chargenchargenchargen | dd count=1 bs=$(($RANDOM % 512)) 2\u0026gt; /dev/null\u0026#34; 参考文献： ncat emulating Diagnostic Services\n2 tcpdump软件的用法 tcpdump抓取的数据是以太网帧，通过该命令的参数控制帧的过滤和显示。\n2.1 常用参数功能介绍 1 2 3 4 5 6 7 8 # -i 指定监控网卡 # -e Print the link-level header on each dump line. # -n Don’t convert host addresses to names. # -t Don’t print a timestamp on each dump line. # -s 每个数据的最大显示长度 # -v 打印IP数据报头部信息中关键字段的值（例如tos,ttl,offset,传输层协议，长度等信息）。 # -x 将数据按照十六进制显示 # -X 将数据按照十六进制显示，并显示对应的ASCII。 2.2 tcpdump软件使用实例 2.2.1 指定源IP地址和目的IP地址抓包 1 tcpdump -i eth0 -ent \u0026#39;(dst 192.168.56.6 and src 192.168.56.8) or (dst 192.168.56.8 and src 192.168.56.6)\u0026#39; 2.2.2 指定服务抓包 port domain说明只抓取使用domain域名服务的数据包，即DNS查询和应答报文。\n1 tcpdump -i eth0 -nt -s 500 port domain 2.2.3 指定网卡抓包 1 2 # 抓取本地回路上的数据包 tcpdump -ntx -i lo 2.2.4 指定协议抓包 1 2 # 只抓取icmp报文 tcpdump -i eth0 -ntv icmp 2.2.5 指定端口抓包 1 2 # 只抓发送至或者来自54321端口的TCP报文段 tcpdump -i eth0 -n port 54321 3 ping命名的用法 3.1 ping命令常用参数说明 1 2 -i interval # Wait interval seconds between sending each packet. -s packetsize # Specifies the number of data bytes to be sent. 4 ifconfig命令的用法 1 2 3 -a # display all interfaces which are currently available, even if down up # This flag causes the interface to be activated down # This flag causes the driver for this interface to be shut down. 4.1 ifconfig查询结果中的字段含义 enp0s8: flags=4163\u0026lt;UP,BROADCAST,RUNNING,MULTICAST\u0026gt; mtu 1500\ninet 192.168.56.8 netmask 255.255.255.0 broadcast 192.168.56.255\ninet6 fe80::a00:27ff:fe8b:9089 prefixlen 64 scopeid 0x20\nenp0s8: 表示网卡的名称 UP：表示当前网卡处于UP状态 mtu 1500: 表示当前网卡的以太网帧的长度为1500字节(Byte) inet：为该网卡的IPv4地址，netmask为子网掩码 inet6: 表示该网卡的IPv6地址 4.2 ifconfig示例 1 2 3 4 5 # 显示当前设备上所有网卡信息，包含down的网卡 ifconfig -a # 查询指定网卡的信息 ifconfig eth0 5 route命令的用法 5.1 route常用参数说明 1 2 3 4 5 6 -C # operate on the kernel’s routing cache. -n # show numerical addresses instead of trying to determine symbolic host names -v # select verbose operation del # delete a route. add # add a new route. dev If # force the route to be associated with the specified device 5.2 route使用示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 # deletes the current default route, which is labeled \u0026#34;default\u0026#34; # or 0.0.0.0 in the destination field of the current routing table. route del default # deletes the route. Since the Linux routing kernel uses classless addressing, # you pretty much always have to specify the netmask that is same as as seen in \u0026#39;route -n\u0026#39; listing. route del -net 192.56.76.0 netmask 255.255.255.0 # adds a default route (which will be used if no other route matches). # All packets using this route will be gatewayed through the address of a node named \u0026#34;mango\u0026#34;. # The device which will actually be used for that route depends on how we can reach \u0026#34;mango\u0026#34; - # \u0026#34;mango\u0026#34; must be on directly reachable route. route add default gw mango # Adds the route to the host named \u0026#34;mango\u0026#34; via # the SLIP interface (assuming that \u0026#34;mango\u0026#34; is the SLIP host). route add mango sl0 # 查看路由表缓冲区 # # route -Cn # Kernel IP routing cache # Source Destination Gateway Flags Metric Ref Use Iface # 192.168.56.2 192.168.56.1 192.168.56.1 0 1 0 eth1 # 192.168.56.1 192.168.56.2 192.168.56.2 il 0 0 26 lo route -Cn 6 netstat命令的用法 1 2 3 4 5 6 7 8 9 10 11 -a, --all # Show both listening and non-listening (for TCP this means established connections) sockets. With the --interfaces option, show interfaces that are not marked -l, --listening # Show only listening sockets. (These are omitted by default.) -p, --program # Show the PID and name of the program to which each socket belongs. -n, --numeric # Show numerical addresses instead of trying to determine symbolic host, port or user names. -t|--tcp # filter tcp -u|--udp # filter udp -C # Print routing information from the route cache. -F # Print routing information from the FIB. (This is the default.) --route , -r # Display the kernel routing tables. ","date":"2025-01-09T16:26:52+08:00","permalink":"http://localhost:1313/post/tools/network_tools/","tags":[""],"title":"Linux网络相关工具的使用方法"},{"categories":[""],"contents":"本文对Nginx源码功能进行简要介绍。\n1 Nginx源码功能结构\n1 2 3 4 5 6 7 src |__ core/ |__ event/ |__ http/ |__ mail/ |__ os/ |__ stream/ 1.1 core： 基础功能 其中core目录中提供一些基础功能：\nngx_log: 打印日志 ngx_thread_pool： 线程池功能 ngx_rbtree： 红黑树功能 ngx_radix_tree： radix tree功能 ngx_string： 字符串处理 1.2 event：事件处理 ngx_event_timer：定时器功能 1.3 http: http服务 1.4 mail：邮件服务 1.5 os相关 1.6 stream","date":"2025-01-03T13:21:21+08:00","permalink":"http://localhost:1313/post/linux/nginx/nginx_introduction/","tags":[""],"title":"Nginx源码功能简介"},{"categories":["CPP"],"contents":"本文介绍C++ 11及后续版本中的新特性\n1 C++ 11新增关键字(部分) 1.1 constexpr constexpr 和const的功能类似，只值 constexpr 类型在编译时会进行变量类型检查，检查变量的值是否为常量表达式。\n声明为 constexpr的变量一定是常量，而且必须使用常量表达式初始化\n1.2 decltype decltype的作用是获取并返回操作数的类型。\n针对的场景：希望从表达式的类型推导出要定义的变量的类型，但是不想用该表达式初始化变量。例如：\n1 2 const int ci = 0; decltype(ci) x = 1; // x的类型为const int 1.3 =default = default是用于限定构造函数的，要求编译器生成构造函数。它可以出现在类内部，也可以作为定义出现在类外部。 若在类内部，则默认构造函数是内联的，如果在内外部，则该构造函数默认不是内联的。\n1.4 =delete 用于修饰函数，将函数定义为已删除。所有尝试调用已删除函数的代码，都会在编译阶段报错。\n1.5 noexcept 用于指定函数不抛出异常。\n1.6 nullptr nullptr是一个指针常量，表示空指针。\n1.7 explicit 1.7.1 修饰构造函数 explicit用于修饰构造函数是，用于阻止构造函数进行隐式转换。\nexplicit只对拥有一个参数的构造函数有效。 explicit只能在类内部声明构造函数时使用，而且在类外定义该构造函数时不能重复使用该关键字。 explicit声明构造函数时，该构造函数只能安札直接初始化的形式使用。\n1.8 override override关键字用在派生类的函数中，用于明确覆盖基类中的同名函数。\n若要在派生类的函数中使用override关键字，需要基类中有同名函数而且该函数为虚函数(virtual修饰)。【只有虚函数才能被覆盖】。 final和override说明符出现在形参列表(包括任何const或引用修饰符)以及尾置返回类型之后。\n1.9 final final的作用是阻止派生类覆盖该函数。 当函数使用final修饰后，任何尝试覆盖该函数的操作都会报错。\n1.10 auto 1.11 using using可以用来声明类型别名和模板声明别名。\n示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // type alias, identical to // typedef std::ios_base::fmtflags flags; using flags = std::ios_base::fmtflags; // the name \u0026#39;flags\u0026#39; now denotes a type: flags fl = std::ios_base::dec; // type alias, identical to // typedef void (*func)(int, int); using func = void (*) (int, int); // the name \u0026#39;func\u0026#39; now denotes a pointer to function: void example(int, int) {} func f = example; // type alias used to hide a template parameter template\u0026lt;class CharT\u0026gt; using mystring = std::basic_string\u0026lt;CharT, std::char_traits\u0026lt;CharT\u0026gt;\u0026gt;; mystring\u0026lt;char\u0026gt; str; 2 Lambda表达式 2.1 Lambda表达式的几种模式 1 2 3 4 //[ capture-list ] ( params ) mutable(optional) constexpr(optional)(c++17) exception attribute -\u0026gt; ret { body } (1) //[ capture-list ] ( params ) -\u0026gt; ret { body } (2) //[ capture-list ] ( params ) { body } (3) //[ capture-list ] { body } (4) capture-list - a comma-separated list of zero or more captures, optionally beginning with a capture-default. Capture list can be passed as follows (see below for the detailed description):\n[a,\u0026amp;b] where a is captured by copy and b is captured by reference.\n[this] captures the current object (*this) by reference\n[\u0026amp;] captures all automatic variables used in the body of the lambda by reference and current object by reference if exists\n[=] captures all automatic variables used in the body of the lambda by copy and current object by reference if exists [] captures nothing\nparams - The list of parameters, as in named functions, except that default arguments are not allowed (until C++14). If auto is used as a type of a parameter, the lambda is a generic lambda. (since C++14)\nret - Return type. If not present it\u0026rsquo;s implied by the function return statements (or void if it doesn\u0026rsquo;t return any value)\nbody - Function body\n2.2 Lambda表达式的示例程序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include \u0026lt;vector\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;functional\u0026gt; int main() { std::vector\u0026lt;int\u0026gt; c = {1, 2, 3, 4, 5, 6, 7}; int x = 5; c.erase(std::remove_if(c.begin(), c.end(), [x](int n) { return n \u0026lt; x; }), c.end()); std::cout \u0026lt;\u0026lt; \u0026#34;c: \u0026#34;; std::for_each(c.begin(), c.end(), [](int i){ std::cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39; \u0026#39;; }); std::cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // the type of a closure cannot be named, but can be inferred with auto auto func1 = [](int i) { return i + 4; }; std::cout \u0026lt;\u0026lt; \u0026#34;func1: \u0026#34; \u0026lt;\u0026lt; func1(6) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // like all callable objects, closures can be captured in std::function // (this may incur unnecessary overhead) std::function\u0026lt;int(int)\u0026gt; func2 = [](int i) { return i + 4; }; std::cout \u0026lt;\u0026lt; \u0026#34;func2: \u0026#34; \u0026lt;\u0026lt; func2(6) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } 程序执行结果：\nc: 5 6 7\nfunc1: 10\nfunc2: 10\n","date":"2025-01-02T21:06:18+08:00","permalink":"http://localhost:1313/post/cpp/cpp_new_features/","tags":[""],"title":"C++新特性(C++11及后续版本)"},{"categories":["Linux"],"contents":"线程介绍相关功能的使用方法。\nlinux获取线程id的方法 通过gettid()获取 1 2 3 4 5 6 #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;syscall.h\u0026gt; inline pid_t gettid(void) { return (pid_t)syscall(__NR_gettid); } 通过pthread_self()获取 1 2 3 4 5 void* func(void *ptr) { printf(\u0026#34;The id of %s is %u\\n\u0026#34;,(char*)ptr,(unsigned int)pthread_self()); return (void*)0; } 两种获取tid方法的差异：\npthread_self()是glibc提供的接口，是由线程库实现的。\ngettid()获取的tid是内核分配的，通过该方法获取到的tid和pid类似。可以通过命令ps -Tp PID获取当前进程中的线程。\n","date":"2025-01-02T10:42:37+08:00","permalink":"http://localhost:1313/post/linux/apue/threads/","tags":["线程"],"title":"线程"},{"categories":["操作系统"],"contents":"本文介绍树莓派硬件的一些初始化配置。\n1 安装系统 1.1 下载RaspberryPi OS 在树莓派官网下载树莓派操作系统(OS)。\n树莓派系统下载地址：https://www.raspberrypi.com/software/operating-systems/\n我选择的系统是：Raspberry Pi OS Lite(64)\n对linux系统不太熟悉的可以选择desktop版本。\n1.2 安装操作系统 找一个可用空间大于8GB的micro SD卡,将卡插入读卡器并将读卡器连接至windows系统； 将步骤1.1安装的系统解压到非中文路径下备用。 使用rufus工具，将解压得到的img文件烧到准备好的SD卡中。 待烧写系统完成，操作系统就安装好了。 将安装好操作系统的SD卡插入树莓派的SD插槽中。 将树莓派的电源线连接好，接通电源，系统将自动启动。 2 系统配置 2.1 键盘布局设置 执行命令：sudo raspi-config打开系统配置界面。\n然后按照步骤【Localisation Options】-\u0026gt; 【L3 keybord】的步骤设置键盘布局。选择【Generic 104-key pc】-\u0026gt; 【English(US)】\n2.2 连接WIFI 执行命令：sudo raspi-config打开系统配置界面。\n然后按照步骤【System Options】-\u0026gt; 【S1 Wireless LAN】的步骤设置无线网络。\n2.3 启用ssh功能 启用ssh功能后，就可以在局域网连接到树莓派系统。\n执行命令：sudo raspi-config打开系统配置界面。 然后按照步骤【Interface Options】-\u0026gt; 【I1 SSH】的步骤设置ssh启动开关。\n3 安装Nginx 安装Nginx参考文档： Debian安装Nginx的方法\n4 安装samba 安装samba: sudo apt install samba 创建访问samba共享目录的用户： 1 2 sudo useradd smb # 添加smb用户 sudo passwd smb # 为账户smb设置密码 创建共享目录： mkdir /home/sambashare/ 修改共享目录权限和所有者： 1 2 sudo chmod -R 755 /home/sambashare/ # 设置smb目录的权限 sudo chown -R smb:smb /home/sambashare/ # 设置smb目录的所属用户和组为smb 设置smb用户访问samba的密码：sudo smbpasswd -a smb\n编辑samba配置文件：sudo vim /etc/samba/smb.conf\n1 2 3 4 5 6 7 8 9 [sambaShare] comment = Samba on RespberryPi path = /opt/share/ browsable = yes read only = no guest ok = no write list = smb allow hosts = 192.168.101.103 deny hosts = 192.168.101.0/24 重启samba服务： sudo service smbd restart 设置防火墙：sudo ufw allow samba ","date":"2024-12-28T17:49:22+08:00","permalink":"http://localhost:1313/post/operating_system/raspberrypi/raspberrypi_getting_started/","tags":["RaspberryPi"],"title":"树莓派系统的初始化"},{"categories":["CPP"],"contents":"本文总结C++算法库中有关排序相关的库函数的常见用法。\n1 std::sort 1.1 使用默认排序函数 默认排序函数得到的排序结果是升序结果。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 std::array\u0026lt;int, 10\u0026gt; s = {5, 7, 4, 2, 8, 6, 1, 9, 0, 3}; // sort using the default operator\u0026lt; // 0 1 2 3 4 5 6 7 8 9 std::sort(s.begin(), s.end()); for (auto a : s) { std::cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } std::cout \u0026lt;\u0026lt; std::endl; // sort using a standard library compare function object // 9 8 7 6 5 4 3 2 1 0 std::sort(s.begin(), s.end(), std::greater\u0026lt;int\u0026gt;()); for (auto a : s) { std::cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } std::cout \u0026lt;\u0026lt; std::endl; 1.2 使用自定义排序函数 1 2 3 4 5 6 7 8 9 10 11 12 13 // sort using a custom function bool comp(const vector\u0026lt;int\u0026gt;\u0026amp; a, const vector\u0026lt;int\u0026gt;\u0026amp; b) { return *a.cbegin() \u0026lt; *b.cbegin(); } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; vec = {{5,6}, {2, 7}, {6, 9}, {15, 19}}; sort(vec.begin(), vec.end(), comp); for (auto item : vec) { for (auto iter : item) { printf(\u0026#34;%d \u0026#34;, iter); } printf(\u0026#34;\\n\u0026#34;); } ","date":"2024-12-27T11:23:42+08:00","permalink":"http://localhost:1313/post/cpp/algorithms_library/sorting_operations/","tags":["C++算法库"],"title":"C++算法库-排序算法"},{"categories":["汇编语言"],"contents":"Introduce the Intel and AT\u0026amp;T Syntax about assembly language\nIntel and AT\u0026amp;T Syntax Intel and AT\u0026amp;T syntax Assembly language are very different from each other in appearance,\nand this will lead to confusion when one first comes across AT\u0026amp;T syntax after having learnt Intel syntax first, or vice versa.\nSo lets start with the basics. Linux use AT\u0026amp;T syntax default.\n1.1 Direction of Operands The direction of the operands in Intel syntax is opposite from that of AT\u0026amp;T syntax.\nIn Intel syntax the first operand is the destination, and the second operand is the source whereas in AT\u0026amp;T syntax the first operand is the source and the second operand is the destination.\nThe advantage of AT\u0026amp;T syntax in this situation is obvious.\nWe read from left to right, we write from left to right, so this way is only natural.\nExample:\nIntel Syntax AT\u0026amp;T Syntax instr dest,source instr source,dest mov eax,[ecx] movl (%ecx),%eax 1.2 Prefixes In Intel syntax there are no register prefixes or immed prefixes.\nIn AT\u0026amp;T however registers are prefixed with a \u0026lsquo;%\u0026rsquo; and immed\u0026rsquo;s are prefixed with a \u0026lsquo;$\u0026rsquo;.\nIntel syntax hexadecimal or binary immed data are suffixed with \u0026lsquo;h\u0026rsquo; and \u0026lsquo;b\u0026rsquo; respectively.\nAlso if the first hexadecimal digit is a letter then the value is prefixed by a \u0026lsquo;0\u0026rsquo;.\nExample:\nIntel Syntax AT\u0026amp;T Syntax mov eax, 1 movl $1, %eax mov ebx, 0ffh movl $0xff, %ebx int 80h int $0x80 1.3 Memory Operands Memory operands as seen above are different also. In Intel syntax the base register is enclosed in \u0026lsquo;[\u0026rsquo; and \u0026lsquo;]\u0026rsquo; whereas in AT\u0026amp;T syntax it is enclosed in \u0026lsquo;(\u0026rsquo; and \u0026lsquo;)\u0026rsquo;.\nExample:\nIntel Syntax AT\u0026amp;T Syntax mov eax, [ebx] movl (%ebx), %eax mov eax, [ebx+3] movl 3(%ebx), %eax The AT\u0026amp;T form for instructions involving complex operations is very obscure compared to Intel syntax. The Intel syntax form of these is segreg:[base+index*scale+disp]. The AT\u0026amp;T syntax form is %segreg: disp(base,index,scale).\nIndex/scale/disp/segreg are all optional and can simply be left out. Scale, if not specified and index is specified, defaults to 1. Segreg depends on the instruction and whether the app is being run in real mode or pmode. In real mode it depends on the instruction whereas in pmode its unnecessary. Immediate data used should not \u0026lsquo;$\u0026rsquo; prefixed in AT\u0026amp;T when used for scale/disp.\nExample:\nIntel Syntax AT\u0026amp;T Syntax instr foo,segreg:[base+index*scale+disp] instr %segreg:disp(base,index,scale), foo mov eax, [ebx+20h] movl 0x20(%ebx), %eax add eax, [ebx+ecx*2h] addl (%ebx,%ecx,0x2), %eax lea eax, [ebx+ecx] leal (%ebx,%ecx), %eax sub eax, [ebx+ecx*4h-20h] subl -0x20(%ebx,%ecx,0x4), %eax As you can see, AT\u0026amp;T is very obscure. [base+index*scale+disp] makes more sense at a glance than disp(base,index,scale).\n1.4 Suffixes As you may have noticed, the AT\u0026amp;T syntax mnemonics have a suffix. The significance of this suffix is that of operand size. \u0026rsquo;l\u0026rsquo; is for long, \u0026lsquo;w\u0026rsquo; is for word, and \u0026lsquo;b\u0026rsquo; is for byte. Intel syntax has similar directives for use with memory operands, i.e. byte ptr, word ptr, dword ptr. \u0026ldquo;dword\u0026rdquo; of course corresponding to \u0026ldquo;long\u0026rdquo;. This is similar to type casting in C but it doesnt seem to be necessary since the size of registers used is the assumed datatype.\nExample:\nIntel Syntax AT\u0026amp;T Syntax mov al,bl movb %bl,%al mov ax,bx movw %bx,%ax mov eax,ebx movl %ebx,%eax mov eax, dword ptr [ebx] movl (%ebx),%eax ","date":"2024-12-23T20:41:51+08:00","permalink":"http://localhost:1313/post/assembly/inter_gun_syntax_difference/","tags":[""],"title":"Intel和AT\u0026T汇编语言语法的差异"},{"categories":[""],"contents":"该页面为汇编语言使用的导航页。\n汇编语言 Intel和AT\u0026amp;T汇编语言语法的差异\n内联汇编\n","date":"2024-12-23T18:25:40+08:00","permalink":"http://localhost:1313/index/content_assembly/","tags":[""],"title":"汇编语言导航页"},{"categories":["数据结构"],"contents":"本文介绍B-Tree的特性，以及代码实现。\n","date":"2024-12-17T20:01:46+08:00","permalink":"http://localhost:1313/post/data_structure/tree/b_tree/","tags":["B-Tree"],"title":"B_tree"},{"categories":[""],"contents":"该页面为存储系统的导航页。\n存储系统导航页 存储系统的基本概念\n一致性哈希原理\nraft协议原理介绍\n[Ceph功能简介] [LevelDB原理介绍] [RocksDB原理介绍]\n","date":"2024-12-17T18:25:40+08:00","permalink":"http://localhost:1313/index/content_storage/","tags":[""],"title":"存储系统导航页"},{"categories":[""],"contents":"","date":"2024-12-17T17:51:06+08:00","permalink":"http://localhost:1313/post/storage_system/leveldb/","tags":[""],"title":"LevelDB"},{"categories":[""],"contents":"","date":"2024-12-17T17:50:40+08:00","permalink":"http://localhost:1313/post/storage_system/rocksdb/","tags":[""],"title":"RocksDB"},{"categories":["存储系统"],"contents":"本文介绍Ceph系统的基本组成部分以及一些基本概念。\n","date":"2024-12-17T17:50:30+08:00","permalink":"http://localhost:1313/post/storage_system/ceph/","tags":["Ceph"],"title":"Ceph"},{"categories":["storage"],"contents":"本文介绍存储基础知识。\n1 存储的基本概念 副本 EC 重构 扩容 缩容 2 一致性哈希算法","date":"2024-12-17T17:49:33+08:00","permalink":"http://localhost:1313/post/storage_system/storage_basic_knowledge/","tags":[""],"title":"存储系统的基本概念"},{"categories":["CPP"],"contents":"本文总结C++中的部分关键字的用法。\n1 C++中的部分关键字的用法 1.1 const的用法 1.1.1 定义常量 使用const修饰的变量的值不可改变。\n1 const double PI = 3.1415; 1.1.2 const与指针 指向常量的指针(point to const)\n定义方法： const int *p; int const *p;\n指向常量的指针的特点：const在*前面，不论它在类型前还是类型后作用相同。\n指向常量的指针的特点： 不能通过指针改变所指向的数据 指针本身的内容可以改变 指针指向的内容可以是常量也可以不是常量 指针所指向的内容若为非常量，也可以改变 示例如下：\n1 2 3 4 5 6 7 int a = 100; int b = 50; const int *point1 = \u0026amp;a; //定义指针常量 //*point1 = 50; //非法操作，不能通过指针变量来改变所指向的数据 a = 50; //改变指针常量所指内容的值 point1 = \u0026amp;b; //改变指针常量的值 常量指针(const pointer)\n定义方法： int *const p;\n常量指针就是该指针为常量。因为该指针为一个常量，因此指针的值不能改变。 常量指针的特点： 常量指针必须初始化 一旦初始化后，指针的内容就不能改变 指针所指向的内容可以改变 示例如下：\n1 2 3 4 5 6 int a = 100; int b = 50; int *const point2 = \u0026amp;b; // 定义常量指针 //point2 = \u0026amp;a; //非法操作，不能更改常量指针的值 b = 100; // 可以改变常量指针所指内容的值 指向常量的常指针\n定义方法： const int *const p;\n指向常量的常指针为前面两种情况的综合。因此既不能通过指针变量来改变所指向的数据，也不能更改指针本身的值。 指向常量的常指针： 指针本身的内容不能改变 不能通过指针改变指针所指向的内容 若指针指向的内容为非常量，则指针指向的内容可以改变 示例：\n1 2 3 4 5 6 int a = 100; int b = 50; int c = 80; const int *const point3 = \u0026amp;c; //定义指向常量的常量指针 *point3 = a; //非法操作，不能通过指针变量来改变所指向的数据 point3 = \u0026amp;b; //非法操作，不能更改常量指针的值 1.1.3 函数形参 const修饰函数形参，函数中不能修改const形参对应的实参。例如：\n1 void func(const vector\u0026lt;int\u0026gt;\u0026amp; vec); 1.1.4 const修饰函数返回值 1.1.5 类相关的const 常量成员变量：常成员变量只能通过列表初始化的方式初始化。此后，其值不可改变。 const修饰成员函数：const修饰的成员函数不能修改类中成员变量的值；不能调用非const修饰的成员函数。 const修饰对象，对象指针(引用)：const修饰的对象只能调用cosnt修饰的成员函数。 1.2 static的用法 1.2.1 静态全局变量 该变量在全局数据区分配内存; 未经初始化的静态全局变量会被程序自动初始化为0; 静态全局变量在声明它的整个文件都是可见的，而在文件之外是不可见的; 1.2.2 静态局部变量 该变量在全局数据区分配内存； 静态局部变量在程序执行到该对象的声明处时,首次进行初始化;以后的函数调用不再进行初始化； 静态局部变量一般在声明处初始化，如果没有显式初始化会被程序自动初始化为0； 它始终驻留在全局数据区，直到程序运行结束。但其作用域为局部作用域，当定义它的函数或语句块结束时，其作用域随之结束； 1.2.3 静态函数 静态函数不能被其它文件所用；其它文件中可以定义相同名字的函数，不会发生冲突\n1.2.4 类内静态成员 1.2.4.1 静态数据成员 类中的静态成员与类本身直接相关。而不是与类的各个对象保持关联。类的静态数据成员是属于整个类，而不与任何对象绑定； static关键字只能出现在类内部声明语句中； 类的静态成员存在于任何对象之外，对象中不包含任何与静态数据有关的数据； 静态成员变量使用前必须先初始化； 静态数据成员不能由类的构造函数初始化； 静态数据成员一般应在类的外部初始化。当静态数据成员为静态常量(const static)时，可以在类内初始化。 静态数据成员只能定义一次。 1.2.4.2 静态成员函数 类的静态成员函数也不与任何对象绑定，也不包含this指针。 静态成员函数不能声明为const,也不能在static函数体内使用this指针。 静态成员函数不能使用非静态成员函数，非静态成员函数可以使用静态成员函数。 ","date":"2024-12-15T22:08:28+08:00","permalink":"http://localhost:1313/post/cpp/cpp_some_keywords/","tags":[""],"title":"C++中的部分关键字的用法"},{"categories":["CPP"],"contents":"本文总结C++面向对象的相关理论知识。\n1 面向对象 1.1 面向对象的特征 面向对象的特征：封装、继承、多态。\n封装：把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。（优点：可以隐藏实现细节，使得代码模块化） 继承：可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。（优点：可以扩展已存在的代码模块（类）） 多态：一个类实例的相同方法在不同情形有不同表现形式。多态机制使具有不同内部结构的对象可以共享相同的外部接口。虽然针对不同对象的具体操作不同，但通过一个公共的类，这些操作可以通过相同的方式被调用。\n多态实现的两种方式：父类指针指向子类对象或将一个基类的引用类型赋值为它的派生类实例。（重要：虚函数 + 指针或引用） 1.5 类中的数据成员初始化顺序 一个类中的数据成员初始化的顺序，只与数据成员的定义时的顺序有关，而与初始化列表中数据成员的出现次序无关。\n1.7 构造函数的性质 构造函数的名字和类名相同 构造函数没有返回类型 构造函数不能被声明为const 构造函数可以重载，一般包含默认构造函数，拷贝构造函数。 默认构造函数不需要任何参数 构造函数不能为虚函数 1.7.1 构造函数初始化列表 注意: 如果成员是const、引用或者属于某种未提供默认构造函数的类类型。我们必须通过构造函数初始化列表为这些成员提供初值。\n数据成员初始化的顺序 数据成员初始化的顺序与它们在类中定义时出现的顺序一致，而与它们初始化的顺序无关。一般来说，初始化类成员没有严格的顺序要求。但是如果用一个成员初始化另一个成员时，顺序就很关键。例如：\n1 2 3 4 5 6 7 class X{ int i; int j; public: //未定义的：i在j之前被初始化 X(int val):j(val), i(j){} }; 上例中，从构造函数初始值的形式上看，好像是先用val初始化j，然后再用j初始化i。但实际上，i先被初始化，因此这个初始值的效果是试图使用未定义的j初始化i。\n提示：最好令构造函数初始值的顺序与成员声明的顺序保持一致。而且尽量避免使用某些成员初始化其他成员。\n默认实参和构造函数： 如果一个构造函数为所有参数都提供了默认实参，则它实际上也定义了默认构造函数。\n1.7.2 构造函数初始化时必须采用列表初始化的情形： const修饰的成员变量 引用成员变量 数据成员是某种未提供默认构造函数的类类型 1.7.3 默认构造函数 当对象默认初始化或者值初始化时，会自动调用默认构造函数。\n默认初始化的情况：\n在块作用域内不使用任何初始值定义一个非静态变量或者数组时 当一个类本身包含类类型的成员且使用合成的默认构造函数时 当类类型的成员没有在构造函数初始值列表中显示初始化时 值初始化的情形：\n在数组初始化的过程中若提供的初始值少于数组的大小时 不使用初始值顶一个局部静态变量时 通过形式T()的表达式请求值初始化时，其中T为类型名 温馨提示\n如果在一个类中定义构造函数，最好提供一个默认构造函数。\n1.8 析构函数的性质 析构函数不能重载 析构函数可以为虚函数，基类的析构函数建议定义为虚函数。 基类析构函数使用虚函数的好处：当使用基类的指针保存派生类的对象时，我们在释放基类的指针时不仅会释放基类的成员，还会释放派生的的成员，避免造成内存泄露。例如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class ClxBase { public: ClxBase() {}; virtual ~ClxBase() { cout \u0026lt;\u0026lt; \u0026#34;Output from the destructor of class ClxBase!\u0026#34; \u0026lt;\u0026lt; endl;}; virtual void DoSomething() { cout \u0026lt;\u0026lt; \u0026#34;Do something in class ClxBase!\u0026#34; \u0026lt;\u0026lt; endl; }; }; class ClxDerived : public ClxBase { public: ClxDerived() {}; ~ClxDerived() { cout \u0026lt;\u0026lt; \u0026#34;Output from the destructor of class ClxDerived!\u0026#34; \u0026lt;\u0026lt; endl; }; void DoSomething() override { cout \u0026lt;\u0026lt; \u0026#34;Do something in class ClxDerived!\u0026#34; \u0026lt;\u0026lt; endl; } }; int main() { ClxBase *p = new ClxDerived; p-\u0026gt;DoSomething(); delete p; return 0; } 温馨提示：\n绝不在构造和析构过程中调用virtual函数\n1.9 拷贝初始化发生的情形 用等号(=)定义类类型的对象 将一个对象作为实参传递给一个非引用类型的形参 从一个返回类型为非引用类型的函数返回一个对象 用花括号列表初始化一个数组中的元素或一个聚合类(struct)中的成员 1.10 拷贝构造和拷贝赋值运算符 拷贝构造函数的作用：使用一个存在的对象初始化一个未被初始化的对象。\n拷贝赋值运算符的作用：使用一个存在对象去替换一个已经初始化的对象。\n1.11 深拷贝与浅拷贝 浅拷贝，指的是在对象复制时，只对对象中的数据成员进行简单的赋值，默认拷贝构造函数执行的也是浅拷贝。大多情况下“浅拷贝”已经能很好地工作了，但是一旦对象存在动态成员，那么浅拷贝就会出问题。 “深拷贝”的情况下，对于对象中动态成员，就不能仅仅简单地赋值了，而应该重新动态分配空间。\n在某些状况下，类内成员变量需要动态开辟堆内存，如果实行位拷贝，也就是把对象里的值完全复制给另一个对象，如A=B。这时，如果B中有一个成员变量指针已经申请了内存，那A中的那个成员变量也指向同一块内存。这就出现了问题：当B把内存释放了（如：析构），这时A内的指针就是野指针了，出现运行错误。 深拷贝和浅拷贝可以简单理解为：如果一个类拥有资源，当这个类的对象发生复制过程的时候，资源重新分配，这个过程就是深拷贝，反之，没有重新分配资源，就是浅拷贝。\n1.12 基类和派生类 1.12.1 基类 温馨提示\n基类通常都应该定义一个虚析构函数，即使该函数不执行任何实际操作也是如此。\n派生类可以继承其基类的成员，然而当遇到与类型相关的操作时，派生类必须对其重新定义。即派生类需要对这些操作提供自己的新定义以覆盖(override)从基类继承而来的旧定义。 基类通过在其成员函数的声明语句之前加上关键字virtual使得该函数执行动态绑定。任何构造函数之外的非静态函数都可以是虚函数 。关键字virtual只能出现在类内部的声明语句之前而不能用于类外部的函数定义。 成员函数如果没被声明为虚函数，则其解析过程发生在编译时。\n1.12.2 定义派生类 派生类必须通过使用类派生列表明确指出它是从哪个基类继承而来的。\n派生类必须将其继承而来的成员函数中需要覆盖的那些重新声明。\n1.12.2.1 派生类的声明 派生类的声明与其它类差别不大，声明中包含类名但是不包含它的派生列表：\n1 2 class Bulk_quote : public Quote;\t//错误：派生列表不能出现在这里 class Bulk_quote;\t//正确：声明派生类的正确方式 1.12.2.2 派生类构造函数 尽管在派生类对象中包含有基类继承而来的成员，但是派生类并不能直接初始化这些成员。\n派生类也必须使用基类的构造函数来初始化它的基类部分。\n除非特别指出，否则派生类对象的基类部分会像数据成员一样执行默认初始化。 如果想使用其他的基类构造函数，我们需要一类名加圆括号内的实参列表的形式为构造函数提供初始值。 这些实参将帮助编译器决定应该选用那个构造函数来初始化派生类对象的基础部分。例如：\n1 2 3 //Bluk_quote的基类为Quote，在Bluk_quoute初始化时使用Quote的构造函数 Bluk_quote(const std::string\u0026amp; book, double p, std::size_t qty, double disc): Quoute(book, p), min_qty(qty), discount(disc){} 温馨提示\n首先初始化基类部分，然后按照声明的顺序依次初始化派生类的成员。\n1.12.2.3 派生类初始化的顺序 首先调用虚基类的构造函数 然后调用基类的构造函数。若有多个基类，基类构造函数的初始化顺序与派生类的派生列表一致 然后调用成员对象的构造函数 最后调用对象的本身的构造函数。 1.12.2.4 派生类中的虚函数 派生类经常覆盖它继承的虚函数。如果派生类没有覆盖其基类中的某个虚函数，则该虚函数的行为类似于其他的普通成员，派生类会直接继承其在基类中的版本。\n因为在派生类对象中含有与其基类对应的组成部分，所以我们能把派生类的对象当成基类对象使用。而且我们也能将基类的指针或引用绑定到派生类对象的中的基类部分上。这种转换称为派生类到基类的类型转换。编译器会隐式地执行派生类到基类的转换。 这种隐式特性意味着可以把派生类对象或者派生类对象的引用用在需要基类引用的地方。同样，我们也可以把派生类对象的指针用在需要基类指针的地方。\n1.12.2.5 继承和静态成员 如果基类定义了一个静态成员，则在整个继承体系中只存在该成员的唯一定义。不论从基类中派生出来多少个派生类，对于每个静态成员都只存在唯一的实例。\n静态成员遵循通用的访问控制规则，如果基类中的成员是private，则派生类无权访问它。假设静态成员是可访问的，则我们既能通过基类使用它也能通过派生类使用它。\n1.12.2.6 被用作基类的类 如果我们想使用某个类作为基类，这该类必须已经定义而非仅仅声明。\n1 2 3 class Quote;\t//声明但未定义 //错误：Quote必须已经定义 class Bluk_quote : public Quote{...}; 这一规定的原因显而易见：派生类中包含基类并且可以使用它从基类继承而来的成员，为了使用这些成员，派生类当然要知道它们是什么。因此，一个类不能派生它本身。\n1.12.2.7 防止继承的发生 有时我们定义这样的类，不希望其他类继承它。C++11提供了一种防止继承发生的方法，即在类名后跟一个关键字final：\n1 class NoDerived final{}; //NoDerived不能作为基类 1.13 C++多态特性 C++的多态性实现方式有：编译时多态(静态绑定)和运行时多态(动态绑定)。\n静态绑定：绑定的是对象的静态类型，依赖于对象的静态类型，发生在编译期。函数重载和模板实现的是静态绑定。 动态绑定：绑定的是对象的动态类型，依赖于对象的动态类型，发生在运行期。虚函数实现的是动态绑定。\nvirtual函数是动态绑定，non-virtual函数是静态绑定，缺省参数值也是静态绑定的。 1.13.1 多态性(polymorphism) 引用或指针的静态类型与动态类型不同这一事实是C++语言支持动态性的根本所在。\n当我们使用基类的引用或指针调用基类中定义的一个函数时，我们并不知道该函数真正作用的对象是什么类型。\n因为它可能是一个基类的对象也可能是一个派生类的对象。如果该函数是虚函数，则直到运行时才会决定到底执行哪个版本。\n判断的依据是引用或指针所绑定的对象的真实类型。\n另一方面，对非虚函数的调用在编译时进行绑定。类似的，通过对象进行的函数(虚函数或非虚函数)调用也在编译时绑定。\n对象的类型是确定不变的。通过对象进行的函数调用将在编译时绑定到该对象所属类中的函数版本上。\n1.13.2 动态绑定 只有在我们使用基类的引用或者指针调用基类的虚函数是才会发生动态绑定。\n必须使用基类的指针或者引用； 基类中必须存在这个调用的虚函数。 参见1.5.4的示例程序。 1.13.3 静态绑定 当我们通过一个具有普通类型(非引用非指针)的表达式调用虚函数时，在编译时就会将调用的版本确定下来，称为静态绑定。\n除了动态绑定外，其它情况均为静态绑定。\n例如如下程序的输出结果为：B-\u0026gt;1\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 class A{ public: virtual void func(int val = 1) { std::cout\u0026lt;\u0026lt;\u0026#34;A-\u0026gt;\u0026#34;\u0026lt;\u0026lt;val \u0026lt;\u0026lt;std::endl;} virtual void test(){ func();} }; class B : public A{ public: void func(int val=0){std::cout\u0026lt;\u0026lt;\u0026#34;B-\u0026gt;\u0026#34;\u0026lt;\u0026lt;val \u0026lt;\u0026lt;std::endl;} }; int main(int argc ,char* argv[]){ B* p = new B; p-\u0026gt;test(); return 0; } 上述程序的执行过程是：首先执行new B，调用类B的默认构造函数创建类B的对象。然后类B类型的指针指向以上新建的对象。 而后指针p调用test()函数。因为类B继承至类A，而且类B没有test()函数。因此此时的test()函数是类A的test()函数。 又因为类B拥有与类A形参列表相同的函数func()，而且类A的func()函数为虚函数。因此类B的func()函数会覆盖类A的函数。 因此类B在执行test()函数时，调用的是类B的func()函数。但是因为缺省参数是静态绑定的，因此val的值是基类A中的默认参数。因此就有： “绝不重新定义继承而来的缺省参数（Never redefine function’s inherited default parameters value.）”\n在构造函数中不要调用虚函数。在基类构造的时候，虚函数是非虚函数，不会走到派生类中，既是采用的静态绑定。 当我们构造一个子类的对象时，先调用基类的构造函数，构造子类中基类部分，子类还没有构造，还没有初始化，如果在基类的构造中调用虚函数，如果可以的话就是调用一个还没有被初始化的对象，那是很危险的。 在析构函数中也不要调用虚函数。在析构的时候会首先调用子类的析构函数，析构掉对象中的子类部分，然后在调用基类的析构函数析构基类部分。\n1.13.4 虚函数的性质 类中除了构造函数，静态函数以外的函数都可以为虚函数。 派生类要想覆盖(override)基类的虚函数，必须与基类的虚函数拥有相同的函数参数列表。\n在C++语言中，当我们使用基类的引用或指针调用一个虚成员函数时会执行动态绑定。因为我们知道运行时才知道调用了哪个版本的虚函数，所以所有虚函数都必须有定义。因此，我们必须为每一个虚函数都提供定义，而不管它是否被用到。只是因为，编译器也无法确定到底会使用哪个虚函数。\n对虚函数的调用可能在运行时才能被解析\n当某个虚函数通过指针或引用调用时，编译器产生的代码直到运行时才能确定应该调用哪个版本的函数。被调用的函数是与绑定到指针或引用上的对象的动态类型相匹配的哪一个。\n1 2 3 4 Quoute base(\u0026#34;0-201-82470-1\u0026#34;, 50); print_total(cout, base, 10);\t//调用Quote::net_price Bulk_quote derived(\u0026#34;0-201-82470-1\u0026#34;, 50, 5, 0.19); print_total(cout, derived, 10);\t//调用Bulk_quote:net_price 1.13.4.1 派生类中的虚函数 当我们在派生类中覆盖了某个虚函数时，可以再一次使用virtual关键字指出该函数的性质。\n然而这么做并非必须，因为一旦某个函数被声明为虚函数，则在所有派生类中它都是虚函数。\n一个派生类的函数如果覆盖了某个继承而来的虚函数，则它的形参类型必须与被它覆盖的基类函数完全一致。\n同样，派生类中虚函数的返回类型也必须与基类函数匹配。该规则存在一个例外, 当类的虚函数返回类型是类本身的指针或引用时，可以不遵循上述规则。例如，如果D由B派生得到，则基类的虚函数可以返回B*而派生类的对应函数可以返回D*。只不过这样的返回类型要求从D到B的类型转换是可访问的。\n温馨提示\n基类中的虚函数在派生类中隐含地也是一个虚函数。当派生类覆盖了某个虚函数时，该函数在基类中的形参必须与派生类中的形参严格匹配。\n1 2 3 4 5 6 7 8 9 10 11 struct B{ virtual void f1(int) const; virtual void f2(); void f3(); }; struct D1 : B{ void f1(int) const override; //正确：f1与基类中的f1匹配 void f2(int) override; //错误：B没有形如f2(int)的函数 void f3() override; //错误：B中f3不是虚函数 void f4() override; //错误：B中没有名为f4的函数 } 因为只有虚函数才能被覆盖。所以编译器会拒绝D1的f3。\n该函数不是B中的虚函数，因此它不能被覆盖。类似的，f4的声明也会发生错误，因为B中根本就没有名为f4的函数。\n我们还能把某个函数指定为final，如果我们已经把函数定义为final，则之后任何尝试覆盖该函数的操作都将引发错误：\n1 2 3 4 5 6 7 8 struct D2 : B{ //从B继承f2()和f3(),覆盖f1(int) void f1(int) const final; }; struct D3 : D2{ void f2();\t//正确：覆盖从间接基类B继承而来的f2 void f1(int) const;\t//错误：D2已经将f2声明为final }; 1.13.4.2 虚函数与默认实参 和其他函数一样，虚函数也可以拥有默认实参。如果某次函数调用使用了默认实参，则该实参值由本次调用的静态类型决定。 换句话说，如果我们通过基类的引用或指针 调用函数，则使用基类中定义的默认实参，即使实际运行的派生类中的函数版本也是如此。此时，传入派生类函数的将是基类函数定义的默认实参。如果派生类函数依赖不同的实参，则程序结果将与我们的与其不符。\n1.13.4.3 回避虚函数的机制 在某些情况下，我们希望对虚函数的调用不要进行动态绑定，而是强迫其执行虚函数的某个特定版本。使用作用域运算符可以实现这一目的。例如：\n1 2 //强行调用基类中定义的函数版本而不管baseP的动态类型到底是什么 double undiscounted = baseP-\u0026gt;Quote::net_price(42); 1.13.4.4 虚函数表 C++中虚函数使用虚函数表和虚函数表指针实现。\n虚函数表(vtabel,virtual function table):虚函数表是编译器在编译阶段生成的。虚函数表中存放的是虚函数的指针。\n编译器在每个含有虚函数的类中包含了一个虚函数表指针*__vptr。当创建一个该类的实例时，虚函数表指针将指向虚函数表。虚函数表存放在只读区(.rodata区)。\n1.14 访问控制与继承 继承类成员的访问级别\n成员权限(下)/ 继承权限(右) public protected private public public protected private protected protected protected private private 不可访问 不可访问 不可访问 ","date":"2024-12-15T22:08:07+08:00","permalink":"http://localhost:1313/post/cpp/cpp_oop/","tags":["OOP"],"title":"C++面向对象理论知识"},{"categories":["Tools"],"contents":"1 Qt下载与安装 QT5.9下载地址\n2 QT经典示例程序 简单计算器示例代码\n3 QT视频教程 传智播客《QT从入门到实战完整版》 \u0026ndash;\u0026gt; 视频配套代码\n","date":"2024-12-15T14:40:46+08:00","permalink":"http://localhost:1313/post/tools/qt_usful_tips/","tags":["QT"],"title":"QT入门"},{"categories":[""],"contents":"GCC总结常用编译命令和常用内置函数。\n1 GCC编译选项 1.1 GCC常用编译选项 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 file.c\tC语言源代码 file.i\t预处理后的C语言源文件 file.s\tGUN汇编代码 file.o\t链接文件 .a 归档库文件(Archive file) -o file\t指定生成的可执行文件的文件名为file -c\t编译或者汇编源代码，但是不执行链接操作；生成file.o文件 -E\t对源文件进行预处理,得到的信息显示在stdin;一般重定位到某个文件中，例如： gcc -E main.c \u0026gt; main.i -g\t在目标程序中加入调试信息，用于debug -I\t指定头文件所在的文件夹 -L\t指定函数库所在的文件夹 -O 对编译代码进行优化，后跟优化级别。例如-O3 -S\t将源代码编译为汇编代码；生成file.s文件 -std=standard standard,其中standard为C/C++的标准，例如c89,c99,c++0x,c++11 -Wall\t打开所有警告信息 1.2 GCC的attribute功能 1.2.1 aligned 功能说明：该属性指定结构体变量或者变量的最小对齐长度，单位是字节。\n示例：\n1 int x __attribute__ ((aligned (16))) = 0; 1.2.2 packed 功能说明：该属性指定结构体变量或者变量的最小对齐长度：变量最小对齐长度为1字节，结构体变量的最少为1位，除非通过aligned属性执行最大值。\n使用示例：\n1 2 3 4 struct foo { char a; int x[2] __attribute__ ((packed)); }; 1.2.3 section attribute((section(\u0026ldquo;name\u0026rdquo;)))实现在编译时把某个函数/数据放到指定的内存区域。以下两种格式都是可以的。\n1 2 __attribute__((__section__(\u0026#34;section_name\u0026#34;))) __attribute__((section(\u0026#34;section_name\u0026#34;))) 使用示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 struct duart a __attribute__ ((section (\u0026#34;DUART_A\u0026#34;))) = { 0 }; struct duart b __attribute__ ((section (\u0026#34;DUART_B\u0026#34;))) = { 0 }; char stack[10000] __attribute__ ((section (\u0026#34;STACK\u0026#34;))) = { 0 }; int init_data __attribute__ ((section (\u0026#34;INITDATA\u0026#34;))) = 0; int main() { /* Initialize stack pointer */ init_sp(stack + sizeof(stack)); /* Initialize initialized data */ memcpy(\u0026amp;init_data, \u0026amp;data, \u0026amp;edata - \u0026amp;data); /* Turn on the serial ports */ init_duart(\u0026amp;a); init_duart(\u0026amp;b); } 参考文献：\nGCC Specifying Attributes of Variables\n2 gcc编译时使用asan的方法 环境安装和gcc版本对应的libasan版本。 编译代码时添加-fsanitize=address参数。 例如：\n1 gcc -Wall -g -std=c99 -fsanitize=address lru.c -o lru 备注：ubuntu系统中不同asan版本和gcc的对应关系。\nlibasan0: gcc-4.8 libasan2: gcc-5 libasan3: gcc-6 libasan4: gcc-7 libasan5: gcc-8 3 GCC的","date":"2024-12-14T19:44:49+08:00","permalink":"http://localhost:1313/post/tools/gcc_usful_tips/","tags":[""],"title":"GCC常用编译命令和常用内置函数"},{"categories":["CPP"],"contents":"本文总结vector的原理和使用方法。\n1 vector的实现原理 1.2 vector保存在栈上还是堆上？ 示例代码1: 1 2 3 4 5 6 7 8 9 10 11 12 13 vector\u0026lt;int\u0026gt;* test_vec(void) { vector\u0026lt;int\u0026gt; vec; vec.push_back(1); vec.push_back(2); return \u0026amp;vec; } int main() { vector\u0026lt;int\u0026gt;* o_vec = test_vec(); printf(\u0026#34;%d\\n\u0026#34;, (*o_vec)[0]); return 0; } 在编译时会有如下提示：warning: reference to local variable 'vec' returned [-Wreturn-local-addr]。 而忽略该告警直接编译运行，进程会coredump。\n示例代码2 1 2 3 4 5 6 7 8 9 10 11 12 13 vector\u0026lt;int\u0026gt; test_vec(void) { vector\u0026lt;int\u0026gt; vec; vec.push_back(1); vec.push_back(2); return vec; } int main() { vector\u0026lt;int\u0026gt; o_vec = test_vec(); printf(\u0026#34;%d\\n\u0026#34;, o_vec[0]); return 0; } 该段代码可以正常编译运行，无任何报错。\n示例代码3 1 2 3 4 5 6 7 8 9 10 11 12 13 vector\u0026lt;int\u0026gt;* test_vec(void) { vector\u0026lt;int\u0026gt;* vec = new vector\u0026lt;int\u0026gt;; vec-\u0026gt;push_back(1); vec-\u0026gt;push_back(2); return vec; } int main() { vector\u0026lt;int\u0026gt;* o_vec = test_vec(); printf(\u0026#34;%d\\n\u0026#34;, (*o_vec)[0]); return 0; } 这段代码可以正常运行。\n原因分析：\n为什么示例代码1和实例代码2中的函数test_vec()相同，为啥返回vector变量的地址会coredump，而直接将vector的名字返回却可以正常运行呢？ 答：因为C++ 11新特性中支持直接返回容器名会默认调用move()函数,参考1.3.1和1.3.2的内容。 1.3 C++中返回一个vector的方法 1.3.1 通过value返回 1 2 3 4 5 6 #include \u0026lt;vector\u0026gt; std::vector\u0026lt;int\u0026gt; createVector() { std::vector\u0026lt;int\u0026gt; vec = {1, 2, 3, 4, 5}; return vec; // Move semantics will be applied here } 1.3.2 通过move()函数 1 2 3 4 std::vector\u0026lt;int\u0026gt; createVector() { std::vector\u0026lt;int\u0026gt; vec = {1, 2, 3, 4, 5}; return std::move(vec); // Explicitly moving the vector } 1.3.3 返回静态引用 1 2 3 4 std::vector\u0026lt;int\u0026gt;\u0026amp; getGlobalVector() { static std::vector\u0026lt;int\u0026gt; vec = {1, 2, 3, 4, 5}; return vec; // Return a reference to a static vector } 1.3.4 通过传入引用实现 1 2 3 void fillVector(std::vector\u0026lt;int\u0026gt;\u0026amp; vec) { vec = {1, 2, 3, 4, 5}; // Modify the existing vector } 1.3.5 使用std::optional 1 2 3 4 5 6 7 8 9 #include \u0026lt;optional\u0026gt; #include \u0026lt;vector\u0026gt; std::optional\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; createVector(bool shouldCreate) { if (shouldCreate) { return std::vector\u0026lt;int\u0026gt;{1, 2, 3, 4, 5}; } return std::nullopt; // No vector created } 相关参考文档：\nIs there a way to return a vector more efficiently\n一文带你详细介绍c++中的std::move函数\n【Modern C++】深入理解左值、右值\n2 vector的使用方法 2.1 vector初始化的方法 1 2 3 4 5 6 7 std::vector\u0026lt;int\u0026gt; first; // empty vector of ints std::vector\u0026lt;int\u0026gt; second(4, 100); // four ints with value 100 std::vector\u0026lt;int\u0026gt; third(second.begin(),second.end()); // iterating through second std::vector\u0026lt;int\u0026gt; fourth(third); // a copy of third int tmp[] = { 10, 20, 30 }; std::vector\u0026lt;int\u0026gt; v(tmp, tmp + 3 ); // use some utility to avoid hardcoding the size here 2.2 vector容量相关 1 2 3 std::vector\u0026lt;int\u0026gt; vec(3, 235); vec.size(); // return the number of elements vec.empty(); // checks whether the container is empty 2.3 vector数据修改 1 2 3 std::vector\u0026lt;int\u0026gt; vec(3, 235); // init vector vec.push_back(12); // adds an element to the end vec.pop_back(); // removes the last element ","date":"2024-12-13T22:45:13+08:00","permalink":"http://localhost:1313/post/cpp/stl/vector/","tags":["STL","vector"],"title":"Vector"},{"categories":["CPP"],"contents":"1 C++数据处理 1.1 获取浮点型数的小数部分 1 2 float value; float rear = value - (int)value; //获取浮点数的小数部分 1.2 double保留指定位数的小数 1 2 3 4 5 6 double round(double number, unsigned int bits) { stringstream ss; ss \u0026lt;\u0026lt; fixed \u0026lt;\u0026lt; setprecision(bits) \u0026lt;\u0026lt; number; ss \u0026gt;\u0026gt; number; return number; } 2 动态数组初始化方法 1 2 3 4 5 int size = 50; int *p=new int[size]; //申请动态数组 delete [] p; //释放动态数组 ","date":"2024-12-13T22:39:33+08:00","permalink":"http://localhost:1313/post/cpp/cpp_common_tips/","tags":[""],"title":"C++编码中常用的基础知识"},{"categories":["Tools"],"contents":"1 本文的gdb脚本的使用方法 将步骤2中的脚本拷贝到文件.gdbinit文件中； 然后就可以在gdb中使用对应的命令，查看c++容器中的内容。 2 GDB打印C++中容器内容的gdb脚本 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 # # STL GDB evaluators/views/utilities - 1.03 # # The new GDB commands: # are entirely non instrumental # do not depend on any \u0026#34;inline\u0026#34;(s) - e.g. size(), [], etc # are extremely tolerant to debugger settings # # This file should be \u0026#34;included\u0026#34; in .gdbinit as following: # source stl-views.gdb or just paste it into your .gdbinit file # # The following STL containers are currently supported: # # std::vector\u0026lt;T\u0026gt; -- via pvector command # std::list\u0026lt;T\u0026gt; -- via plist or plist_member command # std::map\u0026lt;T,T\u0026gt; -- via pmap or pmap_member command # std::multimap\u0026lt;T,T\u0026gt; -- via pmap or pmap_member command # std::set\u0026lt;T\u0026gt; -- via pset command # std::multiset\u0026lt;T\u0026gt; -- via pset command # std::deque\u0026lt;T\u0026gt; -- via pdequeue command # std::stack\u0026lt;T\u0026gt; -- via pstack command # std::queue\u0026lt;T\u0026gt; -- via pqueue command # std::priority_queue\u0026lt;T\u0026gt; -- via ppqueue command # std::bitset\u0026lt;n\u0026gt; -- via pbitset command # std::string -- via pstring command # std::widestring -- via pwstring command # # The end of this file contains (optional) C++ beautifiers # Make sure your debugger supports $argc # # Simple GDB Macros writen by Dan Marinescu (H-PhD) - License GPL # Inspired by intial work of Tom Malnar, # Tony Novac (PhD) / Cornell / Stanford, # Gilad Mishne (PhD) and Many Many Others. # Contact: dan_c_marinescu@yahoo.com (Subject: STL) # # Modified to work with g++ 4.3 by Anders Elton # Also added _member functions, that instead of printing the entire class in map, prints a member. # # std::vector\u0026lt;\u0026gt; # define pvector if $argc == 0 help pvector else set $size = $arg0._M_impl._M_finish - $arg0._M_impl._M_start set $capacity = $arg0._M_impl._M_end_of_storage - $arg0._M_impl._M_start set $size_max = $size - 1 end if $argc == 1 set $i = 0 while $i \u0026lt; $size printf \u0026#34;elem[%u]: \u0026#34;, $i p *($arg0._M_impl._M_start + $i) set $i++ end end if $argc == 2 set $idx = $arg1 if $idx \u0026lt; 0 || $idx \u0026gt; $size_max printf \u0026#34;idx1, idx2 are not in acceptable range: [0..%u].\\n\u0026#34;, $size_max else printf \u0026#34;elem[%u]: \u0026#34;, $idx p *($arg0._M_impl._M_start + $idx) end end if $argc == 3 set $start_idx = $arg1 set $stop_idx = $arg2 if $start_idx \u0026gt; $stop_idx set $tmp_idx = $start_idx set $start_idx = $stop_idx set $stop_idx = $tmp_idx end if $start_idx \u0026lt; 0 || $stop_idx \u0026lt; 0 || $start_idx \u0026gt; $size_max || $stop_idx \u0026gt; $size_max printf \u0026#34;idx1, idx2 are not in acceptable range: [0..%u].\\n\u0026#34;, $size_max else set $i = $start_idx while $i \u0026lt;= $stop_idx printf \u0026#34;elem[%u]: \u0026#34;, $i p *($arg0._M_impl._M_start + $i) set $i++ end end end if $argc \u0026gt; 0 printf \u0026#34;Vector size = %u\\n\u0026#34;, $size printf \u0026#34;Vector capacity = %u\\n\u0026#34;, $capacity printf \u0026#34;Element \u0026#34; whatis $arg0._M_impl._M_start end end document pvector Prints std::vector\u0026lt;T\u0026gt; information. Syntax: pvector \u0026lt;vector\u0026gt; \u0026lt;idx1\u0026gt; \u0026lt;idx2\u0026gt; Note: idx, idx1 and idx2 must be in acceptable range [0..\u0026lt;vector\u0026gt;.size()-1]. Examples: pvector v - Prints vector content, size, capacity and T typedef pvector v 0 - Prints element[idx] from vector pvector v 1 2 - Prints elements in range [idx1..idx2] from vector end # # std::list\u0026lt;\u0026gt; # define plist if $argc == 0 help plist else set $head = \u0026amp;$arg0._M_impl._M_node set $current = $arg0._M_impl._M_node._M_next set $size = 0 while $current != $head if $argc == 2 printf \u0026#34;elem[%u]: \u0026#34;, $size p *($arg1*)($current + 1) end if $argc == 3 if $size == $arg2 printf \u0026#34;elem[%u]: \u0026#34;, $size p *($arg1*)($current + 1) end end set $current = $current._M_next set $size++ end printf \u0026#34;List size = %u \\n\u0026#34;, $size if $argc == 1 printf \u0026#34;List \u0026#34; whatis $arg0 printf \u0026#34;Use plist \u0026lt;variable_name\u0026gt; \u0026lt;element_type\u0026gt; to see the elements in the list.\\n\u0026#34; end end end document plist Prints std::list\u0026lt;T\u0026gt; information. Syntax: plist \u0026lt;list\u0026gt; \u0026lt;T\u0026gt; \u0026lt;idx\u0026gt;: Prints list size, if T defined all elements or just element at idx Examples: plist l - prints list size and definition plist l int - prints all elements and list size plist l int 2 - prints the third element in the list (if exists) and list size end define plist_member if $argc == 0 help plist_member else set $head = \u0026amp;$arg0._M_impl._M_node set $current = $arg0._M_impl._M_node._M_next set $size = 0 while $current != $head if $argc == 3 printf \u0026#34;elem[%u]: \u0026#34;, $size p (*($arg1*)($current + 1)).$arg2 end if $argc == 4 if $size == $arg3 printf \u0026#34;elem[%u]: \u0026#34;, $size p (*($arg1*)($current + 1)).$arg2 end end set $current = $current._M_next set $size++ end printf \u0026#34;List size = %u \\n\u0026#34;, $size if $argc == 1 printf \u0026#34;List \u0026#34; whatis $arg0 printf \u0026#34;Use plist_member \u0026lt;variable_name\u0026gt; \u0026lt;element_type\u0026gt; \u0026lt;member\u0026gt; to see the elements in the list.\\n\u0026#34; end end end document plist_member Prints std::list\u0026lt;T\u0026gt; information. Syntax: plist \u0026lt;list\u0026gt; \u0026lt;T\u0026gt; \u0026lt;idx\u0026gt;: Prints list size, if T defined all elements or just element at idx Examples: plist_member l int member - prints all elements and list size plist_member l int member 2 - prints the third element in the list (if exists) and list size end # # std::map and std::multimap # define pmap if $argc == 0 help pmap else set $tree = $arg0 set $i = 0 set $node = $tree._M_t._M_impl._M_header._M_left set $end = $tree._M_t._M_impl._M_header set $tree_size = $tree._M_t._M_impl._M_node_count if $argc == 1 printf \u0026#34;Map \u0026#34; whatis $tree printf \u0026#34;Use pmap \u0026lt;variable_name\u0026gt; \u0026lt;left_element_type\u0026gt; \u0026lt;right_element_type\u0026gt; to see the elements in the map.\\n\u0026#34; end if $argc == 3 while $i \u0026lt; $tree_size set $value = (void *)($node + 1) printf \u0026#34;elem[%u].left: \u0026#34;, $i p *($arg1*)$value set $value = $value + sizeof($arg1) printf \u0026#34;elem[%u].right: \u0026#34;, $i p *($arg2*)$value if $node._M_right != 0 set $node = $node._M_right while $node._M_left != 0 set $node = $node._M_left end else set $tmp_node = $node._M_parent while $node == $tmp_node._M_right set $node = $tmp_node set $tmp_node = $tmp_node._M_parent end if $node._M_right != $tmp_node set $node = $tmp_node end end set $i++ end end if $argc == 4 set $idx = $arg3 set $ElementsFound = 0 while $i \u0026lt; $tree_size set $value = (void *)($node + 1) if *($arg1*)$value == $idx printf \u0026#34;elem[%u].left: \u0026#34;, $i p *($arg1*)$value set $value = $value + sizeof($arg1) printf \u0026#34;elem[%u].right: \u0026#34;, $i p *($arg2*)$value set $ElementsFound++ end if $node._M_right != 0 set $node = $node._M_right while $node._M_left != 0 set $node = $node._M_left end else set $tmp_node = $node._M_parent while $node == $tmp_node._M_right set $node = $tmp_node set $tmp_node = $tmp_node._M_parent end if $node._M_right != $tmp_node set $node = $tmp_node end end set $i++ end printf \u0026#34;Number of elements found = %u\\n\u0026#34;, $ElementsFound end if $argc == 5 set $idx1 = $arg3 set $idx2 = $arg4 set $ElementsFound = 0 while $i \u0026lt; $tree_size set $value = (void *)($node + 1) set $valueLeft = *($arg1*)$value set $valueRight = *($arg2*)($value + sizeof($arg1)) if $valueLeft == $idx1 \u0026amp;\u0026amp; $valueRight == $idx2 printf \u0026#34;elem[%u].left: \u0026#34;, $i p $valueLeft printf \u0026#34;elem[%u].right: \u0026#34;, $i p $valueRight set $ElementsFound++ end if $node._M_right != 0 set $node = $node._M_right while $node._M_left != 0 set $node = $node._M_left end else set $tmp_node = $node._M_parent while $node == $tmp_node._M_right set $node = $tmp_node set $tmp_node = $tmp_node._M_parent end if $node._M_right != $tmp_node set $node = $tmp_node end end set $i++ end printf \u0026#34;Number of elements found = %u\\n\u0026#34;, $ElementsFound end printf \u0026#34;Map size = %u\\n\u0026#34;, $tree_size end end document pmap Prints std::map\u0026lt;TLeft and TRight\u0026gt; or std::multimap\u0026lt;TLeft and TRight\u0026gt; information. Works for std::multimap as well. Syntax: pmap \u0026lt;map\u0026gt; \u0026lt;TtypeLeft\u0026gt; \u0026lt;TypeRight\u0026gt; \u0026lt;valLeft\u0026gt; \u0026lt;valRight\u0026gt;: Prints map size, if T defined all elements or just element(s) with val(s) Examples: pmap m - prints map size and definition pmap m int int - prints all elements and map size pmap m int int 20 - prints the element(s) with left-value = 20 (if any) and map size pmap m int int 20 200 - prints the element(s) with left-value = 20 and right-value = 200 (if any) and map size end define pmap_member if $argc == 0 help pmap_member else set $tree = $arg0 set $i = 0 set $node = $tree._M_t._M_impl._M_header._M_left set $end = $tree._M_t._M_impl._M_header set $tree_size = $tree._M_t._M_impl._M_node_count if $argc == 1 printf \u0026#34;Map \u0026#34; whatis $tree printf \u0026#34;Use pmap \u0026lt;variable_name\u0026gt; \u0026lt;left_element_type\u0026gt; \u0026lt;right_element_type\u0026gt; to see the elements in the map.\\n\u0026#34; end if $argc == 5 while $i \u0026lt; $tree_size set $value = (void *)($node + 1) printf \u0026#34;elem[%u].left: \u0026#34;, $i p (*($arg1*)$value).$arg2 set $value = $value + sizeof($arg1) printf \u0026#34;elem[%u].right: \u0026#34;, $i p (*($arg3*)$value).$arg4 if $node._M_right != 0 set $node = $node._M_right while $node._M_left != 0 set $node = $node._M_left end else set $tmp_node = $node._M_parent while $node == $tmp_node._M_right set $node = $tmp_node set $tmp_node = $tmp_node._M_parent end if $node._M_right != $tmp_node set $node = $tmp_node end end set $i++ end end if $argc == 6 set $idx = $arg5 set $ElementsFound = 0 while $i \u0026lt; $tree_size set $value = (void *)($node + 1) if *($arg1*)$value == $idx printf \u0026#34;elem[%u].left: \u0026#34;, $i p (*($arg1*)$value).$arg2 set $value = $value + sizeof($arg1) printf \u0026#34;elem[%u].right: \u0026#34;, $i p (*($arg3*)$value).$arg4 set $ElementsFound++ end if $node._M_right != 0 set $node = $node._M_right while $node._M_left != 0 set $node = $node._M_left end else set $tmp_node = $node._M_parent while $node == $tmp_node._M_right set $node = $tmp_node set $tmp_node = $tmp_node._M_parent end if $node._M_right != $tmp_node set $node = $tmp_node end end set $i++ end printf \u0026#34;Number of elements found = %u\\n\u0026#34;, $ElementsFound end printf \u0026#34;Map size = %u\\n\u0026#34;, $tree_size end end document pmap_member Prints std::map\u0026lt;TLeft and TRight\u0026gt; or std::multimap\u0026lt;TLeft and TRight\u0026gt; information. Works for std::multimap as well. Syntax: pmap \u0026lt;map\u0026gt; \u0026lt;TtypeLeft\u0026gt; \u0026lt;TypeRight\u0026gt; \u0026lt;valLeft\u0026gt; \u0026lt;valRight\u0026gt;: Prints map size, if T defined all elements or just element(s) with val(s) Examples: pmap_member m class1 member1 class2 member2 - prints class1.member1 : class2.member2 pmap_member m class1 member1 class2 member2 lvalue - prints class1.member1 : class2.member2 where class1 == lvalue end # # std::set and std::multiset # define pset if $argc == 0 help pset else set $tree = $arg0 set $i = 0 set $node = $tree._M_t._M_impl._M_header._M_left set $end = $tree._M_t._M_impl._M_header set $tree_size = $tree._M_t._M_impl._M_node_count if $argc == 1 printf \u0026#34;Set \u0026#34; whatis $tree printf \u0026#34;Use pset \u0026lt;variable_name\u0026gt; \u0026lt;element_type\u0026gt; to see the elements in the set.\\n\u0026#34; end if $argc == 2 while $i \u0026lt; $tree_size set $value = (void *)($node + 1) printf \u0026#34;elem[%u]: \u0026#34;, $i p *($arg1*)$value if $node._M_right != 0 set $node = $node._M_right while $node._M_left != 0 set $node = $node._M_left end else set $tmp_node = $node._M_parent while $node == $tmp_node._M_right set $node = $tmp_node set $tmp_node = $tmp_node._M_parent end if $node._M_right != $tmp_node set $node = $tmp_node end end set $i++ end end if $argc == 3 set $idx = $arg2 set $ElementsFound = 0 while $i \u0026lt; $tree_size set $value = (void *)($node + 1) if *($arg1*)$value == $idx printf \u0026#34;elem[%u]: \u0026#34;, $i p *($arg1*)$value set $ElementsFound++ end if $node._M_right != 0 set $node = $node._M_right while $node._M_left != 0 set $node = $node._M_left end else set $tmp_node = $node._M_parent while $node == $tmp_node._M_right set $node = $tmp_node set $tmp_node = $tmp_node._M_parent end if $node._M_right != $tmp_node set $node = $tmp_node end end set $i++ end printf \u0026#34;Number of elements found = %u\\n\u0026#34;, $ElementsFound end printf \u0026#34;Set size = %u\\n\u0026#34;, $tree_size end end document pset Prints std::set\u0026lt;T\u0026gt; or std::multiset\u0026lt;T\u0026gt; information. Works for std::multiset as well. Syntax: pset \u0026lt;set\u0026gt; \u0026lt;T\u0026gt; \u0026lt;val\u0026gt;: Prints set size, if T defined all elements or just element(s) having val Examples: pset s - prints set size and definition pset s int - prints all elements and the size of s pset s int 20 - prints the element(s) with value = 20 (if any) and the size of s end # # std::dequeue # define pdequeue if $argc == 0 help pdequeue else set $vec = ($arg0) # size of one data element set $datasize = sizeof(**$vec._M_impl._M_map) # bufsize is the number of nodes per memory page set $bufsize = $datasize \u0026lt; 512 ? 512/$datasize : 1 set $iter = $vec._M_impl._M_start set $enditer = $vec._M_impl._M_finish set $mnode = $iter._M_node set $mfirst = $iter._M_first set $mlast = $iter._M_last set $mcur = $iter._M_cur set $size = 0 while ($mcur != $enditer._M_cur) if $argc == 2 printf \u0026#34;elem[%u]: \u0026#34;, $size p *($arg1*)($mcur) end if $argc == 3 if $size == $arg2 printf \u0026#34;elem[%u]: \u0026#34;, $size p *($arg1*)($mcur) end end if $argc == 1 printf \u0026#34;elem[%u]: \u0026#34;, $size p *$mcur end # now imitate iter.operator++ set $mcur++ if ($mcur == $mlast) set $mnode++ set $mfirst = *$mnode set $mlast = $mfirst + $bufsize set $mcur = $mfirst end set $size++ end printf \u0026#34;Dequeue size = %u\\n\u0026#34;, $size end end document pdequeue Prints std::dequeue\u0026lt;T\u0026gt; information. Syntax: pdequeue \u0026lt;dequeue\u0026gt;: Prints dequeue size, if T defined all elements Deque elements are listed \u0026#34;left to right\u0026#34; (left-most stands for front and right-most stands for back) Example: pdequeue d - prints all elements and size of d end # # std::stack # define pstack if $argc == 0 help pstack else set $start_cur = $arg0.c._M_impl._M_start._M_cur set $finish_cur = $arg0.c._M_impl._M_finish._M_cur set $size = $finish_cur - $start_cur set $i = $size - 1 while $i \u0026gt;= 0 p *($start_cur + $i) set $i-- end printf \u0026#34;Stack size = %u\\n\u0026#34;, $size end end document pstack Prints std::stack\u0026lt;T\u0026gt; information. Syntax: pstack \u0026lt;stack\u0026gt;: Prints all elements and size of the stack Stack elements are listed \u0026#34;top to buttom\u0026#34; (top-most element is the first to come on pop) Example: pstack s - prints all elements and the size of s end # # std::queue # define pqueue if $argc == 0 help pqueue else set $start_cur = $arg0.c._M_impl._M_start._M_cur set $finish_cur = $arg0.c._M_impl._M_finish._M_cur set $size = $finish_cur - $start_cur set $i = 0 while $i \u0026lt; $size p *($start_cur + $i) set $i++ end printf \u0026#34;Queue size = %u\\n\u0026#34;, $size end end document pqueue Prints std::queue\u0026lt;T\u0026gt; information. Syntax: pqueue \u0026lt;queue\u0026gt;: Prints all elements and the size of the queue Queue elements are listed \u0026#34;top to bottom\u0026#34; (top-most element is the first to come on pop) Example: pqueue q - prints all elements and the size of q end # # std::priority_queue # define ppqueue if $argc == 0 help ppqueue else set $size = $arg0.c._M_impl._M_finish - $arg0.c._M_impl._M_start set $capacity = $arg0.c._M_impl._M_end_of_storage - $arg0.c._M_impl._M_start set $i = $size - 1 while $i \u0026gt;= 0 p *($arg0.c._M_impl._M_start + $i) set $i-- end printf \u0026#34;Priority queue size = %u\\n\u0026#34;, $size printf \u0026#34;Priority queue capacity = %u\\n\u0026#34;, $capacity end end document ppqueue Prints std::priority_queue\u0026lt;T\u0026gt; information. Syntax: ppqueue \u0026lt;priority_queue\u0026gt;: Prints all elements, size and capacity of the priority_queue Priority_queue elements are listed \u0026#34;top to buttom\u0026#34; (top-most element is the first to come on pop) Example: ppqueue pq - prints all elements, size and capacity of pq end # # std::bitset # define pbitset if $argc == 0 help pbitset else p /t $arg0._M_w end end document pbitset Prints std::bitset\u0026lt;n\u0026gt; information. Syntax: pbitset \u0026lt;bitset\u0026gt;: Prints all bits in bitset Example: pbitset b - prints all bits in b end # # std::string # define pstring if $argc == 0 help pstring else printf \u0026#34;String \\t\\t\\t= \\\u0026#34;%s\\\u0026#34;\\n\u0026#34;, $arg0._M_data() printf \u0026#34;String size/length \\t= %u\\n\u0026#34;, $arg0._M_rep()._M_length printf \u0026#34;String capacity \\t= %u\\n\u0026#34;, $arg0._M_rep()._M_capacity printf \u0026#34;String ref-count \\t= %d\\n\u0026#34;, $arg0._M_rep()._M_refcount end end document pstring Prints std::string information. Syntax: pstring \u0026lt;string\u0026gt; Example: pstring s - Prints content, size/length, capacity and ref-count of string s end # # std::wstring # define pwstring if $argc == 0 help pwstring else call printf(\u0026#34;WString \\t\\t= \\\u0026#34;%ls\\\u0026#34;\\n\u0026#34;, $arg0._M_data()) printf \u0026#34;WString size/length \\t= %u\\n\u0026#34;, $arg0._M_rep()._M_length printf \u0026#34;WString capacity \\t= %u\\n\u0026#34;, $arg0._M_rep()._M_capacity printf \u0026#34;WString ref-count \\t= %d\\n\u0026#34;, $arg0._M_rep()._M_refcount end end document pwstring Prints std::wstring information. Syntax: pwstring \u0026lt;wstring\u0026gt; Example: pwstring s - Prints content, size/length, capacity and ref-count of wstring s end # # C++ related beautifiers (optional) # set print pretty on set print object on set print static-members on set print vtbl on set print demangle on set demangle-style gnu-v3 set print sevenbit-strings off set follow-fork-mode child set detach-on-fork off ","date":"2024-12-13T22:15:25+08:00","permalink":"http://localhost:1313/post/tools/gdb_print_stl_tool/","tags":["GDB"],"title":"GDB打印C++ STL容器中的内容的方法"},{"categories":["Linux"],"contents":"本文介绍Linux系统中各种钩子的使用方法以及使用场景。\n1 用户态钩子 2 内核态钩子","date":"2024-12-13T15:49:45+08:00","permalink":"http://localhost:1313/post/linux/linux_hook/","tags":["hook"],"title":"Linux系统中钩子的使用方法"},{"categories":["算法"],"contents":"本文介绍拓扑排序的原理和代码实现。\n1 拓扑排序的基本原理 能够使用拓扑排序的图一定是一个有向无环图(DAG, Directed Acyclic Graph)。若是一个有向有环图，则任务无法完成，存在循环依赖问题。\n2 拓扑排序的代码实现 2.1 使用深度优先遍历 2.2 使用广度优先遍历 2.3 课程表 课程表相关的LeetCode题目:\n207. 课程表\n210. 课程表 II\n2050. 并行课程 III\n2.3.1 207. 课程表 保存每个结点的入度数量； 保存每个结点的出度结点； 每次将入度为0的结点添加至队列，出队列时，将其关联的出度结点的入度减1； 当遍历完所有结点时，若存在入度不为0的结点，说明这个图存在环，任务无法完成；否则任务可以完成； 实际上该算法是用于判断这个有向图是否存在环。拓扑排序要求图为有向图无环。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class Solution { public: bool canFinish(int numCourses, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; prerequisites) { vector\u0026lt;int\u0026gt; indegree(numCourses, 0); unordered_map\u0026lt;int, vector\u0026lt;int\u0026gt;\u0026gt; outdegreeNode; // init indegree and outdegreeNode for (int i = 0; i \u0026lt; prerequisites.size(); ++i) { int out = prerequisites[i][0]; int in = prerequisites[i][1]; indegree[out]++; outdegreeNode[in].push_back(out); } queue\u0026lt;int\u0026gt; que; int count = numCourses; // node count for (int i = 0; i \u0026lt; numCourses; ++i) { if (indegree[i] == 0) { indegree[i] = -1; que.push(i); --count; } } while (!que.empty() \u0026amp;\u0026amp; count != 0) { int front = que.front(); que.pop(); for (int item : outdegreeNode[front]) { if (indegree[item] \u0026gt; 0) { --indegree[item]; if (indegree[item] == 0) { indegree[item] = -1; que.push(item); --count; } } } } return count == 0; } }; 2.3.2 210. 课程表 II 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 bool canFinish(int numCourses, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; prerequisites) { vector\u0026lt;int\u0026gt; indegree(numCourses, 0); unordered_map\u0026lt;int, vector\u0026lt;int\u0026gt;\u0026gt; outdegreeNode; // init indegree and outdegreeNode for (int i = 0; i \u0026lt; prerequisites.size(); ++i) { int out = prerequisites[i][0]; int in = prerequisites[i][1]; indegree[out]++; outdegreeNode[in].push_back(out); } queue\u0026lt;int\u0026gt; que; int count = numCourses; // node count for (int i = 0; i \u0026lt; numCourses; ++i) { if (indegree[i] == 0) { indegree[i] = -1; que.push(i); --count; } } while (!que.empty() \u0026amp;\u0026amp; count \u0026gt;= 0) { int front = que.front(); que.pop(); for (int item : outdegreeNode[front]) { if (indegree[item] \u0026gt; 0) { --indegree[item]; if (indegree[item] == 0) { indegree[item] = -1; que.push(item); --count; } } } } if (count == 0) { return res; } return {}; } 2.3.3 2050. 并行课程 III 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 int minimumTime(int n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; relations, vector\u0026lt;int\u0026gt;\u0026amp; time) { vector\u0026lt;int\u0026gt; indegree(n+1, 0); vector\u0026lt;int\u0026gt; indegreeMaxTime(n+1, 0); // 记录每个结点的入度结点中的最大值 unordered_map\u0026lt;int, vector\u0026lt;int\u0026gt;\u0026gt; outdegreeNode; vector\u0026lt;int\u0026gt; node_time(time.begin(), time.end()); // init indegree and outdegreeNode for (int i = 0; i \u0026lt; relations.size(); ++i) { int in = relations[i][0]; int out = relations[i][1]; indegree[out]++; indegreeMaxTime[out] = max(indegreeMaxTime[out], node_time[in-1]); outdegreeNode[in].push_back(out); } queue\u0026lt;int\u0026gt; que; for (int i = 1; i \u0026lt;= n; ++i) { if (indegree[i] == 0) { indegree[i] = -1; que.push(i); } } while (!que.empty()) { int front = que.front(); que.pop(); node_time[front-1] = indegreeMaxTime[front] + node_time[front-1]; for (int item : outdegreeNode[front]) { if (indegree[item] \u0026gt; 0) { --indegree[item]; indegreeMaxTime[item] = max(indegreeMaxTime[item], node_time[front-1]); if (indegree[item] == 0) { indegree[item] = -1; que.push(item); } } } } return *max_element(node_time.begin(), node_time.end()); } ","date":"2024-12-13T12:07:28+08:00","permalink":"http://localhost:1313/post/data_structure/graph/topological_sorting/","tags":["有向图","拓扑排序"],"title":"拓扑排序"},{"categories":["CPP"],"contents":"本文总结C++中容易混淆的概念。\n1 常见易混淆知识点 1.1 内存控制 1.1.1 malloc/free, new/delete的区别 malloc和free是C/C++语言的标准库函数,而new/delete是C++的运算符。它们都可以用于动态申请和释放内存。 new/delete运算符不仅可以申请/释放内存，还可以对申请的对象进行初始化和销毁操作。 C++既可以使用new/delete，也可以调用malloc/free。而C语言只能用malloc/free管理动态内存。 1.1.2 new/delete new/delete就是C++的运算符。new的全称为new operator, delete的全称为delete operator。其作用是为分配并初始化一个对象数组。\nC++执行new操作实际上后台执行了以下3步操作： 调用operate new或者operate new []的标准库函数。该函数分配一块原始的、足够大的、未命名的存储特定类型对象的空间； 编译器运行相应的构造函数以构造这些特定对象(或对象数组)； 对象被构造完成并分配的空间，返回一个指向该对象的指针。 C++执行delete操作实际上后台执行了以下2步操作：\n对所指向的对象或者对象数组执行对应的析构函数； 编译器调用operate delete(或者operate delete[])的标准库函数释放内存空间。 使用示例：\n1 2 3 4 5 int* p = new int; delete p; int* pa = new int[10]; delete [] pa; 1.1.3 operate new/delete operate new/delte是C++的标准函数。用于用于为特定类型的对象分配或者释放内存空间。operate new/delete的函数原型定义如下： 1 2 3 4 5 6 7 8 9 10 void* operate new(size_t); // 分配一个对象 void* operate new[](size_t); // 分配一个对象数组 void* operate delete(void*) noexpect; // 释放一个对象 void* operate delete[](void*) noexpect; // 释放一个对象数组 // 不会抛出异常的函数，功能同上 void* operate new(size_t, nothrow_t\u0026amp;) noexpect; void* operate new[](size_t, nothrow_t\u0026amp;) noexpect; void* operate delete(void*, nothrow_t\u0026amp;) noexpect; void* operate delete[](void*, nothrow_t\u0026amp;) noexpect; 如果应用程序希望自己控制内存的分配和释放，就需要自己定义operate new和operate delete函数，从而让编译器使用自定义的版本替换标准库中定义的版本。 应用程序可以在全局作用域中定义oprerate new/delete函数或者定义为类的成员函数。\n如果分配或者释放的的对象是类对象，则首先在类中查找是否有自定义的oprerate new/delete函数。若没查找到，再到全局作用域中查找。\n我们也可以直接指定查找全局作用域的函数：使用::new ::delete可以指定查找全局作用域的函数。 因为operate new用在构造函数之前而operate delete用在对象销毁之后，所以这两个成员函数必须是静态函数，而且不能操作类的任何数据成员。\n例外：不能重载以下形式的operate new函数：\n1 void* operate new(size_t, void*); 这种形式只供标准库使用，不能被用户重新定义。\n温馨提示：\n实际上C++也有和operate new/delete功能相似的标准库allocator类，用于为指定类型的对象分配内存。它非配的内存是原始、未构造的。\n1.1.4 placement new placement new用于对使用operate new的方式申请的内存上构造对象。placement new的几种形式：\n1 2 3 4 new (place_address) type new (place_address) type (initializers) new (place_address) type [size] new (place_address) type [size] {braced initializer list} 其中place_address必须是一个指针，同时在initializers中提供一个(可能为空)的逗号分隔的初始化列表，该初始值列表用于构造新分配的对象。\n1.1.5 智能指针 1.1.5.1 shared_ptr 1.1.5.2 unique_ptr 1.1.5.3 weak_ptr 1.2 指针与引用的区别 指针本身就是一个对象，其内容是某个内存单元的地址，允许对指针赋值和拷贝；而引用并非对象，它只是一个已经存在的对象的一个别名。 指针在它的生命周期内可以指向不同的对象；而引用一旦初始化完成，将和它的初始值始终绑定在一起。 指针无须在定义时赋初值；而引用必须初始化，绑定到一个已经存在的对象。指针可以为空，但引用不可以。 sizeof操作指针和引用的结果不同；sizeof操作引用得到的是引用所绑定的对象的大小；而sizeof操作指针得到的是指针本身的大小。 引用是类型安全的，而指针不是。 1.3 struct和class的区别 struct的成员(成员函数和数据成员)的访问控制属性默认是共有的；而class的成员默认是私有的。 struct的继承默认是共有继承，而class的默认继承方式是私有的。 1.4 const修饰常量与define的区别 const定义的常量在编译阶段进行处理；#define定义的常量在预处理阶段进行处理； const定义的常量要进行类型检查；#define定义的常量只是简单的文本替换，没有类型，不进行类型检查； const定义的常量要分配内存；#define定义的常量为宏定义，不需要分配内存； const定义的常量存放在数据区，只有一份拷贝；#define定义的常量不分配存储空间，使用过程中只是简单的执行文本替换； 1.5 重载覆盖隐藏的区别 1.5.1 重载 重载的特点：\n相同的范围（在同一个类中） 函数名字相同 参数不同 virtual 关键字可有可无 1.5.2 覆盖 覆盖是指派生类函数覆盖基类虚函数。其特征为：\n不同的范围（分别位于派生类与基类）； 函数名字相同 参数相同 基类函数必须有virtual 关键字 1.5.3 隐藏 “隐藏”是指派生类的函数屏蔽了与其同名的基类函数，规则如下：\n如果派生类的函数与基类的函数同名，但是参数不同。此时，不论有无virtual关键字，基类的函数将被隐藏（注意别与重载混淆）。 如果派生类的函数与基类的函数同名，并且参数也相同而且基类函数没有virtual 关键字。此时，基类的函数被隐藏（注意别与覆盖混淆） 1.5.4 覆盖隐藏的示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 class Base { public: virtual void fcn() { cout \u0026lt;\u0026lt; \u0026#34;This is Base fcn().\u0026#34; \u0026lt;\u0026lt; endl; } }; class FristDerived : public Base { public: // FristDerived继承Base中的虚函数fcn() // 形参与Base::fcn()中的不一致，隐藏基类的fcn() void fcn(int) { cout \u0026lt;\u0026lt; \u0026#34;This is FristDerived fcn().\u0026#34; \u0026lt;\u0026lt; endl; } // 新增一个虚函数，在Base中不存在 virtual void display() { cout \u0026lt;\u0026lt; \u0026#34;This is FristDerived display().\u0026#34; \u0026lt;\u0026lt; endl; } }; class SecondDerived : public FristDerived { public: // 隐藏FristDerived::fcn(int) void fcn(int a) { cout \u0026lt;\u0026lt; \u0026#34;This is SecondDerived fcn(\u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34;).\u0026#34; \u0026lt;\u0026lt; endl; } void fcn() { // 覆盖Base中的虚函数fcn() cout \u0026lt;\u0026lt; \u0026#34;This is SecondDerived fcn().\u0026#34; \u0026lt;\u0026lt; endl; } void display() { // 覆盖FristDerived中的虚函数display()函数 cout \u0026lt;\u0026lt; \u0026#34;This is SecondDerived display().\u0026#34; \u0026lt;\u0026lt; endl; } }; int main() { Base base_obj; FristDerived fd_obj; SecondDerived sd_obj; Base* bp1 = \u0026amp;base_obj; Base* bp2 = \u0026amp;fd_obj; Base* bp3 = \u0026amp;sd_obj; bp1-\u0026gt;fcn(); // Base::fcn() bp2-\u0026gt;fcn(); // Base::fcn() bp3-\u0026gt;fcn(); // SecondDerived::fcn() cout \u0026lt;\u0026lt; \u0026#34;----------\u0026#34; \u0026lt;\u0026lt; endl; FristDerived* fd = \u0026amp;fd_obj; SecondDerived* sd = \u0026amp;sd_obj; // bp2-\u0026gt;display(); // 错误，Base没有display()函数 fd-\u0026gt;display(); // FristDerived::display() sd-\u0026gt;display(); // SecondDerived::display() return 0; } ","date":"2024-12-13T12:06:32+08:00","permalink":"http://localhost:1313/post/cpp/cpp_interview_knowledge/","tags":[""],"title":"C++中一些易混淆的基础知识"},{"categories":["Linux"],"contents":"本文介绍进程打印堆栈的原理。\n1.1 涉及结构体 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 struct dl_phdr_info { ElfW(Addr) dlpi_addr; /* Base address of object */ const char *dlpi_name; /* (Null-terminated) name of object */ const ElfW(Phdr) *dlpi_phdr; /* Pointer to array of ELF program headers for this object */ ElfW(Half) dlpi_phnum; /* # of items in dlpi_phdr */ /* The following fields were added in glibc 2.4, after the first version of this structure was available. Check the size argument passed to the dl_iterate_phdr callback to determine whether or not each later member is available. */ unsigned long long dlpi_adds; /* Incremented when a new object may have been added */ unsigned long long dlpi_subs; /* Incremented when an object may have been removed */ size_t dlpi_tls_modid; /* If there is a PT_TLS segment, its module ID as used in TLS relocations, else zero */ void *dlpi_tls_data; /* The address of the calling thread\u0026#39;s instance of this module\u0026#39;s PT_TLS segment, if it has one and it has been allocated in the calling thread, otherwise a null pointer */ }; typedef struct { Elf32_Word p_type; /* Segment type */ Elf32_Off p_offset; /* Segment file offset */ Elf32_Addr p_vaddr; /* Segment virtual address */ Elf32_Addr p_paddr; /* Segment physical address */ Elf32_Word p_filesz; /* Segment size in file */ Elf32_Word p_memsz; /* Segment size in memory */ Elf32_Word p_flags; /* Segment flags */ Elf32_Word p_align; /* Segment alignment */ } Elf32_Phdr; typedef struct { Elf64_Word st_name; /* Symbol name */ unsigned char st_info; /* Symbol type and binding */ unsigned char st_other; /* Symbol visibility */ Elf64_Section st_shndx; /* Section index */ Elf64_Addr st_value; /* Symbol value */ Elf64_Xword st_size; /* Symbol size */ } Elf64_Sym; typedef struct { const char *dli_fname; /* Pathname of shared object that contains address */ void *dli_fbase; /* Base address at which shared object is loaded */ const char *dli_sname; /* Name of symbol whose definition overlaps addr */ void *dli_saddr; /* Exact address of symbol named in dli_sname */ } Dl_info; typedef struct { size_t dls_size; /* Size in bytes of the whole buffer */ unsigned int dls_cnt; /* Number of elements in \u0026#39;dls_serpath\u0026#39; */ Dl_serpath dls_serpath[1]; /* Actually longer, \u0026#39;dls_cnt\u0026#39; elements */ } Dl_serinfo; typedef struct { char *dls_name; /* Name of library search path directory */ unsigned int dls_flags; /* Indicates where this directory came from */ } Dl_serpath; struct link_map { ElfW(Addr) l_addr; /* Difference between the address in the ELF file and the address in memory */ char *l_name; /* Absolute pathname where object was found */ ElfW(Dyn) *l_ld; /* Dynamic section of the shared object */ struct link_map *l_next, *l_prev; /* Chain of loaded objects */ /* Plus additional fields private to the implementation */ }; 1.2 涉及接口 1 2 3 4 5 6 7 8 #include \u0026lt;dlfcn.h\u0026gt; int dl_iterate_phdr(int (*callback)(struct dl_phdr_info *info, size_t size, void *data), void *data); void *dlopen(const char *filename, int flags); void *dlsym(void *restrict handle, const char *restrict symbol); int dlclose(void *handle); int dladdr(const void *addr, Dl_info *info); int dlinfo(void *restrict handle, int request, void *restrict info); char *dlerror(void); ","date":"2024-12-12T16:48:23+08:00","permalink":"http://localhost:1313/post/linux/backtrace/","tags":["ELF","backtrace"],"title":"Linux系统中进程打印堆栈的原理"},{"categories":["Linux"],"contents":"本文介绍并发程序中经常遇到的几个经典问题以及解决方法。\n1 Thundering herd problem(惊群效应) 解决方法：\nEvent Multiplexing: Use event-driven programming models (e.g., select, poll, epoll in Linux) that allow a single thread or process to handle multiple events.\nLoad Distribution: Distribute the load more evenly among multiple processes or threads using techniques like load balancers. Load balancing involves distributing incoming requests across multiple servers to prevent any one server from becoming overwhelmed. By distributing the load across multiple servers, the likelihood of a thundering herd problem occurring can be reduced.\nSerialized Access: Implement locking mechanisms or use queueing to serialize access to the shared resource, ensuring that only one process or thread handles the event at a time. Queuing: Queuing involves placing incoming requests in a queue and processing them in a controlled and orderly manner. By queuing requests, the load on the resource can be controlled, and the likelihood of a thundering herd problem occurring can be minimized.\nRate Limiting: Introduce rate limits to control the frequency at which processes or threads are woken up. Throttling involves limiting the rate at which requests are processed. By limiting the rate at which requests are processed, the load on the resource can be controlled, and the likelihood of a thundering herd problem occurring can be minimized.\nConnection pooling: Connection pooling involves reusing existing connections to a resource rather than creating a new connection for each request. By reusing existing connections, the load on the resource can be reduced, and the likelihood of a thundering herd problem occurring can be minimized.\n2 lock problem 2.1 deadlock(死锁) 2.2 livelock(活锁) 活锁产生的背景是：若获取多个锁时，若无法获取全部的锁时，会释放已经持有的锁，防止死锁。\n下面考虑这种场景：\n线程1(t1)需要获取lock1和lock2才能工作。线程2(t2)也需要获取lock1和lock2才能工作。\nt1先拿到lock1,尝试去获取lock2；t2先拿到lock2,尝试获取lock1;如果t1获取lock1和t2获取到lock2是同时发生的，他们在尝试获取另外一个锁时都会失败，然后同时释放自己的锁后重新按照原流程进程尝试。这样就会导致两个线程一直重试而无法继续进行。\n活锁类似于生活中两个有礼貌的人让路的场景：两个人都很客气的让路给对方，但是两人同时移动到同一侧，又继续冲突，再移动回来又冲突，一直这样持续下去，那么就会发生活锁。\n2.3 Starvation(饿死) 2.3 Lock convoy 2.5 Pessimistic Concurrency Control(悲观锁) 悲观锁策略：认为修改读写数据是不安全的，需要在操作数据前加锁，操作完数据后再解锁。也就是传统意义上的加锁动作。\n2.6 Optimistic Concurrency Control(乐观锁) 乐观锁的策略：乐观锁在更新数据前先获暂存数据，然后执行修改数据的操作。\n在将数据写回时，确认数据是否被修改，若数据被修改，就放弃更新的动作。\n乐观锁，一般用在数据冲突比较小的场景。\n2.7 False Sharing(伪共享) 2.4 Non-blocking algorithm 2.4.1 ring buffer FIFO a single-reader single-writer\n2.4.2 disruptor 2.4.2.1 disruptor 的原理介绍 How the Disruptor works and how to use it\ndisruptor的原理中文翻译\n2.4.2.2 disruptor的ringbuffer结构 内部结构为数组实现的环状队列，大小一般设置为$2^n$个，这样可以通过使用\u0026amp;运算替代%运算，加快计算速度。例如对于有8($2^3$)个数据的环状队列。 只需要将数字编号n\u0026amp;7(8-1)即可得访问对应的内容。 其中的数据的编号从0开始，不断增长。随着你不停地填充这个buffer（可能也会有相应的读取），这个序号会一直增长，直到绕过这个环。 2.4.2.3 从ring Buffer中读数据的原理 假设Ring Buffer中已经写入了一些数据，如下图所示，怎样从Ring Buffer读出这些数据呢？ 这里增加几个基本概念：\n消费者(Consumer)：消费者(Consumer)是一个想从Ring Buffer里读取数据的线程。就像Ring Buffer需要一个序号才能找到下一个可用节点一样，消费者也需要知道它将要处理的序号——每个消费者都需要找到下一个它要访问的序号。　ConsumerBarrier对象： ConsumerBarrier是消费者和Ring Buffer沟通的桥梁，用于两者之间的通信。 这个对象由RingBuffer创建并且代表消费者与RingBuffer进行交互。\n消费者可以调用ConsumerBarrier对象的waitFor()方法，传递它所需要的下一个序号.\n1 final long availableSeq = consumerBarrier.waitFor(nextSequence); 在上面的例子中，消费者处理完了Ring Buffer里序号8之前（包括8）的所有数据，那么它期待访问的下一个序号是9。 但是ConsumerBarrier从RingBuffer获取到的最大可访问序号是12。如下图所示： 注意：\n对于这个环状队列，其中的编号要经过对环的大小取余，才是其实际的编号。\n针对该示例，RingBuffer返回的最大可访问序列号是12（实际对应的数组编号是2），而消费者期望访问的编号是9。 所以消费者需要等待数据填充到9以及已有的区域时才可以访问。（实际分析问题是，可以认为只能按照顺时针去访问数据，不能逆时针访问。）\nConsumerBarrier有一个WaitStrategy方法来决定它如何等待这个序号\n接下来怎么做？\n接下来消费者会一直原地停留，等待更多数据被写入Ring Buffer。并且一旦数据写入后消费者会收到通知——节点9，10，11和12 已写入。现在序号12到了，消费者可以让ConsumerBarrier去拿这些序号节点里的数据了。如下图所示：\n2.4.2.4 向ringbuffer中写数据的原理","date":"2024-12-11T16:11:22+08:00","permalink":"http://localhost:1313/post/linux/linux_some_typical_problem/","tags":[""],"title":"并发编程中常见的问题"},{"categories":["数据结构"],"contents":"本文描述如何使用C语言实现一个队列的功能，展示如何使用数组、链表结构实现队列的方法。\n1 队列的基本功能 队列的基本功能包括：创建队列、销毁队列、判断队列是否为空、进队列、出队列、获取队列中的元素个数、获取队列头部元素、获取队列尾部元素。\n2 使用单链表实现队列 实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 struct Node { int val; struct Node* next; }; typedef struct Node Node; typedef struct { Node* head; Node* tail; int size; } myQueue; myQueue* initQueue(void) { // init head Node* node = (Node*)malloc(sizeof(Node)); if (!node) { printf(\u0026#34;Init que head node failed, not mem.\\n\u0026#34;); return NULL; } node-\u0026gt;val = -1; node-\u0026gt;next = NULL; // init queue myQueue* queue = (myQueue*)malloc(sizeof(myQueue)); if (!queue) { printf(\u0026#34;Init que failed, not mem.\\n\u0026#34;); return NULL; } queue-\u0026gt;head = node; queue-\u0026gt;tail = node; queue-\u0026gt;size = 0; return queue; } void destroyLinklist(Node* head) { while (head) { Node* next = head-\u0026gt;next; free(head); head = next; } } void destroyQueue(myQueue* que) { if (que) { destroyLinklist(que-\u0026gt;head); que-\u0026gt;size = 0; free(que); } } int isQueueEmpty(myQueue* que) { return que-\u0026gt;size == 0; } int getQueueSize(myQueue* que) { return que-\u0026gt;size; } void pushQueue(myQueue* que, int value) { Node* node = (Node*)malloc(sizeof(Node)); if (!node) { return; } node-\u0026gt;val = value; node-\u0026gt;next = NULL; que-\u0026gt;tail-\u0026gt;next = node; que-\u0026gt;tail = node; ++(que-\u0026gt;size); } void popQueue(myQueue* que) { if (isQueueEmpty(que)) { return; } Node* cur = que-\u0026gt;head-\u0026gt;next; que-\u0026gt;head-\u0026gt;next = cur-\u0026gt;next; if (que-\u0026gt;tail == cur) { que-\u0026gt;tail = que-\u0026gt;head; } free(cur); --(que-\u0026gt;size); } int getQueueFront(myQueue* que) { if (isQueueEmpty(que)) { return -1; } return que-\u0026gt;head-\u0026gt;next-\u0026gt;val; } int getQueueTail(myQueue* que) { if (isQueueEmpty(que)) { return -1; } return que-\u0026gt;tail-\u0026gt;val; } void printQueue(myQueue* que) { Node* head = que-\u0026gt;head-\u0026gt;next; printf(\u0026#34;que:\u0026#34;); while (head != que-\u0026gt;tail) { printf(\u0026#34;[%d|-]-\u0026gt;\u0026#34;, head-\u0026gt;val); head = head-\u0026gt;next; } printf(\u0026#34;[%d|^].\\n\u0026#34;, que-\u0026gt;tail-\u0026gt;val); } void reverseQueue(myQueue* que) { if (isQueueEmpty(que)) { return; } Node* front = que-\u0026gt;head-\u0026gt;next; if (front != que-\u0026gt;tail) { que-\u0026gt;head-\u0026gt;next = front-\u0026gt;next; front-\u0026gt;next = NULL; que-\u0026gt;tail-\u0026gt;next = front; que-\u0026gt;tail = front; } } 3 使用数组实现队列(环形队列) 实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 #define QUE_LEN 100 typedef struct { int arr[QUE_LEN]; int front; int tail; int size; int capacity; } myQueue; myQueue* initQueue(void) { // init queue myQueue* queue = (myQueue*)malloc(sizeof(myQueue)); if (!queue) { printf(\u0026#34;Init que failed, not mem.\\n\u0026#34;); return NULL; } queue-\u0026gt;front = 0; queue-\u0026gt;tail = 0; queue-\u0026gt;size = 0; queue-\u0026gt;capacity = QUE_LEN; return queue; } void destroyQueue(myQueue* que) { if (que) { que-\u0026gt;size = 0; free(que); } } int isQueueEmpty(myQueue* que) { return (que-\u0026gt;size == 0 \u0026amp;\u0026amp; que-\u0026gt;front == que-\u0026gt;tail); } int isQueueFull(myQueue* que) { return (que-\u0026gt;size == que-\u0026gt;capacity \u0026amp;\u0026amp; que-\u0026gt;front == que-\u0026gt;tail); } int getQueueSize(myQueue* que) { return que-\u0026gt;size; } void pushQueue(myQueue* que, int value) { if (isQueueFull(que)) { return; } int capacity = que-\u0026gt;capacity; int tail = que-\u0026gt;tail; que-\u0026gt;arr[tail] = value; que-\u0026gt;tail = (tail + 1) % capacity; ++(que-\u0026gt;size); } void popQueue(myQueue* que) { if (isQueueEmpty(que)) { return; } int front = que-\u0026gt;front; que-\u0026gt;front = (front + 1) % que-\u0026gt;capacity; --(que-\u0026gt;size); } int getQueueFront(myQueue* que) { if (isQueueEmpty(que)) { return -1; } int front = que-\u0026gt;front; return que-\u0026gt;arr[front]; } int getQueueTail(myQueue* que) { if (isQueueEmpty(que)) { return -1; } int tail = (que-\u0026gt;tail + que-\u0026gt;capacity - 1) % que-\u0026gt;capacity; return que-\u0026gt;arr[tail]; } void printQueue(myQueue* que) { if (isQueueEmpty(que)) { printf(\u0026#34;que is empty().\\n\u0026#34;); return; } printf(\u0026#34;queue:\u0026#34;); for (int i = 0; i \u0026lt; que-\u0026gt;size; ++i) { int front = (que-\u0026gt;front + i) % que-\u0026gt;capacity; printf(\u0026#34;|%d\u0026#34;, que-\u0026gt;arr[front]); } printf(\u0026#34;|.\\n\u0026#34;); } void reverseQueue(myQueue* que) { if (isQueueEmpty(que)) { return; } if (isQueueFull(que)) { que-\u0026gt;front = (que-\u0026gt;front + 1) % que-\u0026gt;capacity; que-\u0026gt;tail = (que-\u0026gt;tail + 1)% que-\u0026gt;capacity; return; } int front = getQueueFront(que); popQueue(que); pushQueue(que, front); } ","date":"2024-12-10T10:39:32+08:00","permalink":"http://localhost:1313/post/data_structure/queue/implement_a_queue/","tags":["队列","环形队列"],"title":"C语言实现一个队列的功能"},{"categories":["数据结构"],"contents":"本文描述如何使用C语言实现一个栈的功能。\n1 栈的基本功能 栈的基本功能包括：创建栈、销毁栈、判断栈是否为空、进栈、出栈、获取栈中的元素个数、获取栈顶元素。\n2 使用数组实现一个固定大小的栈 实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 #define SIZE 101 typedef struct { int arr[SIZE]; int size; } myStack; myStack* stack_init(void) { myStack* stk = (myStack*)malloc(sizeof(myStack)); if (stk == NULL) { return NULL; } memset(stk, 0, sizeof(myStack)); return stk; } int stack_is_empty(myStack* stk) { return (stk-\u0026gt;size == 0); } int get_stack_size(myStack* stk) { return stk-\u0026gt;size(); } void push_stack(myStack* stk, int val) { int idx = stk-\u0026gt;size; stk-\u0026gt;arr[idx] = val; ++(stk-\u0026gt;size); } void pop_stack(myStack* stk) { if (stack_is_empty(stk)) { return; } --(stk-\u0026gt;size); } int get_stack_top(myStack* stk) { if (stack_is_empty) { return -1; } int idx = stk-\u0026gt;size; return stk-\u0026gt;arr[idx-1]; } void destroy_stack(myStack* stk) { if (stk) { stk-\u0026gt;size = 0; free(stk); stk = NULL; } } ","date":"2024-12-10T10:39:32+08:00","permalink":"http://localhost:1313/post/data_structure/stack/implement_a_stack/","tags":["栈"],"title":"C语言实现一个栈的功能"},{"categories":["算法"],"contents":"本文总结动态规划算法的原理和使用场景。\n1 动态规划问题的特征 具有最优子结构 子结构之间存在依赖关系。 是用来求解最优解的问题的，因此符合上面两条，然后存在最大(多/少)等字眼的，可以尝试用动态规划求解。 2 动态规划问题的求解步骤 定义子问题 写出状态转移方程 确定计算顺序(top-down/down-top)：大多数都是采用自底向上的方法。 ","date":"2024-12-08T16:05:29+08:00","permalink":"http://localhost:1313/post/algorithm/dynamic_programming/","tags":["动态规划"],"title":"动态规划"},{"categories":["Linux"],"contents":"本文介绍进程间同步的3种方法，分别是文件锁，信号量和互斥量。 并且介绍它们是如何实现进程间同步的。\n1.1 文件锁（记录锁） 文件锁，在APUE中称为记录锁（record locking)，是保证某一时刻只有一个进程修改文件中的一个指定区域的锁。\n1.1.1 fcntl() fcntl()函数原型：int fcntl(int fd, int cmd, struct flock* fllockptr)。\n对于函数fcntl()来说，记录锁是通过cmd来控制的。记录锁的对应的cmd有：F_GETLK，F_SETLK和F_SETLKW。\nflock结构体的定义如下：\n1 2 3 4 5 6 7 struct flock { short l_type; /* F_RDLCK, F_WRLCK, F_UNLCK */ short l_whence; /* SEEK_SET, SEEK_CUR, SEEK_END */ short l_start; /* offset in bytes, relative to l_whence */ short l_len; /* length, in byte, 0 means lock of EOF */ short l_pid; /* returned with F_GETLK */ } flock结构中各个成员的含义说明：\nl_type表示文件锁的类型：F_RDLCK表示共享读锁, F_WRLCK为独占写锁, F_UNLCK为解锁指定文件区域\nl_whence, l_start和lseek()中的whence、offset功能相同；\n1.1.2 文件锁的使用方法 对整个文件加锁的方法：将l_start和l_len都设置为0, l_whece设置为SEEK_SET。\n如果一个进程对一个文件区域已经加了锁，后续如果该进程再次对同一区域再次加锁。则新锁将替换已持有的锁。\n加读锁时，该文件描述符必须是读打开的。加写锁时，该描述符必须是写打开的。\nfcntl函数中，文件锁三种参数的的说明：\nF_GETLK：判断对flockptr指定的文件区域加锁是否可以会被阻塞。\nF_SETLK：尝试获取一把锁，若无法获取锁，则返回错误码EACCES，EAGAIN。\nF_SETLKW：这个命令是F_SETLK的阻塞版本（w表示wait)。锁所设置的文件区域已经加锁而我们又无法获取该锁时，那么当前进程会被阻塞。只有等请求的锁可用或者休眠被信号中断，该进程才会被唤醒。\n1.1.3 文件锁的继承和释放 文件锁和进程、文件关联。以下几种场景都会关闭文件锁。\n进程退出：当一个进程退出时，它所建立的锁全部关闭。 文件关闭：文件描述符关闭，则该文件关联的锁全部关闭。 由fork创建的子进程不继承父进程设置的锁。\n在执行exec后，新程序可以继承原执行程序的锁。但是，如果文件设置了(O_CLOEXEC)。\n1.2 信号量 信号量的使用方法见进程间通信文章中的相关内容。\n1.3 互斥量 使用互斥量在多个进程之间实现同步，需要做如下处理：\n多个进程之间需要使用共享内存。\n互斥量需要在共享内存中中初始化；\n互斥量的属性需要设置为PTHREAD_PROCESS_SHARED。\n进程间使用互斥量的示例如下：\n","date":"2024-12-07T17:59:12+08:00","permalink":"http://localhost:1313/post/linux/apue/process_synchronization/","tags":["APUE","进程同步"],"title":"进程同步的方法"},{"categories":["Linux"],"contents":"本文说明UNIX系统中常见的几种标准，以及它们之间的关系。\n1.1 ISO C ISO C是C语言的标准。 ISO C标准现在有ISO/IEC的C程序设计语言国际标准工作组开发和维护。\nISO C标准的目的是提供C程序的可移植性，使其能适合于大量不同的操作系统，而不仅仅是UNIX系统。\n1.2 POSIX POSIX最初是由IEEE指定的标准。该标准的目的是提升应用程序在各种UNIX系统环境之间的可移植性。POSIX标准经过不断演进，发展出很多后续版本。本书统称为POSIX.1。\n1.2.1 XSI POSIX中的XSI(X/Open System Interface)选项描述了POSXI.1中可选接口和定义，以及它们要实现的内容。\n1.3 SUS SUS(Single UNIX Specification)。可以认为POSIX是SUS的子集。它定义了一些附加接口用于扩展POSIX.1规范的功能。POSIX.1相当于SUS中的基本规范。\n1.4 专业术语 ANSI: American National Standards Institute BSD: Berkeley Softwar eDistribution CAE: Common Application Environment COSE: Common Open Software Environment IEC: International Electrotechnical Commission IEEE: Institute of Electrical and Electronics Engineers ISO: International Organization for Standardization OSF: Open Softwar eFoundation POSIX: Portable Operating System Interface SUS: Single UNIX Specification SVID: System V Interface Definition SVR4: UNIX System V Release 4 USL: UNIX System Laboratories XSI: X/Open System Interface ","date":"2024-12-07T17:41:42+08:00","permalink":"http://localhost:1313/post/linux/apue/unix_standardization/","tags":["APUE","UNIX标准"],"title":"UNIX标准说明"},{"categories":["算法"],"contents":"本文介绍贪心算法的原理和实际应用，以及解决贪心算法的常见思路。\n1.3 贪心算法的典型应用 1.3.1 找零钱问题 1.3.1 背包问题 1.3.1 0-1背包问题 1.3.2 完全背包问题 1.3.2 Dijkstra’s algorithm 1.3.3 Kruskal’s algorithm 1.3.4 Huffman coding 1.3.5 Prim’s Algorithm","date":"2024-12-06T09:48:43+08:00","permalink":"http://localhost:1313/post/algorithm/greedy_algorithm/","tags":["贪心算法"],"title":"贪心算法"},{"categories":["Linux"],"contents":"本文总结UNIX环境中一个进程是如何启动和终止的，如何向进程传递参数表和环境变量。\n还介绍了进程内部的存储空间布局方式。\n1.1 main函数 1.2 进程退出的方式 1.3 C程序的内存空间布局 UNIX系统中C程序的内存布局如下图所示:\n程序中各部分的内容说明如下：\n正文段(Text Segment): 该部分包含了CPU执行的机器指令。通常这个段的内容是可共享、在内存中频繁被执行的单副本程序。通常正文段是只读的，以防止被修改。 已初始化数据段(Initialized Data Segment): 它包含了程序中已明确初始化的变量。例如，明确初始化的全局变量。 未初始化数据段(Uninitialized Data segment): 通常称为bss(block started by symbol)段。在程序开始执行前，内核将此段中的变量数据初始化为0或者空指针。例如，未初始化的全局变量。 栈(stack): 存放函数中的临时变量，函数的参数以及函数返回地址等。 堆(heap): 动态分配的内存存放在堆区。堆区在未初始化数据段的上方。 只有正文段和已初始化的数据段是存放在磁盘中。\n通过size命令可以查看二进制各个区域占用的大小。例如查看bash二进制的各个区域大小：size /usr/bin/bash\n1.4 存储空间分配 1.5 共享库","date":"2024-12-05T22:37:40+08:00","permalink":"http://localhost:1313/post/linux/apue/process_environment/","tags":["APUE","存储空间布局","环境变量"],"title":"进程环境"},{"categories":["Linux"],"contents":"本文总结Linux环境中的信号相关知识以及和信号相关的接口的使用方法。\n1.1 信号的基本概念 信号是软中断的一种，是典型的异步事件处理机制之一。因为产生信号的时间时随机出现的，没有任何规律。\n当某个信号出现时，可以告诉内核按照如下3种方式处理，称为信号处理：\n忽略信号\n大多数信号可以采用这种方式。但是SIGKILL(9)和SIGSTOP(19)这两个信号不能忽略。\n捕捉信号 为了捕捉信号，需要通知内核在某种信号发生时，调用一个用户函数。在用户函数中，用户事先定制了该信号发生时要执行的操作。\n执行系统的默认动作\n操作系统为每种信号设置默认的操作。但是大多数信号的系统默认操作都是终止进程。\n1.2 异步信号安全函数(可重入) 不可重入函数的特征：\n使用了静态数据结构的函数 调用malloc()或free()的函数 标准IO函数 1.2.1 Linux系统异步信号安全函数 abort faccessat linkat select socketpair accept fchmod listen sem_post stat access fchmodat lseek send symlink aio_error fchown lstat sendmsg symlinkat aio_return fchownat mkdir sendto tcdrain aio_suspend fcntl mkdirat setgid tcflow alarm fdatasync mkfifo setpgid tcflush bind fexecve mkfifoat setsid tcgetattr cfgetispeed fork mknod setsockopt tcgetpgrp cfgetospeed fstat mknodat setuid tcsendbreak cfsetispeed fstatat open shutdown tcsetattr cfsetospeed fsync openat sigaction tcsetpgrp chdir ftruncate pause sigaddset time chmod futimens pipe sigdelset timer_getoverrun chown getegid poll sigemptyset timer_gettime clock_gettime geteuid posix_trace_event sigfillset timer_settime close getgid pselect sigismember times connect getgroups raise signal umask creat getpeername read sigpause uname dup getpgrp readlink sigpending unlink dup2 getpid readlinkat sigprocmask unlinkat execl getppid recv sigqueue utime execle getsockname recvfrom sigset utimensat execv getsockopt recvmsg sigsuspend utimes execve getuid rename sleep wait _Exit kill renameat sockatmark waitpid _exit link rmdir socket write 1.3 信号相关函数 1.4 自定义信号处理函数","date":"2024-12-05T21:58:39+08:00","permalink":"http://localhost:1313/post/linux/apue/signals/","tags":["APUE","信号"],"title":"信号"},{"categories":["Linux"],"contents":"本文总结内存映射相关接口的用法和注意事项。\n1.1 内存映射IO的实现方法 内存映射IO(memory-mapped I/O)将一个磁盘中的文件映射到内存的一个缓冲区中，从而可以通过操作内存中的缓冲区达到操作文件的目的。例如读取映射在内存中的缓冲区，就等同于读取对应的磁盘文件。\n1.1.1 内存映射IO的优缺点 优点：\n读写文件直接编程操作缓冲区，更加简单； 对于两个文件之间的读写操作而言，直接进行文件读写操作的话，read需要先将内核缓冲区中的内容读到应用缓冲区(read_buffer),然后write再将应用缓冲区(write_buffer)的数据拷贝到内核缓冲区。若使用内存映射IO，则直接将数据从内核的一个缓冲区拷贝到另外一个缓冲区即可,开销很小(开销来自于可能发生缺页中断)。 1.2 内存映射IO相关的接口 1.2.1 内存映射IO相关的函数声明 1 2 3 4 5 #include \u0026lt;sys/mman.h\u0026gt; void* mmap(void* addr, size_t length, int prot, int flag, int fd, off_t offset); int mprotect(void *addr, size_t len, int prot); int msync(void *addr, size_t length, int flags); int munmap(void *addr, size_t length); 1.2.2 mmap函数 mmap函数参数说明：\naddr参数用于指定映射内存区的起始地址。通常设置为NULL，表示由系统选择该映射区的首地址。 length参数用于指定要映射的内存区域的长度。length必须是虚拟内存页面的整数倍。 prot用于指定内存映射区域的保护方式： PROT_READ：映射区可读 PROT_WRITE：映射区可写 PROT_EXEC：映射区可执行 PROT_NONE：映射区不可访问 prot可以设置为PROT_NONE，也可以设置为PROT_READ,PROT_WRITE, PROT_EXEC一个或者多个组合按位或。 对指定内存映射区的保护不能超过被映射文件打开时的访问权限。例如文件是只读打开的，那么对映射内存区就不能指定PROT_WRITE属性。 当prot设置为PROT_NONE时：这块映射的缓冲区不可读写，读写时会触发SIGSEGV。 用于实现对特定区域的保护，例如可以检测内存越界。典型应用：pthread_attr_setguardsize/pthread_attr_getguardsize. prot的属性PROT_EXEC的作用是：将内存映射区域的内容当作CPU可以执行的的机器指令进行执行。 flag参数：用于设置映射区域的属性。\nMAP_SHARED：该属性表示共享当前映射的内存区。映射区域的更新对其它映射了同一文件区域的进程可见。更新映射区域就会更新对应的映射文件。 MAP_PRIVATE: 该属性表示创建一个私有的映射副本。映射区域的更新对其它映射了同一文件区域的进程不可见。更新映射区域也不会更新对应的映射文件。任何修改都只影响映射文件的副本，而不影响源文件。 必须指定MAP_SHARED或者MAP_PRIVATE其中的一个，但是不能同时指定。 fd参数：指定要被映射的文件描述符。注意，在进行文件映射之前，文件必须先打开。但是关闭文件描述符并不会解除映射区。\noffset参数：offset为被映射的文件中偏移，offset必须是虚拟内存页面的整数倍。虚拟内存页面的大小通过sysconf(_SC_PAGE_SIZE)获取。\n若offset或者length不是内存页面大小的整数倍，操作系统如何处理？例如文件长度96字节，系统页面大小4096字节，则系统会提供4096字节的内存映射区，其中4000字节会被设置为0。虽然可以在映射区中修改4000字节区域，但是修改不会影响到被映射的文件。 1.2.3 mprotect()函数 函数参数说明：\naddr必须是内存页面的整数倍。 mprotect()函数用于修改调用它的进程的访问指定页面中数据的访问权限。如果调用mprotect()函数的进程尝试违反设置的保护方式访问指定的内存区域，则操作系统会给进程返回一个SIGSEGV。利用这特性，我们可以用来定位踩内存问题。 可以通过mprotect()函数来修改内存映射区的保护属性。prot参数和mmap中的参数相同。 1.2.4 msync()函数 函数参数和功能说明：\naddr必须是内存页面的整数倍。 flags参数说明： MS_ASYNC: 函数执行更新操作后立刻返回。 MS_SYNC: 函数需要等待写操作完成才返回。函数必须指定M_ASYNC或M_SYNC中的一个。 MS_INVALIDATE: msync()函数的用途说明：\n如果是用MAP_SHARED标识进行的内存映射，当映射区更新后，修改并不会立刻写会到被映射文件中。而何时将修改的脏页写会磁盘取决于操作系统内核的策略。 脏页写回的策略是：只要某个页面有一个字节被修改，整个页面都会被写回。 如果内存映射区被修改，可以调用msync()函数将脏页下刷到被映射的文件中。 1.2.5 munmap()函数 函数功能说明： munmap()用于解除内存和文件的映射关系。\n相关特性说明：\n当进程退出时会自动解除内存映射。 关闭内存映射时的文件描述符并不能解除和文件的内存映射关系。 调用munmap()函数并不会将内存映射区的内容更新到被映射的文件呢中。 当内存映射区解除映射后，映射时设置为MAP_PRIVATE的内存区的修改会被丢弃。 1.2.6 映射区的一些特性 与映射区相关的信号\nSIGSEGV：信号SIGSEGV通常在进程访问到它不可用的内存区时产生。例如映射区被设置为只读时，进程若尝试修改这个映射区是就会触发SIGSEGV。或者试图访问设置了PROT_NONE的映射区域。\nSIGBUS：如果映射区的某部分在访问时不存在，会触发SIGBUS信号。\n子进程可以通过fork基础父进程的内存映射区。但是不能通过exec继承映射区。\n1.3 内存映射IO的使用示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;sys/mman.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #define COPYINCR (4*1024) int main(int argc, char** argv) { int fdin; int fdout; void* src; void* dst; size_t copysz; struct stat sbuf; off_t fsz = 0; if (argc != 3) { printf(\u0026#34;input argv invalid(%d).\\n\u0026#34;, argc); exit(1); } if ((fdin = open(argv[1], O_RDONLY)) \u0026lt; 0) { printf(\u0026#34;open file(%s) failed, errno(%d).\\n\u0026#34;, argv[1], errno); exit(1); } if (fstat(fdin, \u0026amp;sbuf) \u0026lt; 0) { printf(\u0026#34;get file(%s) stat failed, errno(%d).\\n\u0026#34;, argv[1], errno); exit(1); } if ((fdout = open(argv[2], O_CREAT | O_RDWR | O_TRUNC)) \u0026lt; 0) { printf(\u0026#34;open file(%s) failed, errno(%d).\\n\u0026#34;, argv[2], errno); exit(1); } if (ftruncate(fdout, sbuf.st_size) \u0026lt; 0) { printf(\u0026#34;change file(%s) size failed, errno(%d).\\n\u0026#34;, argv[2], errno); exit(1); } while (fsz \u0026lt; sbuf.st_size) { if (sbuf.st_size - fsz \u0026gt; COPYINCR) { copysz = COPYINCR; } else { copysz = sbuf.st_size - fsz; } src = mmap(NULL, copysz, PROT_READ, MAP_PRIVATE, fdin, fsz); if (src == MAP_FAILED) { printf(\u0026#34;mmap file(%s) offset(%ld)len(%ld) size failed, errno(%d).\\n\u0026#34;, argv[1], fsz, copysz, errno); exit(1); } dst = mmap(NULL, copysz, PROT_WRITE, MAP_SHARED, fdout, fsz); if (src == MAP_FAILED) { printf(\u0026#34;mmap file(%s) offset(%ld)len(%ld) size failed, errno(%d).\\n\u0026#34;, argv[2], fsz, copysz, errno); exit(1); } memcpy(dst, src, copysz); munmap(src, copysz); munmap(dst, copysz); fsz += copysz; } return 0; } ","date":"2024-12-05T11:39:06+08:00","permalink":"http://localhost:1313/post/linux/apue/memory_mapped_io/","tags":["APUE","内存映射"],"title":"内存映射IO"},{"categories":["Linux"],"contents":"本文总结进程间通信的方法和各种方法的差异，以及注意事项。\n1 Linux支持的进程间通信方式 IPC类型 进程关系 半双工管道(匿名) 主机内的进程 FIFO(命名管道) 主机内的进程 消息队列 主机内的进程 信号量 主机内的进程 共享内存 主机内的进程 socket(套接字) 主机内或者主机间的进程 2 管道 3 FIFO 4 消息队列 5 共享内存 共享内存和内存映射IO的不同之处在于，共享内存不需要关联文件，使用的是虚拟内存中的匿名段。\n体现在用法上，就是共享内存不需要关联文件，通过shm_open()创建一个共享内存(虚拟的文件)，所有的进程就可以使用mmap来进行共享了。\n5.1 XSI共享内存 XSI共享内存相关接口：\n1 2 3 4 5 6 7 8 9 10 11 12 #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;sys/ipc.h\u0026gt; #include \u0026lt;sys/shm.h\u0026gt; key_t ftok(const char *pathname, int proj_id); int shmget(key_t key, size_t size, int shmflg); // get or create a shared memory int shmctl(int shmid, int cmd, struct shmid_ds *buf); void *shmat(int shmid, const void *shmaddr, int shmflg); // attach shared memory int shmdt(const void *shmaddr); void *shmat(int shmid, const void *shmaddr, int shmflg); // detach shard memory int shmdt(const void *shmaddr); XSI共享内存的用法见APUE第三版的15.9节。\n5.2 POSIX共享内存 POSIX共享内存接口最早出现在Linux kernel 2.4和glibc 2.2版本。通过man 7 shm_overview可以查看详细说明。POSIX共享内存接口使用更方便，通用性更强。\nPOSIX共享内存相关接口：\n1 2 3 4 5 6 7 8 9 10 11 12 #include \u0026lt;sys/mman.h\u0026gt; int shm_open(const char *name, int oflag, mode_t mode); int shm_unlink(const char *name); void* mmap(void* addr, size_t length, int prot, int flag, int fd, off_t offset); int munmap(void *addr, size_t length); // Set the size of the shared memory object. (A newly created shared memory object has a length of zero.) int ftruncate(int fd, off_t length); // Close the file descriptor allocated by shm_open(3) when it is no longer needed. int close(int fd); 链接时需要增加链接选项-lrt。\nshm_open()：shm_open接口和open接口作用类似。只不过shm_open是为了创建一个用于共享内存的文件而已。因此shm_open()创建的文件描述符同样用close()关闭。\nname：为了具有更好的可移植性，最好将name命名为以/开头的字符串。除了开头的/外不包含其他字符串。而name的长度也要符合当前系统的文件名长度的要求。\noflag：为了确保创建一个新的共享内存，可以将oflag参数设置为O_CREAT | O_EXEL。这样当name已经存在时，就会返回错误，保证只有不存在才会创建。\nshm_unlink()：shm_unlink()删除shm_open创建的共享内存。\n而要实现不同的进程共同使用同一片共享内存，只需要其中约定某个进程创建一个共享内存，然后将该共享内存的名字提供出来。其他进程就可以使用mmap来使用这个共享内存了。\n6 信号量 6.1 XSI信号量 SUS提供的信号量机制，提供了相当全面的功能。但是和POSIX信号量相比，使用更加复杂，而且性能也不如POSIX信号量。\n因此linux环境中一般使用POSIX信号量。感兴趣的可以阅读APUE第三版15.8节了解它的使用细节。\nXSI 信号量相关接口：\n1 2 3 4 #include \u0026lt;sys/sem.h\u0026gt; int semget(key_t key, int nsems, int semflg); int semctl(int semid, int semnum, int cmd, ...); int semop(int semid, struct sembuf *sops, size_t nsops); 6.2 POSIX信号量 信号量相关接口：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;semaphore.h\u0026gt; typedef union { char __size[__SIZEOF_SEM_T]; long int __align; } sem_t; int sem_init(sem_t *sem, int pshared, unsigned int value); int sem_destroy(sem_t *sem); sem_t *sem_open(const char *name, int oflag); sem_t *sem_open(const char *name, int oflag, mode_t mode, unsigned int value); int sem_unlink(const char *name); int sem_close(sem_t *sem); int sem_wait(sem_t *sem); int sem_trywait(sem_t *sem); int sem_timedwait(sem_t *sem, const struct timespec *abs_timeout); int sem_post(sem_t *sem); int sem_getvalue(sem_t *sem, int *sval); // POSIX信号量有两种：匿名型号量和命名信号量。它们的除了创建和销毁方式不同，其它没什么区别。\n匿名信号量只存在于内存中，只有可以访问对应内存的进程才可以使用。这意味着只有同一个进程中的线程可以使用或者已经映射相同内存内容到它们的地址空间的不同进程中的线程。 命名信号量可以通过名字访问，因此知道它们的名字的进程都可以使用。 6.2.1 信号量通用接口 sem_wait()：该函数用来实现信号量的减1操作。也可以理解为申请1个资源。调用该函数时，若信号量为0就会被阻塞。直到成功将信号量减1或者被一个信号中断。\nsem_try_wait()：该函数功能和sem_wait相同，都是用来对信号减1的。但是该函数在遇到信号量为0时不会被阻塞，而是返回-1并且将errno设置为EAGAIN。\nsem_timedwait()：该函数也是用于对信号量进行减1操作的。不同之处在于，它可以设置一个超时时间，当遇到信号量为0时，等待一个指定时间后仍然未能对信号量减1，就返回-1并将errno设置为ETIMEDOUT。\nsem_post()：该函数用来实现信号量的加1操作。也可以理解为释放1个资源。在调用sem_post()时，存在被信号量阻塞的进程，那么被阻塞的线程会被唤醒。而且被sem_post()加1的信号量会再次被sem_wait()或者sem_timedwait()函数减1。\nsem_getvalue()：获取当前信号量的值。该函数的操作不是原子的，即该函数返回是这个值可能已经改变，若需要获取准确的值，需要自行保证获取value的原子性。\n6.2.2 匿名信号量 如果信号量只在某个进程内部使用，使用匿名信号量更方便。\nsem_init()：创建匿名信号量。\nsem：sem用于保存新创建的匿名信号量的地址，需要事先定义好。\n若只在进程内部使用，需要对使用该信号量的线程均可见。例如全局变量或者在堆内存中申请内存的变量。\n若需要在两个进程之间使用，则变量需要在两个进程共享内存区域中。\npshared：pshared参数用于指定当前信号量的共享方式。若只在进程内使用，则将值设置为0；若在进程间使用，将值设置为非0值，例如1。\nvalue：value用于设置信号量的初始值。\nsem_destroy()：销毁匿名信号量。调用sem_destroy()后，不能再使用任何带有sem的函数了。\n6.2.3 命名信号量 sem_open()：sem_open()可以用来创建一个新的命名信号量或者使用一个已经存在的命名信号量。\n创建一个新的信号量的方法：如果要确保创建一个新的信号量，可以将oflag设置为O_CREAT|O_EXCL。当指定name的信号量已经存在时，会返回sem_open失败。\n使用已经存在的信号量的方法：使用只包含name和flag参数的sem_open函数，而且oflag设置为0。\nname：name参数用于指定信号量的名字。为了增加可移植性，建议名字以/开头。而且除了开头的/外，不能有其他的/存在。信号量的名字有最大长度限制，其长度不应该超过_POSIX_NAME_MAX。\noflag：oflag用于控制创建信号量的行为，参见前面两条说明。\nmode：mode为创建的信号量的文件访问权限，同open()函数的mode。\nvalue：value为创建的信号量的初始值。\n返回值：sem_open()函数的返回值为sem_t类型的指针，作为只用这个变量对该信号量执行其他操作。\nsem_close()：sem_close()用于释放进程申请的所有和该命名信号量相关的资源。\n如果进程在退出前，没有主动关闭命名信号量，那么内核会自动关闭该进程打开所有信号量。\n命名信号量关闭后，不会影响信号量的值。进程退出后由内核自动关闭的信号量也是一样的。\nsem_unlink()：sem_unlink()删除命名信号量的名字。调用该函数后信号量的名字会被立刻删除。但是只有当所有的信号量的使用者均关闭了该信号量，信号量才会被销毁。\n6.2.3 二进制信号量 二值信号量和计数信号量的差异在于初始化和使用信号量。如果信号量的值只有0和1，那它就是二值信号量。\n当二值信号量为1时，表示它处于\u0026quot;解锁状态\u0026quot;；当信号量的值为\u0026quot;0\u0026quot;时，表示他处于”加锁“状态。\n7 sockek socket相关的内容比较多，单独作为一篇文章介绍。\n","date":"2024-12-05T11:37:06+08:00","permalink":"http://localhost:1313/post/linux/apue/interprocess_communication/","tags":["APUE","IPC","进程间通信"],"title":"进程间通信的方法"},{"categories":["Linux"],"contents":"本文总结多线程的特性和同步方法。\n多线程 多线程的复杂性来源：\nCPU任务可抢占 多核并发 线程让渡 1 线程数据 1.1 线程私有数据 线程有如下私有数据：\n线程ID，线程ID在进程内部唯一。 一组寄存器 栈 调度优先级和调度策略 信号屏蔽字 errno变量 线程私有数据 1.2 线程共享数据 一个进程中的所有信息对该进程中的所有线程都是共享的。包含如下信息：\n可执行程序的代码\n程序的全局变量\n堆内存\n栈\n文件描述符\n1 线程同步方法 原子操作相关的接口由GCC自身提供，使用时无需包含其他头文件。pthread相关接口由glibc提供，使用时需要包含pthread.h头文件。\n1.1 原子操作 原子操作主要用于对整数进行简单的取值、加减、交换操作。由GCC提供的原子操作：\nn++类 1 2 3 4 5 6 7 8 type __sync_fetch_and_add(type *ptr, type value, ...); // m+n type __sync_fetch_and_sub(type *ptr, type value, ...); // m-n type __sync_fetch_and_or(type *ptr, type value, ...); // m|n type __sync_fetch_and_and(type *ptr, type value, ...); // m\u0026amp;n type __sync_fetch_and_xor(type *ptr, type value, ...); // m^n type __sync_fetch_and_nand(type *ptr, type value, ...); // (~m)\u0026amp;n /* 对应的伪代码 */ { tmp = *ptr; *ptr op= value; return tmp; }{ tmp = *ptr; *ptr = (~tmp) \u0026amp; value; return tmp; } // nand ++n类 1 2 3 4 5 6 7 8 type __sync_add_and_fetch(type *ptr, type value, ...); // m+n type __sync_sub_and_fetch(type *ptr, type value, ...); // m-n type __sync_or_and_fetch(type *ptr, type value, ...); // m|n type __sync_and_and_fetch(type *ptr, type value, ...); // m\u0026amp;n type __sync_xor_and_fetch(type *ptr, type value, ...); // m^n type __sync_nand_and_fetch(type *ptr, type value, ...); // (~m)\u0026amp;n /* 对应的伪代码 */ { *ptr op= value; return *ptr; }{ *ptr = (~*ptr) \u0026amp; value; return *ptr; } // nand 3.CAS类\n1 2 3 4 bool __sync_bool_compare_and_swap (type *ptr, type oldval, type newval, ...); type __sync_val_compare_and_swap (type *ptr, type oldval, type newval, ...); /* 对应的伪代码 */ { if (*ptr == oldval) { *ptr = newval; return true; } else { return false; } }{ if (*ptr == oldval) { *ptr = newval; } return oldval; } 1.2 自旋锁(spinklock) 自旋锁使用场景：执行时间短的任务。\n等待自旋锁的过程中，不会让渡CPU资源，盲等。\n1.2.1 pthread自旋锁接口 1 2 3 4 5 6 #include \u0026lt;pthread.h\u0026gt; int pthread_spin_init(pthread_spinlock_t* lock, int pshared); // init spink lock int pthread_spin_destroy(pthread_spinlock_t* lock); // destroy spin lock int pthread_spin_lock(pthread_spinlock_t* lock); int pthread_spin_unlock(pthread_spinlock_t* lock); int pthread_spin_trylock(pthread_spinlock_t* lock); 1.2.2 pthread_spin_lock实现 以x86系统为例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 int pthread_spin_lock ( pthread_spinlock_t *lock) { asm (\u0026#34;\\n\u0026#34; \u0026#34;1:\\t\u0026#34; LOCK_PREFIX \u0026#34;decl %0\\n\\t\u0026#34; \u0026#34;jne 2f\\n\\t\u0026#34; \u0026#34;.subsection 1\\n\\t\u0026#34; \u0026#34;.align 16\\n\u0026#34; \u0026#34;2:\\trep; nop\\n\\t\u0026#34; \u0026#34;cmpl $0, %0\\n\\t\u0026#34; \u0026#34;jg 1b\\n\\t\u0026#34; \u0026#34;jmp 2b\\n\\t\u0026#34; \u0026#34;.previous\u0026#34; : \u0026#34;=m\u0026#34; (*lock) : \u0026#34;m\u0026#34; (*lock)); return 0; } 1.2.2 pthread_spin_unlock实现 1 2 3 4 5 6 7 8 9 10 11 12 13 .globl pthread_spin_unlock .type pthread_spin_unlock,@function .align 16 pthread_spin_unlock: movl 4(%esp), %eax movl $1, (%eax) xorl %eax, %eax ret .size pthread_spin_unlock,.-pthread_spin_unlock /* The implementation of pthread_spin_init is identical. */ .globl pthread_spin_init pthread_spin_init = pthread_spin_unlock 1.3 互斥量(mutex) 对互斥量进行加锁以后，任何其它试图再次对互斥量加锁的线程都会被阻塞，直到当前你线程释放该互斥锁。如果释放互斥锁时有一个以上的线程阻塞，那么所有阻塞在该互斥量上的线程都会变为可运行状态。但是只有第一个可运行状态的线程可以获取互斥锁而得以继续运行，其他线程仍然需要继续等待。\n1.3.1 pthread mutex接口 1 2 3 4 5 6 7 8 9 10 // pthread_mutex_t结构定义： // nptl\\sysdeps\\unix\\sysv\\linux\\x86_64\\bits\\pthreadtypes.h #include \u0026lt;pthread.h\u0026gt; int pthread_mutex_init(pthread_mutex_t* mutex, const pthread_mutexattr_t* attr); int pthread_mutex_destroy(pthread_mutex_t* mutex); int pthread_mutex_lock(pthread_mutex_t* mutex); int pthread_mutex_trylock(pthread_mutex_t* mutex); int phtread_mutex_unlock(pthread_mutex_t* mutex); 1.3.2 pthread_mutex结构 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // x86_64结构 typedef union { struct __pthread_mutex_s { int __lock; unsigned int __count; int __owner; unsigned int __nusers; int __kind; int __spins; __pthread_list_t __list; # define __PTHREAD_MUTEX_HAVE_PREV 1 } __data; char __size[__SIZEOF_PTHREAD_MUTEX_T]; long int __align; } pthread_mutex_t; 1.4 读写锁(rw_lock) 1.4.1 读写锁特性 读写锁可以有3种状态：读模式下加锁状态，写模式下加锁状态和不加锁状态。一次只有一个线程可以占有写模式的读写锁，但是多个线程可以同时占有读模式的读写锁。\n当读写锁是写加锁状态时，在这个锁被解锁前，所有试图对这个锁加锁的线程都会被阻塞。当读写锁在读加锁状态时，所有试图以读模式对它进行加锁的线程都可以的到访问权。但是任何希望以写模式对此锁进行加锁的线程都会阻塞，直到所有的线程释放它们的读锁为止。该模式为读锁优先模式，存在申请写锁的线程饥饿问题。\n优化方案：当读写锁处于读模式锁住的状态，而这时有一个线程试图以写模式获取锁时，读写锁通常会阻塞随后的读模式锁请求。这样可以避免读模式锁长期占用，写模式锁一直等待的问题。\n1.4.2 读写锁接口 1 2 3 4 5 6 7 8 #include \u0026lt;pthread.h\u0026gt; int pthread_rwlock_init(phread_rwlock_t* rwlock, pthread_rwlockattr_t* attr); //init int pthread_rwlock_destroy(pthread_rwlok_t* rwlock); // destroy int pthread_rwlock_rdlock(pthread_rwlock_t* rwlock); // set read lock int pthread_rwlock_wrlock(pthread_rwlock_t* rwlock); // set write lock int pthread_rwlock_unlock(pthread_rwlock_t* unlock); // unlock read/write lock 1.5 条件变量(condition variable) 1.5.1 条件变量相关接口 1 2 3 4 5 6 7 8 9 10 int pthread_cond_init(pthread_cond_t* cond, const pthread_condattr_t* attr); int pthread_cond_destroy(pthread_cond_t* cond); int pthread_cond_wait(pthread_cond_t* cond, pthread_mutex_t* mutex); int pthread_cond_timedwait(pthread_cond_t* cond, pthread_mutex_t* mutex, const struct timespec* tsptr); int pthread_cond_signal(pthread_cond_t* cond); int pthread_cond_broadcast(pthread_cond_t* cond); 1.5.2 条件变量实例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 1 #include \u0026lt;stdio.h\u0026gt; 2 #include \u0026lt;unistd.h\u0026gt; 3 #include \u0026lt;pthread.h\u0026gt; 4 #include \u0026lt;errno.h\u0026gt; 5 6 int done = 0; 7 pthread_mutex_t m_lock = PTHREAD_MUTEX_INITIALIZER; 8 pthread_cond_t c_lock = PTHREAD_COND_INITIALIZER; 9 10 void thread_join(void) 11 { 12 pthread_mutex_lock(\u0026amp;m_lock); 13 while (done == 0) { 14 pthread_cond_wait(\u0026amp;c_lock, \u0026amp;m_lock); 15 } 16 pthread_mutex_unlock(\u0026amp;m_lock); 17 } 18 19 void thread_exit(void) 20 { 21 pthread_mutex_lock(\u0026amp;m_lock); 22 done = 1; 23 printf(\u0026#34;thread end.\\n\u0026#34;); 24 pthread_cond_signal(\u0026amp;c_lock); 25 pthread_mutex_unlock(\u0026amp;m_lock); 26 } 28 void* t_func(void* arg) 29 { 30 printf(\u0026#34;thread is start.\\n\u0026#34;); 31 thread_exit(); 32 return NULL; 33 } 34 35 int main(void) 36 { 37 printf(\u0026#34;parent start.\\n\u0026#34;); 38 pthread_t tid; 39 int ret = pthread_create(\u0026amp;tid, NULL, t_func, NULL); 40 if (ret != 0) { 41 printf(\u0026#34;create pthread failed, errno(%d).\\n\u0026#34;, errno); 42 } 43 thread_join(); 44 45 printf(\u0026#34;parent end.\\n\u0026#34;); 46 return 0; 47 } 1.6 二进制信号量 二进制信号量也可以用来实现互斥。二进制信号量的作用类似于互斥锁。详细使用方法见进程通信文章中的信号量部分。\n2 死锁 2.1 死锁的产生 2.2 死锁检测 2.2 常见死锁 3 线程安全函数 如果一个函数在相同的时间点可以被多个线程安全的调用，则称该函数是线程安全的。\n如果一个函数对多个线程来说是可重入的，就说这个函数是线程安全的。\n最典型的场景是：使用了静态变量的函数就是线程不安全的函数。因为多个线程调用时，都可以修改该静态变量。\n解决方法是： 将静态变量替换为调用者传入，各个线程自己管理自己的变量。\n","date":"2024-12-05T11:29:06+08:00","permalink":"http://localhost:1313/post/linux/apue/thread_synchronization/","tags":["APUE","多线程","线程同步"],"title":"多线程的特性和同步方法"},{"categories":["算法"],"contents":"本文讲解回溯算法的原理和具体实现。\n1 回溯算法 1.1 回溯算法的原理 回溯算法是暴力搜索法中的一种。回溯法是一种可以找出所有（或一部分）解的一般性算法，尤其适用于约束满足问题。\n在实际实现时采用DFS搜索的方式进行遍历，然后再遍历过程中采用剪枝的策略去掉不满足条件的解。\n对于具体代码实现而言，实际上就是DFS的一种实际应用。 和DFS遍历二叉树不同之处在于，回溯中使用DFS需要有前进和回退的过程，这也是为啥叫做回溯的原因。 一般在回溯算法中，使用递归的方式来进行DFS。\n1.2 解决回溯问题思路 解决回溯问题时，一定要画出遍历路径的多叉树。搞清楚横向遍历的是什么，和纵向遍历的路径是啥？ 例如： 如下图所示，为leetcode 电话号码组合问题中\u0026quot;23\u0026quot;的遍历示意图。其中2对应字符串\u0026quot;abc\u0026quot;, 3对应字符串\u0026quot;def\u0026quot;。\n我们可以看到，横向展开的是每个字符串内的每个字母，纵向是展开的字符串\u0026quot;23\u0026quot;。\n而回溯的递归函数中的for循环内部实现，就是横向展开的体现。\n因此在这个问题中，需要先根据索引获取数字对应的字符串。\n而针对问题39-组合总和问题，可以按照下图所示的思路去分析解决：\n1.1.1 回溯代码的基本框架 1 2 3 4 5 6 7 8 9 10 path = [] def backtrack(path, 选择列表): if 满足结束条件: result.add(item) return for item in 选择列表: path.push(item) // 添加 backtrack(path, 选择列表) path.pop() // 删除 1.2 回溯算法的应用 1.2.1 排列组合问题 问题1: 全排列 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; permute(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int len = nums.size(); if (len == 0) { return res; } vector\u0026lt;int\u0026gt; path; vector\u0026lt;bool\u0026gt; used(len, false); dfs(nums, path, 0, used); return res; } void dfs(vector\u0026lt;int\u0026gt;\u0026amp; nums, vector\u0026lt;int\u0026gt; path, int depth, vector\u0026lt;bool\u0026gt;\u0026amp; used) { int len = nums.size(); if (len == depth) { res.push_back(path); return; } for (int i = 0; i \u0026lt; len; ++i) { if (!used[i]) { path.push_back(nums[i]); used[i] = 1; dfs(nums, path, depth + 1, used); used[i] = 0; path.pop_back(); } } } private: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res; }; 问题2：电话号码的字母组合 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public: vector\u0026lt;string\u0026gt; letterCombinations(string digits) { int len = digits.size(); if (len == 0) { return {}; } string path; backtrack(digits, 0, path); return res; } void backtrack(string digits, int index, string\u0026amp; path) { if (index == digits.size()) { res.push_back(path); return; } char ch = digits[index]; string str = num_map[ch - \u0026#39;0\u0026#39;]; for (int i = 0; i \u0026lt; str.size(); ++i) { path.push_back(str[i]); backtrack(digits, index + 1, path); path.pop_back(); } } private: string num_map[10] = {\u0026#34;\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;abc\u0026#34;, \u0026#34;def\u0026#34;, \u0026#34;ghi\u0026#34;, \u0026#34;jkl\u0026#34;, \u0026#34;mno\u0026#34;, \u0026#34;pqrs\u0026#34;, \u0026#34;tuv\u0026#34;, \u0026#34;wxyz\u0026#34;}; vector\u0026lt;string\u0026gt; res; }; 问题3：组合总和(39) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; combinationSum(vector\u0026lt;int\u0026gt;\u0026amp; candidates, int target) { int size = candidates.size(); if (candidates.size() == 0) { return {}; } sort(candidates.begin(), candidates.end()); vector\u0026lt;int\u0026gt; path; backtrack(candidates, 0, path, target); return res; } void backtrack(vector\u0026lt;int\u0026gt;\u0026amp; cand, int idx, vector\u0026lt;int\u0026gt;\u0026amp; path, int target) { if (target == 0) { res.push_back(path); return; } for (int i = idx; i \u0026lt; cand.size(); ++i) { if (target \u0026lt; cand[i]) { return; } path.push_back(cand[i]); backtrack(cand, i, path, target - cand[i]); path.pop_back(); } } private: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res; }; 1.2.2 N皇后问题 1.3 Leetcode相关题目 17 Letter Combinations of a Phone Number\n22 Generate Parentheses\n39 Combination Sum\n46 Permutations\n51 N-Queens\n52 N-Queens II\n77 Combinations\n78 Subsets\n89 Gray Code\n93 Restore IP Addresses\n111 Minimum Depth of Binary Tree\n112 Path Sum\n113 Path Sum II\n131 Palindrome Partitioning\n140 Word Break II\n","date":"2024-12-02T15:39:46+08:00","permalink":"http://localhost:1313/post/algorithm/backtracking_algorithm/","tags":["排序"],"title":"回溯算法"},{"categories":["算法"],"contents":"本文主要是讲解堆排序的原理和具体实现方法。\n1 堆排序 1.1 堆排序的原理 1.2 堆排序的应用：topk问题 堆排序：堆排序最典型的场景就是topK问题\n使用堆实现top-k问题的技巧：\n获取最大的K个元素，使用小顶堆(优先剔除较小的元素)。\n获取最小的K个元素，使用大顶堆(优先剔除较大的元素)。\nTopK 示例，来源【前 K 个高频元素(LCR060)】，实现原理：\n先使用K个元素构建一个小顶堆。 然后将堆顶元素从堆中删除，然后将新元素插入堆中。 重复这个过程，直到遍历完所有元素。 当遍历完所有元素以后，留在堆中的元素就是最大K个元素。（因为较小的元素都被剔除了。） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 static bool cmp(pair\u0026lt;int, int\u0026gt; left, pair\u0026lt;int, int\u0026gt; right) { return left.second \u0026gt; right.second; } vector\u0026lt;int\u0026gt; topKFrequent(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k) { unordered_map\u0026lt;int, int\u0026gt; num_cnt; for (auto\u0026amp; item : nums) { num_cnt[item]++; } // init priority_queue priority_queue\u0026lt;pair\u0026lt;int, int\u0026gt;, vector\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt;, decltype(\u0026amp;cmp)\u0026gt; little_heap(cmp); for (auto\u0026amp; [num, cnt] : num_cnt) { if (little_heap.size() \u0026lt; k) { little_heap.emplace(num, cnt); } else { if (little_heap.top().second \u0026lt; cnt) { little_heap.pop(); little_heap.emplace(num, cnt); } } } vector\u0026lt;int\u0026gt; res; while (!little_heap.empty()) { res.emplace_back(little_heap.top().first); little_heap.pop(); } reverse(res.begin(), res.end()); return res; } 1.3 大顶堆实现降序序列 使用优先级队列实现大顶堆,默认就是大顶堆。\n大顶堆也可以用来排序：大顶堆排序的结果为降序序列，\n堆出列时，先弹出顶部的元素，而顶部的元素最大，所以的得到序列就是降序的。\n1 2 3 4 5 6 7 8 9 vector\u0026lt;int\u0026gt; vec = {1,8,5,6,3,4,0,9,7,2}; std::priority_queue\u0026lt;int\u0026gt; pri_que; for (int val : vec) { pri_que.push(val); } // 或者自定义比较函数实现 std::vector\u0026lt;int\u0026gt; vec = {3, 1, 4, 1, 5}; std::priority_queue\u0026lt;int\u0026gt; big_heap(std::less\u0026lt;int\u0026gt;(), vec); 1.4 小顶堆实现升序序列 使用优先级队列实现小顶堆需要自定义比较函数。小顶堆的排序结果为升序序列。\n优先级队列中的比较函数的含义：顶部元素和尾部元素的比较结果。\n例如：小顶堆中比较函数是greater的原因是，只有顶部元素比尾部元素大，才需要交换。\n1 2 3 // 使用优先级队列实现小顶堆的方法 std::vector\u0026lt;int\u0026gt; vec = {3, 1, 4, 1, 5}; std::priority_queue\u0026lt;int\u0026gt; little_heap(vec, std::greater\u0026lt;int\u0026gt;()); ","date":"2024-12-02T15:38:46+08:00","permalink":"http://localhost:1313/post/algorithm/heap_sort/","tags":["堆排序","排序"],"title":"堆排序的原理与实现"},{"categories":["算法"],"contents":"本文主要针对各种排序算法之间的特性进行比较。\n1.2 排序总结 排序算法按照排序的种类、稳定性、时间复杂度和空间复杂度进行总结。\n名称 排序类型 排序方式 时间复杂度(平均) 时间复杂度(最好) 时间复杂度(最坏) 空间复杂度 稳定性 冒泡排序 比较 交换排序 $O(n^2)$ $O(n)$ $O(n^2)$ O(1) 稳定 快速排序 比较 交换排序 $O(nlogn)$ $O(nlogn)$ $O(n^2)$ $O(logn)$ 不稳定 插入排序 比较 插入排序 $O(n^2)$ $O(n)$ $O(n^2)$ $O(1)$ 稳定 希尔排序 比较 插入排序 $O(n^{4/3})$ $O(nlogn)$ $O(n^{3/2})$ $O(1)$ 不稳定 选择排序 比较 选择排序 $O(n^2)$ $O(n^2)$ $O(n^2)$ $O(1)$ 不稳定 堆排序 比较 选择排序 $O(nlogn)$ $O(nlogn)$ $O(nlogn)$ O(1) 不稳定 归并排序 比较 归并排序 $O(nlogn)$ $O(nlogn)$ $O(nlogn)$ $O(n)$ 稳定 计数排序 非比较 计数 $O(n+r)$ $O(n+r)$ $O(n+r)$ $O(n)$ 稳定 基数排序 非比较 - $O(n*\\frac{k}{d})$ $O(n)$ $O(n*\\frac{k}{d})$ $O(n+2^d)$ 稳定 桶排序 非比较 - $O(n+r)$ - $O(n+r)$ $O(n+r)$ 稳定 ","date":"2024-12-02T15:38:46+08:00","permalink":"http://localhost:1313/post/algorithm/sort_summary/","tags":["排序"],"title":"排序算法的比较"},{"categories":["cpp"],"contents":"C++中的STL用法总结\nC++中的STL用法总结 2 queue 3 priority_queue 优先队列（Priority Queue）是一种容器适配器，是在容器queue的基础上实现的。它能够在常数时间内查找最大（默认情况下）元素，插入和删除操作的时间复杂度为$O(logn)$。\n3.1 优先级队列常用成员函数 push(): top(): 获取队列顶部元素； pop(): 删除队列顶部元素； size(): 获取优先级队列中元素个数； empty():判断优先级队列是否为空。 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // 遍历优先级队列 template\u0026lt;typename T\u0026gt; void print_queue(T\u0026amp; q) { while(!q.empty()) { std::cout \u0026lt;\u0026lt; q.top() \u0026lt;\u0026lt; \u0026#34; \u0026#34;; q.pop(); } std::cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } std::priority_queue\u0026lt;int\u0026gt; q; for(int n : {1,8,5,6,3,4,0,9,7,2}) { q.push(n); } std::priority_queue\u0026lt;int, std::vector\u0026lt;int\u0026gt;, std::greater\u0026lt;int\u0026gt; \u0026gt; q2; for(int n : {1,8,5,6,3,4,0,9,7,2}) { q2.push(n); } 4 stack 4.1 常用成员函数 top(): accesses the top element\nempty(): checks whether the underlying container is empty\npush(): inserts element at the top\nemplace: constructs element in-place at the top\npop()：removes the top element\n5 deque 6 array 7 list 8 forward_list 9 map系列 9.1 map 9.1.1 map功能说明 C++中的容器map是存放key,value键-值对的数据结构。内部的key唯一且会按照比较函数进行排序。特性如下：\nkey唯一 内部数据有序 内存数据结构：红黑树（平衡二叉树） 迭代器按照key的升序顺序遍历数据 9.2 multimap 9.2.1 multimap功能说明 数据结构和map相同，区别在于内部的key可以重复。特性如下：\nkey可以重复 内部数据有序 内存数据结构：红黑树（平衡二叉树） 迭代器按照key的升序顺序遍历数据，对于相同的键，按照插入顺序排列； 9.3 unordered_map 9.3.1 unordered_map功能说明 C++中的容器map是存放key,value键-值对的数据结构。内部的key唯一，但是不会对键值对进行排序；特性如下：\nkey唯一 内部数据无序 内部数据结构：哈希表 9.3.2 unordered_map常用接口函数 9.3.2.1 迭代方法 1 2 3 4 5 6 7 8 9 10 // 方法1 std::unordered_map\u0026lt;int, std::string\u0026gt; mag = {{1, \u0026#34;foo\u0026#34;}, {3, \u0026#34;bar\u0026#34;}, {2, \u0026#34;baz\u0026#34;}}; for(auto iter = mag.begin(); iter != mag.end(); ++iter) { std::cout \u0026lt;\u0026lt; \u0026#34;fisrt:\u0026#34; \u0026lt;\u0026lt; item-\u0026gt;first \u0026lt;\u0026lt; \u0026#34;, second: \u0026#34; \u0026lt;\u0026lt; item-\u0026gt;second \u0026lt;\u0026lt; std::endl; } // 方法2 for(auto item : mag) { std::cout \u0026lt;\u0026lt; \u0026#34;fisrt:\u0026#34; \u0026lt;\u0026lt; item-\u0026gt;first \u0026lt;\u0026lt; \u0026#34;, second: \u0026#34; \u0026lt;\u0026lt; item-\u0026gt;second \u0026lt;\u0026lt; std::endl; } 9.3.2.1 查找元素：find() 1 2 3 4 5 6 7 8 9 10 11 // find() // insert() std::unordered_map\u0026lt;int,int\u0026gt; example; auto item = example.find(2); // Finds an element with key equivalent to 2 if(item != example.end()) { std::cout \u0026lt;\u0026lt; \u0026#34;Found element, fisrt:\u0026#34; \u0026lt;\u0026lt; item-\u0026gt;first \u0026lt;\u0026lt; \u0026#34;, second: \u0026#34; \u0026lt;\u0026lt; item-\u0026gt;second \u0026lt;\u0026lt; std::endl; item-\u0026gt;second++; } else { std::cout \u0026lt;\u0026lt; \u0026#34;Not found element!\u0026#34; \u0026lt;\u0026lt; std::endl; example[2] = 1; } 9.3.2.2 更新map 1 2 3 4 std::unordered_map\u0026lt;std::string, size_t\u0026gt; word_map; for (const auto \u0026amp;w : { \u0026#34;this\u0026#34;, \u0026#34;sentence\u0026#34;, \u0026#34;is\u0026#34;, \u0026#34;not\u0026#34;, \u0026#34;a\u0026#34;, \u0026#34;sentence\u0026#34;, \u0026#34;this\u0026#34;, \u0026#34;sentence\u0026#34;, \u0026#34;is\u0026#34;, \u0026#34;a\u0026#34;, \u0026#34;hoax\u0026#34;}) { ++word_map[w]; } 9.4 unordered_multimap 9.4.1 unordered_multimap功能说明 数据结构和unordered_map相同，区别在于内部的key可以重复。特性如下：\nkey不唯一，但每个键关联的值可以不同。 内部数据无序 内部数据结构：哈希表 10 set系列 在C++标准模板库（STL）中，set、multiset、unordered_set和unordered_multiset是四种常用的关联容器。\n10.1 set功能说明 C++中的set容器是一种关联容器，内部存储的是有序唯一的key。特性如下：\nkey唯一 内部数据有序 内部数据结构：红黑树（平衡二叉树） 10.2 multiset 10.2.1 multiset功能说明 C++中的multiset容器是一种关联容器，特性和set类似，唯一区别是可以存在重复的key。特性如下：\nkey不唯一 内部数据有序 内部数据结构：红黑树（平衡二叉树） 10.3 unordered_set 10.3.1 unordered_set功能说明 C++中的unordered_set容器是一种关联容器，内部存储的key唯一。特性如下：\nkey唯一 内部数据无序 内部数据结构：哈希表 10.3.2 unordered_set常用成员函数 empty()\nsize():\ninsert(): Inserts element(s) into the container, if the container doesn\u0026rsquo;t already contain an element with an equivalent key.\nemplace(): Inserts a new element into the container constructed in-place with the given args if there is no element with the key in the container.\nerase(): erases elements\nfind(): finds element with specific key\n10.4 unordered_multiset 10.4.1 unordered_multiset功能说明 C++中的unordered_multiset容器是一种关联容器，内部存储的key唯一。特性如下：\nkey不唯一 内部数据无序 内部数据结构：哈希表 ","date":"2024-12-02T15:29:46+08:00","permalink":"http://localhost:1313/post/cpp/stl/cpp_stl/","tags":["STL"],"title":"C++ STL用法总结"},{"categories":["CPP"],"contents":"本文主要是记录c++ string的常用成员函数。\n1 string的常用成员函数 1.1 string的构造方法 1 2 3 4 5 6 7 8 9 10 11 12 std::string s(\u0026#34;Exemplar\u0026#34;); std::string const other(\u0026#34;Exemplar\u0026#34;); std::string s(other); std::string const other(\u0026#34;Exemplary\u0026#34;); std::string s(other, 0, other.length()-1); std::string s(4, \u0026#39;a\u0026#39;); // \u0026#34;aaaa\u0026#34; char mutable_c_str[] = \u0026#34;another C-style string\u0026#34;; std::string s(std::begin(mutable_c_str)+8, std::end(mutable_c_str)-1); 1.2 获取字符串长度:size(), length() 1 2 3 std::string s(\u0026#34;Exemplar\u0026#34;); assert(8 == s.size()); assert(s.size() == s.length()); 1.3 字符串查找:find() 1 2 3 4 5 6 7 8 9 // find(): Finds the first substring equal to the given character sequence. // rfind(): Finds the last substring equal to the given character sequence. string src = \u0026#34;This is a test.\u0026#34; string::size_type index = src.find(\u0026#34;is\u0026#34;); if (index != string::npos) { cout \u0026lt;\u0026lt; \u0026#34;Found, index:\u0026#34; \u0026lt;\u0026lt; index \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;Not found.\u0026#34; \u0026lt;\u0026lt; endl; } 1.4 字符串连接 1.4.1 使用string::append() 示例：\n1 2 3 4 5 6 7 string str1(\u0026#34;foo\u0026#34;); string str2(\u0026#34; bar\u0026#34;); str1.append(str2); cout \u0026lt;\u0026lt; str1 \u0026lt;\u0026lt; endl; // print \u0026#34;foo bar\u0026#34; return 0; 1.4.2 使用连接运算符(+) 1 2 3 4 5 6 7 string str1(\u0026#34;foo\u0026#34;); string str2(\u0026#34; bar\u0026#34;); str1 = str1 + str2; cout \u0026lt;\u0026lt; str1 \u0026lt;\u0026lt; endl; // print \u0026#34;foo bar\u0026#34; return 0; 1.4.3 使用库函数：strcat() 1 2 3 4 5 6 7 string str1(\u0026#34;foo\u0026#34;); string str2(\u0026#34; bar\u0026#34;); strcat(str1, str2); cout \u0026lt;\u0026lt; str1 \u0026lt;\u0026lt; endl; // print \u0026#34;foo bar\u0026#34; return 0; 1.4.3 使用循环 1 2 3 4 5 6 7 8 string str1(\u0026#34;foo\u0026#34;); string str2(\u0026#34; bar\u0026#34;); for (auto i : str2) { str1 += i; } cout \u0026lt;\u0026lt; str1 \u0026lt;\u0026lt; endl; // print \u0026#34;foo bar\u0026#34; return 0; 1.5 C++ string与C字符串互转 1 2 3 4 5 6 7 8 9 10 //string转换为C字符串 string str = \u0026#34;abc\u0026#34;; char arr[100]; strncpy(arr, str.c_str(), str.size()); //c字符串转换为string char cStr[] = \u0026#34;hello\u0026#34;; string str(cStr); 1.6 分割字符串：substr() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 vector\u0026lt;string\u0026gt; SplitString(const string\u0026amp; sourceStr, const string\u0026amp; delimiter) { string tmp = sourceStr; vector\u0026lt;string\u0026gt; output; size_t pos = 0; string token; while ((pos = tmp.find(delimiter)) != string::npos) { token = tmp.substr(0, pos); cout \u0026lt;\u0026lt; token \u0026lt;\u0026lt; endl; output.push_back(token); tmp.erase(0, pos + delimiter.length()); } cout \u0026lt;\u0026lt; tmp \u0026lt;\u0026lt; endl; output.push_back(tmp); return output; } ","date":"2024-12-02T15:28:46+08:00","permalink":"http://localhost:1313/post/cpp/cpp_string/","tags":["string"],"title":"c++ string的常用方法"},{"categories":["cpp"],"contents":"C++中常用库函数\nC++中常用库函数 1 字符串处理 1.1 字符串查找: strstr 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; void find_str(char const* str, char const* substr) { char* pos = strstr(str, substr); if(pos) { printf(\u0026#34;found the string \u0026#39;%s\u0026#39; in \u0026#39;%s\u0026#39; at position: %ld\\n\u0026#34;, substr, str, pos - str); } else { printf(\u0026#34;the string \u0026#39;%s\u0026#39; was not found in \u0026#39;%s\u0026#39;\\n\u0026#34;, substr, str); } } int main(void) { char* str = \u0026#34;one two three\u0026#34;; find_str(str, \u0026#34;two\u0026#34;); find_str(str, \u0026#34;\u0026#34;); find_str(str, \u0026#34;nine\u0026#34;); find_str(str, \u0026#34;n\u0026#34;); return 0; } 2 algorithm库 2.1 排序 2.1.1 sort Sorts the elements in the range [first, last) in ascending order. The order of equal elements is not guaranteed to be preserved.\n说明：sort函数默认将数据按照升序排列。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 // template\u0026lt; class RandomIt \u0026gt; // void sort( RandomIt first, RandomIt last ); std::array\u0026lt;int, 10\u0026gt; s = {5, 7, 4, 2, 8, 6, 1, 9, 0, 3}; // sort using the default operator\u0026lt; std::sort(s.begin(), s.end()); // 自定义比较函数，实现降序排序 // sort using a custom function object struct { bool operator()(int a, int b) { return a \u0026lt; b; } } customLess; std::sort(s.begin(), s.end(), customLess); for (auto a : s) { std::cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } std::cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // sort using a lambda expression std::sort(s.begin(), s.end(), [](int a, int b) { return b \u0026lt; a; }); for (auto a : s) { std::cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } std::cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; 2.1.2 stable_sort() 说明：Sorts the elements in the range [first, last) in ascending order. The order of equal elements is guaranteed to be preserved.\n2.1.3 partial_sort() Rearranges elements such that the range [first, middle) contains the sorted middle - first smallest elements in the range [first, last).\nThe order of equal elements is not guaranteed to be preserved. The order of the remaining elements in the range [middle, last) is unspecified.\n1 2 3 4 5 6 std::array\u0026lt;int, 10\u0026gt; s{5, 7, 4, 2, 8, 6, 1, 9, 0, 3}; std::partial_sort(s.begin(), s.begin() + 3, s.end()); for (int a : s) { std::cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } 2.2 二分查找 2.2.1 binary_search() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // template\u0026lt; class ForwardIt, class T\u0026gt; // bool binary_search( ForwardIt first, ForwardIt last, const T\u0026amp; value ); (1) // template\u0026lt; class ForwardIt, class T, class Compare \u0026gt; // bool binary_search( ForwardIt first, ForwardIt last, const T\u0026amp; value, Compare comp ); (2) // 示例 std::vector\u0026lt;int\u0026gt; haystack {1, 3, 4, 5, 9}; std::vector\u0026lt;int\u0026gt; needles {1, 2, 3}; for (auto needle : needles) { std::cout \u0026lt;\u0026lt; \u0026#34;Searching for \u0026#34; \u0026lt;\u0026lt; needle \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; if (std::binary_search(haystack.begin(), haystack.end(), needle)) { std::cout \u0026lt;\u0026lt; \u0026#34;Found \u0026#34; \u0026lt;\u0026lt; needle \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } else { std::cout \u0026lt;\u0026lt; \u0026#34;no dice!\\n\u0026#34;; } } 2.2.2 lower_bound() 功能说明：Returns an iterator pointing to the first element in the range [first, last) that is not less than (i.e. greater or equal to) value.\n1 2 3 4 5 6 7 8 9 10 11 12 // template\u0026lt; class ForwardIt, class T \u0026gt; // ForwardIt lower_bound( ForwardIt first, ForwardIt last, const T\u0026amp; value ); // template\u0026lt; class ForwardIt, class T, class Compare \u0026gt; // ForwardIt lower_bound( ForwardIt first, ForwardIt last, const T\u0026amp; value, Compare comp ); std::vector\u0026lt;int\u0026gt; data = { 1, 1, 2, 3, 3, 3, 3, 4, 4, 4, 5, 5, 6 }; auto lower = std::lower_bound(data.begin(), data.end(), 4); auto upper = std::upper_bound(data.begin(), data.end(), 4); std::copy(lower, upper, std::ostream_iterator\u0026lt;int\u0026gt;(std::cout, \u0026#34; \u0026#34;)); // 4 4 4 2.2.3 upper_bound() Returns an iterator pointing to the first element in the range [first, last) that is greater than value.\n2.3 revert() 接口定义：\n1 template\u0026lt; class BidirIt \u0026gt; void reverse( BidirIt first, BidirIt last ); 示例：\n1 2 3 std::vector\u0026lt;int\u0026gt; v({1,2,3}); std::reverse(std::begin(v), std::end(v)); std::cout \u0026lt;\u0026lt; v[0] \u0026lt;\u0026lt; v[1] \u0026lt;\u0026lt; v[2] \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; 2.4 heap 2.4.1 make_heap() 接口定义：\n1 2 template\u0026lt; class RandomIt\u0026gt; void make_heap(RandomIt first, RandomIt last); template\u0026lt; class RandomIt, class Compare\u0026gt; void make_heap(RandomIt first, RandomIt last, Compare comp); 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 std::vector\u0026lt;int\u0026gt; v = {3, 1, 4, 1, 5, 9}; std::make_heap(v.begin(), v.end()); // heap: 9 4 5 1 1 3 std::cout \u0026lt;\u0026lt; \u0026#34;heap:\\t\u0026#34;; for (const auto \u0026amp;i : v) { std::cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } std::sort_heap(v.begin(), v.end()); // sorted: 1 1 3 4 5 9 std::cout \u0026lt;\u0026lt; \u0026#34;\\nsorted:\\t\u0026#34;; for (const auto \u0026amp;i : v) { std::cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } std::cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; 2.4.2 sort_heap() 接口定义：\n1 2 template\u0026lt; class RandomIt \u0026gt; void sort_heap( RandomIt first, RandomIt last); template\u0026lt; class RandomIt, class Compare \u0026gt; void sort_heap( RandomIt first, RandomIt last, Compare comp); 2.4.3 push_heap() 接口定义：\n1 2 3 4 template\u0026lt; class RandomIt \u0026gt; void push_heap( RandomIt first, RandomIt last ); template\u0026lt; class RandomIt, class Compare\u0026gt; void push_heap(RandomIt first, RandomIt last, Compare comp ); 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 std::vector\u0026lt;int\u0026gt; v { 3, 1, 4, 1, 5, 9 }; std::make_heap(v.begin(), v.end()); std::cout \u0026lt;\u0026lt; \u0026#34;v: \u0026#34;; // v: 9 5 4 1 1 3 for (auto i : v) std::cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39; \u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; v.push_back(6); std::cout \u0026lt;\u0026lt; \u0026#34;before push_heap: \u0026#34;; // before push_heap: 9 5 4 1 1 3 6 for (auto i : v) std::cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39; \u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::push_heap(v.begin(), v.end()); std::cout \u0026lt;\u0026lt; \u0026#34;after push_heap: \u0026#34;; // after push_heap: 9 5 6 1 1 3 4 for (auto i : v) std::cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39; \u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; 2.4.4 pop_heap() 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 std::vector\u0026lt;int\u0026gt; v { 3, 1, 4, 1, 5, 9 }; std::make_heap(v.begin(), v.end()); std::cout \u0026lt;\u0026lt; \u0026#34;v: \u0026#34;; // v: 9 5 4 1 1 3 for (auto i : v) std::cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39; \u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::pop_heap(v.begin(), v.end()); // moves the largest to the end std::cout \u0026lt;\u0026lt; \u0026#34;after pop_heap: \u0026#34;; // after pop_heap: 5 3 4 1 1 9 for (auto i : v) std::cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39; \u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; int largest = v.back(); v.pop_back(); // actually removes the largest element std::cout \u0026lt;\u0026lt; \u0026#34;largest element: \u0026#34; \u0026lt;\u0026lt; largest \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // largest element: 9 std::cout \u0026lt;\u0026lt; \u0026#34;heap without largest: \u0026#34;; // heap without largest: 5 3 4 1 1 for (auto i : v) std::cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39; \u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; ","date":"2024-12-02T15:26:46+08:00","permalink":"http://localhost:1313/post/cpp/cpp_common_function/","tags":[""],"title":"C++常用库函数的用法"},{"categories":["Tools"],"contents":"本文主要是一些针对程序员入门的一些资料。\n1 一些基础知识 The Missing Semester of Your CS Education\n2 新手如何提问 How-To-Ask-Questions-The-Smart-Way.\n中文版本：提问的智慧\n经典的关键字：\nSTFW\n如果你收到STFW（Search The Fucking Web）的回应，回答者认为你应该到他妈的网上搜索。那人多半也是对的，去搜索一下吧。（更温和一点的说法是 Google 是你的朋友！）\nRTFM\n有一个古老而神圣的传统：如果你收到RTFM（Read The Fucking Manual）的回应，回答者认为你应该去读他妈的手册。当然，基本上他是对的，你应该去读一读。\nRTFSC\nLinux的鼻祖Linus Torvalds在回答有人提出的Minix的一个问题时，所说的第一句话就是\u0026quot;Read The Fucking Source Code\u0026quot;，这就是RTFSC的来由。\n3 理解(讲解)复杂问题的方法 why: 为什么产生的？背景是啥？ what: 是什么？ 解决什么问题的？优缺点？ how: 怎么实现的？ 4 编程的一些经验 机器的结果一定是正确的。当代码结果不符合预期时，可能存在以下几种情况： 代码存在bug? 使用的库函数、系统调用等存在bug? 硬件(CPU/内存/磁盘)异常 总之，不论是什么情况，都是因为存在软件或者硬件异常导致结果不符合预期的。\n没有测试的代码都是不可靠的\n一切外部输入都是不可靠的\n编写代码一定要采用滚雪球的方式进行\n切记贪多求全，全部写完后再进行测试，问题隐藏的更深，更难被发现。 编写代码时，按照功能进行模块化。已经完成的模块都要进行接口测试。 测试阶段多使用assert(), 提前发现不符合预期的bug。 5 一些有用的学习编程资源 南京大学计算机基础实验\n蒋炎岩操作系统课程视频\n蒋炎岩操作系统课程配套课件和代码\n调试理论与实践 (Fault; Failure; Error; 调试一切) [南京大学2023操作系统-P8] (蒋炎岩)\nmusl-libc-精简易读的类glibc库，适合学习glibc内部实现细节\n6 经典的书籍 Computer Systems: A Programmer\u0026rsquo;s Perspective【深入理解计算机系统】(CSAPP) Operating Systems: Three Easy Pieces(OSTEP) Advanced Programming in the UNIX Environment (3rd Edition)【UNIX环境高级编程】 (APUE) TCP-IP Illustrated Volunme 1-The Protocols 7 实用工具 7.1 windows实用工具 本地文件搜索：everyting\n解压工具：7Zip\n剪贴板：ditto\n截图工具：Snipaste\n图片简单编辑工具：GreenShot\n远程连接客户端(开源免费的类Xshell工具)：WindTerm\n7.2 绘图工具 ProcessOn:在线绘图网站\nDrawio Graphviz：开源图形可视化软件\nXMind: 思维导图工具\nExcalidraw: 开源手绘画风绘图工具\nPlantUML：绘制UML的工具\nMatplotlib【配合python使用】 官网\n7.3 格式化代码 7.3.1 indent 1 2 # indent工具格式化c/c++代码： indent -kr -i8 hello.c #将源代码格式化为内核编码风格 7.3.2 clang-format 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # 使用clang-format格式化当前目录下所有的.h、.c文件 find ./ -iname \u0026#39;*.h\u0026#39; -o -iname \u0026#39;*.c\u0026#39; | xargs clang-format -i # 使用clang-format默认风格格式化文件 # LLVM A style complying with the LLVM coding standards # Google A style complying with Google’s C++ style guide # Chromium A style complying with Chromium’s style guide # Mozilla A style complying with Mozilla’s style guide # WebKit A style complying with WebKit’s style guide # Microsoft A style complying with Microsoft’s style guide # GNU A style complying with the GNU coding standards clang-format -style=Google -i test_fork.c # 使用自定义的format配置文件格式化文件 clang-format -style=file:~/.clang-format -i test_fork.c # 生成默认配置文件 clang-format -style=Google -dump-config \u0026gt; .clang-format clang-format下载地址\nclang-format用法\nclang-formt自定义格式语法\n7.4 ImageMagick给图片添加水印的方法 下载ImageMagick: ImageMagick下载地址\n添加ImageMagick的环境变量：将ImageMagick的安装完成后的二进制目录添加到系统path路径中。\n制作水印文件watermark.png，可以使用windows自带的mspaint制作。\n执行命令composite -dissolve 30% -gravity south watermark.jpg input-file.jpg output-file.jpg制作水印。\n也可以批量制作水印。例如下面shell脚本可以将当前目录下所有的jpg文件添加水印。\n1 2 3 for pic in *.png; do composite -dissolve 30% watermark.png $pic ${pic//.png}-marked.png done 7.5 7-zip用法 7-zip制作tar.gz压缩包的方法：\n先将待压缩的目录或者文件压缩为tar格式的压缩包 然后再将tar包使用gzip进行压缩即可 8 实用网站 c语言编程书籍推荐\nC++书籍推荐\n操作系统相关知识库\nArchWiki: Arch Linux documentation\n在线LaTeX编辑网站\n计算机自学指南：涵盖计算机相关的网站、书籍等，内容丰富\n开源编程书籍\n计算机相关书籍推荐\n","date":"2024-11-30T19:06:41+08:00","permalink":"http://localhost:1313/post/tools/some_usful_tips/","tags":[""],"title":"程序员入门必读"},{"categories":["Tools"],"contents":"本文介绍markdown的语法和一些实用技巧。\n1 Markdown语法 Markdown语法在线文档\n2 Markdown使用说明 2.1 使用emoji表情符的方法 若markdown支持emoji表情符，直接将对应的表情符添加在文本中即可显示。例如：\n今天天气很好!:sunny:\n显示的结果为：今天天气很好! \u0026#x2600;\u0026#xfe0f;\nemoji表情符在线查询: https://github.com/ikatyang/emoji-cheat-sheet/blob/master/README.md\n2.2 Markdown表格单元格中输入多行内容的方法 方法1：在需要换行的地方添加\u0026lt;br\u0026gt;即可。示例： 动物 猫\n狗\n兔 方法2：在markdown中使用html的表格,转换为html后即可支持显示表格。\nPerson 1\rPerson 2\rPerson 3\rEmil\rTobias\rLinus\r16\n17\n18\r14\r10\r2.3 markdown中设置图片大小的方法 直接使用html中设置图片大小的方法即可，这样转换为html就可以符合预期了。\n1 \u0026lt;img src=\u0026#34;/web_image/about/badminton.svg\u0026#34; width=\u0026#34;30\u0026#34;\u0026gt; ","date":"2024-11-30T10:48:47+08:00","permalink":"http://localhost:1313/post/tools/markdown_usful_tips/","tags":["Markdown"],"title":"Markdown使用技巧"},{"categories":["Tools"],"contents":"本文介绍gdb一些常用命令。\n1 GDB的一些实用的文档 gdb cheat sheet 100-gdb-tips GDB User Manual GDB online 2 gdbinit文件的简单配置方法 在当前用户目录下创建文件：touch ~/.gdbinit\n在~/.gdbinit文件中添加常用的gdb命令即可。常用的配置如下：\n1 2 3 4 directory /usr/src/glibc/glibc-2.27/ # 指定源码所在目录 layout src # 显示源码模式 set pagination off # 输出信息较多时不会暂停输出 set confirm off # gdb退出时不显示提示信息 3 GDB常用命令 3.1 界面配置 命令 功能 layout src 显示源代码 layout asm 显示汇编代码 layout regs 显示寄存器内容 layout split 显示源代码和汇编窗口 layout next 显示下一个layout layout prev 显示上一个layout tui enable 显示layout窗口 tui disable 退出layout窗口 Ctrl + x -\u0026gt; o 在多个窗口间切换 3.2 单步执行 命令 功能 next/n 单步执行，不进入函数内部 step/s 单步执行，是函数则进入函数内部 until line-number 执行到指定行号 where 显示当前行号和当前所在的函数 3.3 断点调试 命令 功能 break/b \u0026lt;where\u0026gt; 在函数入口设置断点 enable \u0026lt;breakpoint\u0026gt; 打开断点 disable \u0026lt;breakpoint\u0026gt; 关闭断点 delete \u0026lt;breakpoint\u0026gt; 删除断点 clear 删除所有断点 info breakpoints [n] 查看断点 break \u0026lt;where\u0026gt; if \u0026lt;condition\u0026gt; 设置条件断点 示例:\n1 2 # 条件断点：第10行中，若变量i等于101则停止。 b 10 if i==101 3.4 观察点 命令 功能 watch \u0026lt;where\u0026gt;/variable 设置观察点 enable \u0026lt;breakpoint\u0026gt; 打开断点 disable \u0026lt;breakpoint\u0026gt; 关闭断点 delete \u0026lt;breakpoint\u0026gt; 删除断点 info watchpoints [n] 查看观察点 watch \u0026lt;where\u0026gt; if \u0026lt;condition\u0026gt; 设置条件观察点 rwatch/rw variable 设置读观察点 awatch/aw variable 设置读写观察点 watch expr thread threadnum 设置指定线程上的观察点 3.5 断点/观察点位置 命令 功能 function_name 函数名 line_num 行号 filenaem:line_num 文件+行号 addr 地址 3.6 打印信息 命令 功能 print \u0026lt;what\u0026gt; 打印指定内容 print /x $rbp-0x8 将计算结果按照16进制输出 print /x ($ebp+8) 将ebp+8内存中的内容按照16进制输出 info proc mappings 打印内存映射信息 x/nfu 0xaddr Examine the contents of memory and specify formatting.\nn: number of display items to print\nf: specify the format for the output\nu: specify the size of the data unit (eg. byte, word, \u0026hellip;)\nExample: x/4dw var n：输出单元的个数。\nf：是输出格式。比如 x 是以16进制形式输出， o 是以8进制形式输出,等等。\nu：标明一个单元的长度。\nb 是一个Byte(8 bit)\nh 是两个Byte （halfword）\nw 是四个Byte （word）\ng 是八个Byte （giant word）。\n3.7 查看栈帧 命令 功能 backtrace/bt 打印栈帧 frame/f \u0026lt;frame#\u0026gt; 显示指定栈帧 info frame 显示当前栈帧的信息 info locals 显示当前帧的局部变量信息 3.8 调试线程 命令 功能 set scheduler-locking on 只允许一个线程运行 set follow-fork-mode child 调试子进程 set detach-on-fork off 调试父子进程 show scheduler-locking 查看当前的调试模式 info threads 查看进程中的线程信息 thread \u0026lt;thread#\u0026gt; 切换调试线程 温馨提示：\n使用线程的调试模式，需要先使用start/run将程序运行起来后才可以设置。否则会提示Target 'exec' cannot support this command错误。\n3.9 修改程序中的值 命令 功能 set var \u0026lt;variable_name\u0026gt;=\u0026lt;value\u0026gt; 修改变量的值 return \u0026lt;expression\u0026gt; 强制将当前函数按照指定值返回 3.10 汇编运行 命令 功能 info line number 显示指定位置的汇编代码 stepi/si 单步运行汇编指令 nexti/ni 单步运行汇编指令 disassemble 0xstart 0xend 反汇编指定地址的代码 info registers 显示当前寄存器的值 info registers rip 仅显示pc的值 info registers rbp rsp 仅显示rbp, rsp的值 3.11 GDB打印C++ STL中常见结构的内容的方法 3.11.1 通用方法 1 2 3 //vector\u0026lt;int\u0026gt; vec = {1, 2, 3, 4, 5}; print *(vec._M_impl._M_start)@vec.size() print *(vec._M_impl._M_start)@n //print first n element 3.11.2 使用gdb脚本进行打印 使用方法见文章：GDB打印STL中各种容器的内容的方法\n","date":"2024-11-29T16:31:59+08:00","permalink":"http://localhost:1313/post/tools/gdb_usful_tips/","tags":["GDB"],"title":"GDB常用命令和一些实用方法"},{"categories":["数据结构"],"contents":"本文介绍二叉树的构造方式。\n1 二叉树的构造方法 1.1 通过前序遍历和中序遍历序列构造二叉树 前提条件：\npreorder 和 inorder 均 无重复 元素 inorder 均出现在 preorder preorder 保证 为二叉树的前序遍历序列 inorder 保证 为二叉树的中序遍历序列 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Solution { public: TreeNode* buildTree(vector\u0026lt;int\u0026gt;\u0026amp; preorder, vector\u0026lt;int\u0026gt;\u0026amp; inorder) { init_map(inorder); int left = 0; int right = inorder.size() - 1; int mid = node_idx[preorder[0]]; int left_len = mid - left; int right_len = right - mid; TreeNode* root = new TreeNode(preorder[0]); root-\u0026gt;left = innerBuildTree(preorder, inorder, left, mid - 1, left + 1, left + left_len); root-\u0026gt;right = innerBuildTree(preorder, inorder, mid + 1, right, left + left_len + 1, right); return root; } private: unordered_map\u0026lt;int, int\u0026gt; node_idx; void init_map(vector\u0026lt;int\u0026gt;\u0026amp; inorder) { for (int i = 0; i \u0026lt; inorder.size(); ++i) { node_idx[inorder[i]] = i; } } TreeNode* innerBuildTree(vector\u0026lt;int\u0026gt;\u0026amp; preorder, vector\u0026lt;int\u0026gt;\u0026amp; inorder, int left, int right, int pre_left, int pre_right) { if (left \u0026gt; right || pre_left \u0026gt; pre_right) { return nullptr; } int mid = node_idx[preorder[pre_left]]; int left_len = mid - left; int right_len = right - mid; TreeNode* node = new TreeNode(inorder[mid]); node-\u0026gt;left = innerBuildTree(preorder, inorder, left, mid - 1, pre_left + 1, pre_left + left_len); node-\u0026gt;right = innerBuildTree(preorder, inorder, mid + 1, right, pre_left + left_len + 1, pre_right); return node; } }; ","date":"2024-11-28T10:30:58+08:00","permalink":"http://localhost:1313/post/data_structure/tree/binary_tree_create/","tags":["二叉树"],"title":"创建二叉树的方法"},{"categories":["数据结构"],"contents":"本文介绍二叉树的遍历方法和具体代码实现。\n1 二叉树的遍历方法 二叉树的遍历方法根据访问根结点的先后顺序分为先序、中序、后序遍历。\n下面1.1，1.2，1.3节将分别介绍各种遍历方式的递归实现和非递归实现方法。\n1.1 二叉树的先序遍历 二叉树先序遍历的过程为：遍历根结点，先序遍历左子树，先序遍历右子树。\n1.1.1 二叉树先序遍历的递归实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public: vector\u0026lt;int\u0026gt; preorderTraversal(TreeNode* root) { preorder(root); return res; } void preorder(TreeNode* root) { if (root == NULL) { return; } res.push_back(root-\u0026gt;val); preorder(root-\u0026gt;left); preorder(root-\u0026gt;right); } private: vector\u0026lt;int\u0026gt; res; }; 1.1.2 二叉树先序遍历的非递归实现 先序遍历的非递归实现方式采用DFS的遍历算法，使用栈来保存中间结果。\n方法1：传统方式，首先将根结点添加至栈中，然后循环添加根结点的左孩子结点。\n当左孩子为空时，弹出栈顶结点，并将栈顶的右孩子结点作为根结点重复进行该过程。\n因为是先序遍历，因此所有结点在进栈前进行访问。具体代码如下所示： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public: vector\u0026lt;int\u0026gt; preorderTraversal(TreeNode* root) { vector\u0026lt;int\u0026gt; res; if (root == NULL) { return res; } stack\u0026lt;TreeNode*\u0026gt; stk; TreeNode* top = root; while (!stk.empty() || top) { while (top) { res.push_back(top-\u0026gt;val); stk.push(top); top = top-\u0026gt;left; } top = stk.top(); stk.pop(); top = top-\u0026gt;right; } return res; } }; 方法2：因为栈的特性是后进先出。入栈和出栈的顺序相反，因此可以利用这一特性简化代码流程：\n具体方法为：在根结点出栈前进行访问，然后分别将其右孩子和左孩子进栈。循环进行，直到栈为空为止。\n这样就会在访问的时候先访问左孩子再访问右孩子。具体实现方式如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public: vector\u0026lt;int\u0026gt; preorderTraversal(TreeNode* root) { vector\u0026lt;int\u0026gt; res; if (root == NULL) { return res; } stack\u0026lt;TreeNode*\u0026gt; stk; stk.push(root); while (!stk.empty()) { TreeNode* top = stk.top(); res.push_back(top-\u0026gt;val); stk.pop(); if (top-\u0026gt;right) { stk.push(top-\u0026gt;right); } if (top-\u0026gt;left) { stk.push(top-\u0026gt;left); } } return res; } }; 1.2 二叉树的中序遍历 二叉树先序遍历的过程为：中序序遍历左子树，遍历根结点，中序遍历右子树。\n1.2.1 二叉树的中序遍历的递归实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public: vector\u0026lt;int\u0026gt; inorderTraversal(TreeNode* root) { vector\u0026lt;int\u0026gt; res; inorder(root, res); return res; } void inorder(TreeNode* root, vector\u0026lt;int\u0026gt;\u0026amp; res) { if (root == nullptr) { return; } if (root-\u0026gt;left != nullptr) { inorder(root-\u0026gt;left, res); } res.emplace_back(root-\u0026gt;val); if (root-\u0026gt;right != nullptr) { inorder(root-\u0026gt;right, res); } } }; 1.2.2 二叉树的中序遍历的非递归实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public: vector\u0026lt;int\u0026gt; inorderTraversal(TreeNode* root) { vector\u0026lt;int\u0026gt; res; if (root == NULL) { return res; } stack\u0026lt;TreeNode*\u0026gt; stk; TreeNode* top = root; while (!stk.empty() || top) { while (top) { stk.push(top); top = top-\u0026gt;left; } top = stk.top(); res.push_back(top-\u0026gt;val); stk.pop(); top = top-\u0026gt;right; } return res; } }; 1.3 二叉树的后序遍历 二叉树先序遍历的过程为：中序序遍历左子树，遍历根结点，中序遍历右子树。\n1.3.1 二叉树的后序遍历的递归实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public: vector\u0026lt;int\u0026gt; postorderTraversal(TreeNode* root) { vector\u0026lt;int\u0026gt; res; postorder(root, res); return res; } void postorder(TreeNode* root, vector\u0026lt;int\u0026gt;\u0026amp; vec) { if (root == nullptr) { return; } postorder(root-\u0026gt;left, vec); postorder(root-\u0026gt;right, vec); vec.push_back(root-\u0026gt;val); } }; 1.3.2 二叉树的后序遍历的非递归实现 方法1：传统方法+访问标记 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public: vector\u0026lt;int\u0026gt; postorderTraversal(TreeNode* root) { vector\u0026lt;int\u0026gt; res; if (root == nullptr) { return res; } stack\u0026lt;pair\u0026lt;TreeNode*, bool\u0026gt;\u0026gt; stk; TreeNode* top = root; while (!stk.empty() || top) { while (top) { auto new_node = std::make_pair(top, false); stk.push(new_node); top = top-\u0026gt;left; } pair\u0026lt;TreeNode*, bool\u0026gt; head = stk.top(); stk.pop(); TreeNode* node = head.first; int sign = head.second; if (sign == false) { head.second = true; stk.push(head); top = node-\u0026gt;right; } else { res.push_back(node-\u0026gt;val); top = nullptr; } } return res; } }; 方法2：使用两个栈\n该方法类似于先序遍历的非递归方式中的方法2。\n只是为了得到中-右-左的序列，因此是先让左孩子入栈，再让右孩子入栈。\n最终的得到的序列和目标序列顺序相反，在使用一个栈将顺序调整过来即可。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public: vector\u0026lt;int\u0026gt; postorderTraversal(TreeNode* root) { vector\u0026lt;int\u0026gt; res; if (root == nullptr) { return res; } stack\u0026lt;TreeNode*\u0026gt; stk; stack\u0026lt;TreeNode*\u0026gt; stk_sec; stk.push(root); while (!stk.empty()) { TreeNode* top = stk.top(); stk.pop(); stk_sec.push(top); if (top-\u0026gt;left) { stk.push(top-\u0026gt;left); } if (top-\u0026gt;right) { stk.push(top-\u0026gt;right); } } while (!stk_sec.empty()) { TreeNode* top = stk_sec.top(); res.push_back(top-\u0026gt;val); stk_sec.pop(); } return res; } }; 方法3：使用一个栈\n原理同方法2：但是是通过特殊的先序遍历(遍历的方式为中-右-左的方式)的方式得到中-右-左的序列。 然后将得到的序列翻转一下即可。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public: vector\u0026lt;int\u0026gt; postorderTraversal(TreeNode* root) { vector\u0026lt;int\u0026gt; res; if (root == nullptr) { return res; } stack\u0026lt;TreeNode*\u0026gt; stk; TreeNode* top = root; while (!stk.empty() || top) { while (top) { res.push_back(top-\u0026gt;val); stk.push(top); top = top-\u0026gt;right; } top = stk.top(); stk.pop(); top = top-\u0026gt;left; } reverse(res.begin(), res.end()); return res; } }; 1.4 二叉树的层次遍历 二叉树的层次遍历实际上是对二叉树的广度优先遍历。\n原理参考BFS原理的讲解。具体代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; levelOrder(TreeNode* root) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res; if (root == NULL) { return res; } queue\u0026lt;TreeNode*\u0026gt; que_level; que_level.push(root); while (!que_level.empty()) { int que_size = que_level.size(); vector\u0026lt;int\u0026gt; level_vec; for (int i = 0; i \u0026lt; que_size; ++i) { TreeNode* head = que_level.front(); if (head-\u0026gt;left) { que_level.push(head-\u0026gt;left); } if (head-\u0026gt;right) { que_level.push(head-\u0026gt;right); } level_vec.push_back(head-\u0026gt;val); que_level.pop(); } res.push_back(level_vec); level_vec.clear(); } return res; } }; 2 二叉树的遍历方法总结 二叉树的前序中序、后序遍历都属于深度优先遍历(DFS)，而层次遍历属于广度优先遍历(BFS)。\n深度优先遍历需要使用栈作为存储中间过程的数据结构，而广度优先遍历需要使用队列作为中间过程的数据结构。 通过1.1,1.2,1.3的递归实现和非递归实现，我们不难发现。\n三种递归遍历方式实现代码较为简洁，三种遍历的方式的差异在于访问根结点的时机。迭代是访问根结点的时机和对应的遍历方式对应。\n三种非递归方式的实现都有可以使用传统遍历框架，区别在于访问结点的差异：\n先序遍历：先访问结点，再放入栈； 中序遍历：先放入栈，出栈时再访问结点； 后序遍历：增加标记，结点进栈两次，第二次出栈时再访问结点； 先序遍历和后续遍历：可以通过栈后进先出的特性调整顺序，简化操作。\n","date":"2024-11-27T11:11:07+08:00","permalink":"http://localhost:1313/post/data_structure/tree/binary_tree_traverse/","tags":["二叉树"],"title":"二叉树的遍历"},{"categories":["算法"],"contents":"本文讲解DFS算法的核心思想和代码基本框架。\n1 DFS算法的核心思想 DFS的英文全称为(Depth-first search),称为深度优先搜索算法。 该算法是用于在树形结构中按照某种规则搜索结点的算法。\n该算法的核心思想是从起始点出发，沿着某一条路径一直向前搜索，直到没有路径后结束。然后再回到起点继续遍历还未遍历的结点，直到遍历完所有结点。\n","date":"2024-11-26T16:31:22+08:00","permalink":"http://localhost:1313/post/algorithm/dfs/","tags":["DFS"],"title":"遍历-DFS"},{"categories":["算法"],"contents":"本文讲解BFS算法的核心思想和代码基本框架。\n1 BFS算法的核心思想 BFS的英文全称为(Breadth-first search),称为广度优先搜索算法。 该算法是用于在树形结构中按照某种规则搜索结点的算法。 该算法的核心思想是从起始点出发，依次遍历完起始点周围的结点，不断重复该过程直至扩散至所有结点。\n2 BFS算法的代码框架 基于BFS的特点：代码实现时，采用队列来保存每一轮迭代的结果。\n首次将起始点或初始状态的结点插入队列。 在出队列时，将和该结点关联的结点进队。 操作结束的条件：队列为空。 温馨提示：\n若需要区分每层遍历的结果，可以通过记录队列中元素的个数来实现。\n1 2 3 4 5 6 7 8 9 10 queue.push(root); while (!queue.empty()) { int size = 0; for (int idx = 0; idx \u0026lt; size; ++i) { head = queue.front(); xxx;// 执行和队列头部相关的操作 queue.push(head-\u0026gt;child); queue.pop(); } } ","date":"2024-11-26T16:29:32+08:00","permalink":"http://localhost:1313/post/algorithm/bfs/","tags":["BFS"],"title":"遍历-BFS"},{"categories":["操作系统"],"contents":"本文总结Linux系统启动的详细流程以及启动流程涉及的基础知识。\n1 Linux系统的传统启动流程 主机上电，运行BIOS MBR 进入引导程序(GRUB） 运行kernel init 2 BIOS和UEFI BIOS(Basic Input Output System) UEFI(Unified Extensible Firmware Interface)\n3 MBR和GPT MBR(Master Boot Record), GPT (GUID Partition Table),\n4 引导程序简介 5 常见linux发布版本启动的差异(CentOS/Ubuntu)","date":"2024-11-20T20:56:16+08:00","permalink":"http://localhost:1313/post/operating_system/linux_kernel/kernel_boot_process/","tags":["kernel_boot_process"],"title":"Kernel_boot_process"},{"categories":["Linux"],"contents":"本文记录Linux系统常用的系统设置的方法。\n1 Linux系统配置coredump的方法 1.1 临时配置方法 设置ulimit中core大小限制 执行命令：ulimit -c unlimited\n配置coredump的生成路径 执行命令：echo \u0026quot;/path/core-%e-%p-%s-%t\u0026quot; \u0026gt; /proc/sys/kernel/core_pattern\n该配置方法，当系统重启后就会失效。\n1.2 永久配置方法 配置当前用户的corefile size大小 在配置文件中增加一行配置项，如下所示： 1 2 #\u0026lt;domain\u0026gt; \u0026lt;type\u0026gt; \u0026lt;item\u0026gt; \u0026lt;value\u0026gt; root hard core 100000 其中，对于item为core的配置项，value的单位为KB.\n然后再/etc/profile文件中增加配置： 1 2 # No core files by default ulimit -S -c unlimited \u0026gt; /dev/null 2\u0026gt;\u0026amp;1 然后再进程的启动脚本中添加如下命令： 1 echo \u0026#34;/path/core-%e-%p-%s-%t\u0026#34; \u0026gt; /proc/sys/kernel/core_pattern 参考文档：\nHow to enable core file dumps when an application crashes or segmentation faults\n2 修改Hostname 2.1 通过命令修改 1 hostnamectl set-hostname new_host_name 2.2 修改配置文件 修改配置文件/etc/hostname中的名字即可（需要root权限）。\n3 Linux修改终端的显示 通过修改/etc/profile或者当前用户目录下的PS1变量既可以实现。\n参考链接： How to display current path in command prompt in linux\u0026rsquo;s sh (not bash)?\n1 2 3 4 # \\u username # \\h hostname # \\W Name of present folder (not full path) # \\w current path(pull path) 4 修改系统时区 1 2 3 4 5 6 7 8 # 查看系统中的时区 timedatectl list-timezones |grep -ai \u0026#34;shanghai\u0026#34; # 设置时区 timedatectl set-timezone Asia/Shanghai # 查询当前系统时区 timedatectl 5 date格式化时间 1 2 3 4 5 6 # 查看当前时间 date # 2025-08-06 21:34:01 date +\u0026#34;%F %T\u0026#34; date +\u0026#34;%Y-%m-%d %H:%M:%S\u0026#34; ","date":"2024-11-19T15:48:31+08:00","permalink":"http://localhost:1313/post/linux/linux_common_setting/","tags":["linux系统设置"],"title":"Linux系统常用的系统配置"},{"categories":["Tools"],"contents":"本文记录vim常用参数的配置方法已经常用命令。\n1.1 vim常用设置 1.1 增加vim配置文件的方法 新建~/.vimrc文件。\n1.2 vim 常用设置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 \u0026#34; Turn syntax highlighting on. syntax on \u0026#34; Add numbers to each line on the left-hand side. set number \u0026#34; Highlight cursor line underneath the cursor horizontally. set cursorline \u0026#34; Highlight cursor line underneath the cursor vertically. \u0026#34;set cursorcolumn \u0026#34; Set shift width to 4 spaces. set shiftwidth=4 \u0026#34; Set tab width to 4 columns. set tabstop=4 \u0026#34; Use space characters instead of tabs. set expandtab \u0026#34; Do not save backup files. set nobackup \u0026#34; Do not let cursor scroll below or above N number of lines when scrolling. set scrolloff=10 \u0026#34; Do not wrap lines. Allow long lines to extend as far as the line goes. set nowrap \u0026#34; While searching though a file incrementally highlight matching characters as you type. set incsearch \u0026#34; Ignore capital letters during search. \u0026#34;set ignorecase \u0026#34; Override the ignorecase option if searching for capital letters. \u0026#34; This will allow you to search specifically for capital letters. set smartcase \u0026#34; Show partial command you type in the last line of the screen. set showcmd \u0026#34; Show the mode you are on the last line. set showmode \u0026#34; Show matching words during a search. set showmatch \u0026#34; Use highlighting when doing a search. set hlsearch \u0026#34; Set the commands to save in history default number is 20. set history=1000 \u0026#34; set autoindent \u0026#34; Set c language auto indent set cindent 参考文档:\nVimrc Configuration Guide - How to Customize Your Vim Code Editor with Mappings, Vimscript, Status Line, and More\n2 vim常用命令 2.1 vim替换字符串命令 替换当前行\n命令：:s/foo/bar/g\n替换第 n 行开始到最后一行中字符串\n命令： n,$s/foo/bar/\n替换文件中所有行的字符串\n命令：:%s/foo/bar/g\n2.2 vim直接输入tab的方法 因为在vim配置文件中配置tab键转换为4个空格，因此在编写makefile时直接按tab间无法达到输入tab的目的。\n在编辑模式或者命令模式下(界面最下方有冒号)，先按快捷键ctrl+v，然后按tab键即可。\n2.3 vim中执行命令的方法 进入命令模式，输入!加在终端输入的命令即可。例如： :!./hello\t//执行hello\n2.4 vim在多行尾部添加内容的方法 使用Shift + v选中多行 然后按:进入命令模式 然后键入normal,进入normal模式 再normal后键入空格，在输入A ;即可在多行后添加分号;。\n命令最终的内容如下：:'\u0026lt;,'\u0026gt;normal A;，其中的'\u0026lt;,'\u0026gt;不需要输入。 ","date":"2024-11-19T15:17:40+08:00","permalink":"http://localhost:1313/post/tools/vim_usful_setting/","tags":["vim"],"title":"Vim常用设置以及常用命令"},{"categories":["操作系统"],"contents":"本文记录Ubutun操作系统常用的系统配置的设置方法和常用命令的用法。\n1 Ubuntu 18.04配置网络的方法 1.1 查看网卡 按照教程VirtualBox实现宿主机访问虚拟机以及虚拟机联网的方法配置好两张网卡，一张卡用于访问外网， 一张卡用于在windows中登陆虚拟机。\n1.2 编辑网卡配置文件 编辑网卡配置文件：sudo vim /etc/netplan/00-installer-config.yaml 注意：Ubuntu 18.04及以后版本不在使用/etc/network/interfaces文件配置网络。改为使用/etc/netplan/*.yaml文件。\n1 2 3 4 5 6 7 8 9 10 network: version: 2 ethernets: enp0s3: dhcp4: true nameservers: addresses: [223.5.5.5,223.6.6.6] enp0s8: dhcp4: false addresses: [192.168.56.8/24] 配置说明：enp0s3为网卡1，是用来访问外网使用的，使用动态IP。 enp0s8是用来访问内部网络的。设置为静态IP，IP和虚拟网卡的IP在同一个网段即可。不需要配置网关，配置网关会导致无法访问外网。 配置完成后，重启网络，即可生效：sudo netplan apply 配置完成后，可以查询到跟新后的网络配置。如下图所示： 备注：2204版本需要安装openvswitch-switch软件包。\n1.3 配置DNS的方法 查了下，这个服务的配置文件为 /etc/systemd/resolved.conf，大致内容如下：\n1 2 3 4 5 6 7 8 9 [Resolve] DNS=180.76.76.76 #FallbackDNS= #Domains= LLMNR=no #MulticastDNS=no #DNSSEC=no #Cache=yes #DNSStubListener=yes 如果我们要想让 /etc/resolve.conf 文件里的配置生效，需要添加到 systemd-resolved 的这个配置文件里 DNS 配置项（如上面的示例，已经完成修改），然后重启 systemd-resolved 服务即可： systemctl restart systemd-resolved.service 另一种更简单的办法是，我们直接停掉 systemd-resolved 服务，这样再修改 /etc/resolve.conf 就可以一直生效了。\n查看结果：systemd-resolve --status\n2 ubuntu系统配置apt源的方法 备份/etc/apt/sources.list文件 mv /etc/apt/sources.list /etc/apt/sourses.list.backup\n新建/etc/apt/sources.list文件并添加以下内容\n1 2 3 4 5 6 7 8 9 10 11 #163源 deb http://mirrors.163.com/ubuntu/ bionic main restricted universe multiverse deb http://mirrors.163.com/ubuntu/ bionic-security main restricted universe multiverse deb http://mirrors.163.com/ubuntu/ bionic-updates main restricted universe multiverse deb http://mirrors.163.com/ubuntu/ bionic-proposed main restricted universe multiverse deb http://mirrors.163.com/ubuntu/ bionic-backports main restricted universe multiverse deb-src http://mirrors.163.com/ubuntu/ bionic main restricted universe multiverse deb-src http://mirrors.163.com/ubuntu/ bionic-security main restricted universe multiverse deb-src http://mirrors.163.com/ubuntu/ bionic-updates main restricted universe multiverse deb-src http://mirrors.163.com/ubuntu/ bionic-proposed main restricted universe multiverse deb-src http://mirrors.163.com/ubuntu/ bionic-backports main restricted universe multiverse #中科大源 deb https://mirrors.ustc.edu.cn/ubuntu/ bionic main restricted universe multiverse deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-security main restricted universe multiverse deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic main restricted universe multiverse deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-security main restricted universe multiverse deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse\n#阿里云源 deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse\n#清华源 deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse\n1 2 3 4 5 6 7 8 9 10 # 3 apt常用命令 ```shell apt-get update # 更新源 apt-get install package # 安装包 apt-get remove package # 删除包 apt-get upgrade # 更新已安装的包 apt-cache search package # 查询软件包 apt list --installed # 查询系统已安装的软件包 4 Ubuntu设置root登陆的方法 使用安装系统时的高级用户解锁root用户\n1 sudo passwd root 设置root用户密码：\n1 sudo passwd -u root 切换到root用户，执行命令：su\n解除root用户登陆限制： 打开文件/etc/ssh/sshd_config, 找如下内容：\n1 2 3 4 5 #LoginGraceTime 2m #PermitRootLogin prohibit-password #StrictModes yes #MaxAuthTries 6 #MaxSessions 10 然后将配置修改为：\n1 2 3 4 5 LoginGraceTime 2m PermitRootLogin yes StrictModes yes MaxAuthTries 3 MaxSessions 10 然后重启ssh服务：systemctl restart ssh.service\n5 制作deb包的方法 创建工作目录并执行以下命令：\n1 2 # 假设创建的软件为：myProject mkdir myProject \u0026amp;\u0026amp; mkdir myProject/DEBIAN 拷贝文件至工作目录 将需要打包到deb包中的文件拷贝到工作目录中。\n若希望deb软件包安装后将二进制存在在指定目录下，需要在工作目录下提前创建好对应的目录，然后将文件拷贝到对应的目录下。\n例如，希望将test.sh安装在/usr/local/bin/目录下，按照如下步骤操作即可：\n1 2 mkdir -p myProject/usr/local/bin/; cp /usr/local/bin/test.sh myProject/usr/local/bin/ 创建配置文件 在DEBIAN目录下创建配置文件control，这个配置文件包含了软件的很多关键信息，例如：软件名称、版本、维护者、架构和描述信息等。\n创建post-installation文件 除以上几步以外，还可以添加post-installation文件，该文件用于在软件安装完成后执行一系列收尾工作。\n要添加该文件，需要在DEBIAN目录下创建名称为postinst的文件，并且确保该文件可以执行。\n创建软件包 切换到在工作目录所在目录，然后执行命令创建软件包：dpkg-deb --build myProject 创建的软件包会保存在工作目录下。\n可以使用如下命令安装文件： dpkg -i myProject.deb\n6 查询系统版本的方法 1 2 3 4 5 # 方法1 cat /etc/os-release # 方法2 lsb_release -a 7 Ubuntu安装常用工具 1 2 3 4 5 # 包含ifconfig apt install net-tools # 包含ncat工具 apt-get install nmap ","date":"2024-11-19T15:17:20+08:00","permalink":"http://localhost:1313/post/operating_system/ubuntu_setting/","tags":["ubuntu"],"title":"Ubuntu系统常用设置和命令"},{"categories":["数据结构"],"contents":"本文介绍LRU的原理和具体c代码实现。\nLRU的英文全称为Least Recently Used，即最近最少使用。该算法为cache淘汰算法，将最近最少使用的元素淘汰掉。具体代码是由hashTable和一个双向链表实现的。\n使用双向链表存放key-value，使用哈希表存储双向链表的结点地址，保证访问结点的复杂度为 $O(1)$。通常来讲，对数据的读写都算做对数据的访问。\n1 LRU的C代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;assert.h\u0026gt; /* define struct start */ #define FREE(ptr) \\ free(ptr); \\ ptr = NULL; typedef int KEY; typedef int VAL; typedef struct ForwardListNode { KEY key; VAL val; struct ForwardListNode* prev; struct ForwardListNode* next; } ForwardListNode; typedef struct HashNode { ForwardListNode* dNode; struct HashNode* next; } HashNode; typedef struct HashTable { HashNode** bucket; int (*destroy)(struct HashTable* tb); int (*hash)(struct HashTable* tb, KEY key); int (*insert)(struct HashTable* tb, HashNode* node); int (*remove)(struct HashTable* tb, KEY key); HashNode* (*find)(struct HashTable* tb, KEY key); int bucket_num; } HashTable; typedef struct { ForwardListNode* head; HashTable* ht; int capacity; int size; } LRUCache; /* ------------------------ */ /* LinkList function start */ int insertListNode(HashNode** head, HashNode* node) { if (*head == NULL) { *head = node; return 0; } node-\u0026gt;next = *head; *head = node; return 0; } int removeListNode(HashNode** head, HashNode* node) { if (*head == node) { *head = (*head)-\u0026gt;next; FREE(node); return 0; } HashNode* prev = *head; HashNode* cur = (*head)-\u0026gt;next; while (cur) { if (cur == node) { prev-\u0026gt;next = cur-\u0026gt;next; FREE(node); return 0; } prev = prev-\u0026gt;next; cur = cur-\u0026gt;next; } return -1; } HashNode* findListNode(HashNode* head, KEY key) { if (head == NULL) { return NULL; } while (head) { if (head-\u0026gt;dNode-\u0026gt;key == key) { return head; } head = head-\u0026gt;next; } return NULL; } void ListNodeDestroy(HashNode* head) { if (head == NULL) { return; } HashNode* cur = head; while (cur) { HashNode* prev = cur-\u0026gt;next; FREE(cur); cur = prev; } } /* ------------------------ */ /* HashTable function */ HashNode* initHashNode(ForwardListNode* node) { HashNode* hNode = (HashNode*)malloc(sizeof(HashNode)); if (hNode == NULL) { return NULL; } hNode-\u0026gt;dNode = node; hNode-\u0026gt;next = NULL; return hNode; } int hashFunc(HashTable* tb, KEY key) { return key % tb-\u0026gt;bucket_num; } HashNode* findHashNode(HashTable* tb, KEY key) { int index = tb-\u0026gt;hash(tb, key); assert(index \u0026gt;= 0 \u0026amp;\u0026amp; index \u0026lt; tb-\u0026gt;bucket_num); return findListNode(tb-\u0026gt;bucket[index], key); } int insertHashNode(HashTable* tb, HashNode* node) { int index = tb-\u0026gt;hash(tb, node-\u0026gt;dNode-\u0026gt;key); assert(index \u0026gt;= 0 \u0026amp;\u0026amp; index \u0026lt; tb-\u0026gt;bucket_num); return insertListNode(\u0026amp;tb-\u0026gt;bucket[index], node); } int removeHashNode(HashTable* tb, KEY key) { int index = tb-\u0026gt;hash(tb, key); assert(index \u0026gt;= 0 \u0026amp;\u0026amp; index \u0026lt; tb-\u0026gt;bucket_num); if (tb-\u0026gt;bucket[index] == NULL) { return -1; } HashNode** head = \u0026amp;tb-\u0026gt;bucket[index]; HashNode* node = findListNode(*head, key); return removeListNode(head, node); } HashTable* initHashTableMem(void) { HashTable* ht = (HashTable*)malloc(sizeof(HashTable)); if (ht == NULL) { return NULL; } memset(ht, 0, sizeof(HashTable)); return ht; } int destroyHashTable(struct HashTable* tb) { for (int i = 0; i \u0026lt; tb-\u0026gt;bucket_num; ++i) { HashNode* head = tb-\u0026gt;bucket[i]; if (head == NULL) { continue; } ListNodeDestroy(head); } FREE(tb-\u0026gt;bucket); FREE(tb); return 0; } int initializeHashTable(struct HashTable* tb, int num) { tb-\u0026gt;hash = hashFunc; tb-\u0026gt;insert = insertHashNode; tb-\u0026gt;remove = removeHashNode; tb-\u0026gt;find = findHashNode; tb-\u0026gt;destroy = destroyHashTable; if (num == 0) { printf(\u0026#34;input bucket num must greater then 0.\\n\u0026#34;); return -1; } tb-\u0026gt;bucket_num = num; tb-\u0026gt;bucket = (HashNode**)malloc(sizeof(HashNode*) * num); if (tb-\u0026gt;bucket == NULL) { printf(\u0026#34;malloc failed.\\n\u0026#34;); return -1; } memset(tb-\u0026gt;bucket, 0, sizeof(HashNode*) * num); return 0; } /*------------------------------------------*/ /* forward_list function */ ForwardListNode* initForwardListNode(KEY key, VAL val) { ForwardListNode* DNode = (ForwardListNode*)malloc(sizeof(ForwardListNode)); if (DNode == NULL) { return NULL; } DNode-\u0026gt;key = key; DNode-\u0026gt;val = val; DNode-\u0026gt;prev = DNode; DNode-\u0026gt;next = DNode; return DNode; } void insertToHead(ForwardListNode* head, ForwardListNode* node) { if (head-\u0026gt;next != head) { node-\u0026gt;next = head-\u0026gt;next; head-\u0026gt;next-\u0026gt;prev = node; head-\u0026gt;next = node; node-\u0026gt;prev = head; } else { head-\u0026gt;next = node; head-\u0026gt;prev = node; node-\u0026gt;prev = head; node-\u0026gt;next = head; } } void removeFromTail(ForwardListNode* head) { if (head-\u0026gt;next != head) { ForwardListNode* tail = head-\u0026gt;prev; tail-\u0026gt;next-\u0026gt;prev = tail-\u0026gt;prev; tail-\u0026gt;prev-\u0026gt;next = tail-\u0026gt;next; FREE(tail); } } void updateForwardList(ForwardListNode* head, ForwardListNode* node) { if (head == NULL) { return; } node-\u0026gt;prev-\u0026gt;next = node-\u0026gt;next; node-\u0026gt;next-\u0026gt;prev = node-\u0026gt;prev; insertToHead(head, node); } void destroyForwardListNode(ForwardListNode* head) { if (head == NULL) { return; } ForwardListNode* cur = head-\u0026gt;next; while (cur \u0026amp;\u0026amp; cur != head) { ForwardListNode* next = cur-\u0026gt;next; FREE(cur); cur = next; } FREE(head); } /*------------------------------------------*/ /* LRUCache function */ LRUCache* lRUCacheCreate(int capacity) { LRUCache* lru = (LRUCache*)malloc(sizeof(LRUCache)); if (lru == NULL) { return NULL; } memset(lru, 0, sizeof(LRUCache)); lru-\u0026gt;head = initForwardListNode(-1, -1); if (lru-\u0026gt;head == NULL) { FREE(lru); } lru-\u0026gt;ht = initHashTableMem(); if (lru-\u0026gt;ht == NULL) { FREE(lru-\u0026gt;head); FREE(lru); return NULL; } int ret = initializeHashTable(lru-\u0026gt;ht, capacity); if (ret != 0) { FREE(lru-\u0026gt;ht); FREE(lru-\u0026gt;head); FREE(lru); return NULL; } lru-\u0026gt;size = 0; lru-\u0026gt;capacity = capacity; return lru; } int lRUCacheGet(LRUCache* obj, int key) { HashTable* ht = obj-\u0026gt;ht; ForwardListNode* DouList = obj-\u0026gt;head; HashNode* node = ht-\u0026gt;find(ht, key); if (node == NULL) { return -1; } updateForwardList(DouList, node-\u0026gt;dNode); return node-\u0026gt;dNode-\u0026gt;val; } void lRUCachePut(LRUCache* obj, int key, int value) { HashTable* ht = obj-\u0026gt;ht; ForwardListNode* DouListHead = obj-\u0026gt;head; int index = ht-\u0026gt;hash(ht, key); HashNode* hNode = findListNode(ht-\u0026gt;bucket[index], key); if (hNode == NULL) { ForwardListNode* dNode = initForwardListNode(key, value); if (dNode == NULL) { printf(\u0026#34;mem alloc failed.\\n\u0026#34;); return; } HashNode* new_node = initHashNode(dNode); if (new_node == NULL) { FREE(dNode); printf(\u0026#34;mem alloc failed.\\n\u0026#34;); return; } insertToHead(DouListHead, dNode); insertListNode(\u0026amp;ht-\u0026gt;bucket[index], new_node); ++obj-\u0026gt;size; // del node from tail if (obj-\u0026gt;size \u0026gt; obj-\u0026gt;capacity) { ForwardListNode* tail = DouListHead-\u0026gt;prev; ht-\u0026gt;remove(ht, tail-\u0026gt;key); removeFromTail(DouListHead); obj-\u0026gt;size--; } } else { if (hNode-\u0026gt;dNode-\u0026gt;val != value) { hNode-\u0026gt;dNode-\u0026gt;val = value; } updateForwardList(DouListHead, hNode-\u0026gt;dNode); } } void lRUCacheFree(LRUCache* obj) { destroyForwardListNode(obj-\u0026gt;head); obj-\u0026gt;ht-\u0026gt;destroy(obj-\u0026gt;ht); FREE(obj); } 1.1 关键函数功能简介 LRU的代码实现可以分为4部分。\n1.1.1 单向链表的操作 int insertListNode(HashNode** head, HashNode* node)\n功能说明：向单链表的头部插入一个结点\nint removeListNode(HashNode** head, HashNode* node)\n功能说明：从单链表中移出指定的结点\nHashNode* findListNode(HashNode* head, KEY key)\n功能说明： 在单链表中查找包含指定key的结点\nvoid ListNodeDestroy(HashNode* head)\n功能说明：销毁单链表\n1.1.2 双向链表的操作 ForwardListNode* initForwardListNode(KEY key, VAL val)\n功能说明：构造双向链表的结点。\nvoid insertToHead(ForwardListNode* head, ForwardListNode* node)\n功能说明：向双向链表的头部插入一个结点。\nvoid removeFromTail(ForwardListNode* head)\n功能说明：从双向链表的尾部删除一个结点\nvoid updateForwardList(ForwardListNode* head, ForwardListNode* node)\n功能说明：更新双向链表中的结点，即将指定结点移动到双向链表的头部。\nvoid destroyForwardListNode(ForwardListNode* head)\n功能说明：销毁双向链表\n温馨提示：\n双向链表的遍历操作和单向链表不同,通过判断cur == head作为判断循环终止的条件。\n1.1.3 哈希表的操作 HashNode* initHashNode(ForwardListNode* node)\n功能说明：初始化哈希表的结点\nint hashFunc(HashTable* tb, KEY key)\n功能说明：哈希函数\nHashNode* findHashNode(HashTable* tb, KEY key)\n功能说明：根据key查找哈希结点\nint insertHashNode(HashTable* tb, HashNode* node)\n功能说明： 插入一个哈希结点\nint removeHashNode(HashTable* tb, KEY key)\n功能说明： 删除一个哈希结点\nHashTable* initHashTableMem(void)\n功能说明： 初始化哈希表\nint destroyHashTable(struct HashTable* tb)\n功能说明： 销毁哈希表\nint initializeHashTable(struct HashTable* tb, int num)\n功能说明： 初始化哈希表中的成员\n1.1.4 LRU相关的操作 LRUCache* lRUCacheCreate(int capacity)\n功能说明：创建LRU\nint lRUCacheGet(LRUCache* obj, int key)\n功能说明：查询lru中是否存在key\nvoid lRUCachePut(LRUCache* obj, int key, int value)\n功能说明：向LRU中插入指定的key-value\nvoid lRUCacheFree(LRUCache* obj)\n功能说明： 销毁LRU\n1.1.4 LRU程序的测试代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 void printHashTable(HashTable* tb); void printLruCache(LRUCache* lru); int main(void) { LRUCache* lru = lRUCacheCreate(2); printf(\u0026#34;Put (1,1) \u0026#34;); lRUCachePut(lru, 1, 1); printLruCache(lru); printf(\u0026#34;Put (2,2) \u0026#34;); lRUCachePut(lru, 2, 2); printLruCache(lru); printf(\u0026#34;Get 1 \u0026#34;); int ret = lRUCacheGet(lru, 1); printf(\u0026#34;get(1) ret:%d.\\n\u0026#34;, ret); printLruCache(lru); printf(\u0026#34;Put (3,3) \u0026#34;); lRUCachePut(lru, 3, 3); printLruCache(lru); printf(\u0026#34;Get 2 2 \u0026#34;); ret = lRUCacheGet(lru, 2); printf(\u0026#34;get(2) ret:%d.\\n\u0026#34;, ret); printLruCache(lru); printf(\u0026#34;Put (4,4) \u0026#34;); lRUCachePut(lru, 4, 4); printLruCache(lru); printf(\u0026#34;Get 1 \u0026#34;); ret = lRUCacheGet(lru, 1); printf(\u0026#34;get(1) ret:%d.\\n\u0026#34;, ret); printLruCache(lru); printf(\u0026#34;Put (3,3) \u0026#34;); lRUCachePut(lru, 3, 3); printLruCache(lru); lRUCacheFree(lru); return 0; } void printLruCache(LRUCache* lru) { DouListNode* cur = lru-\u0026gt;head-\u0026gt;next; printf(\u0026#34;LRUCache num: %d.\\n\u0026#34;, lru-\u0026gt;size); while (cur != lru-\u0026gt;head) { printf(\u0026#34;[%d|%d|-]-\u0026gt;\u0026#34;, cur-\u0026gt;key, cur-\u0026gt;val); cur = cur-\u0026gt;next; } printf(\u0026#34;\\n\\n\u0026#34;); return; } void printListNode(HashNode* head) { if (head == NULL) { return; } while (head) { printf(\u0026#34;[%d|%d|-]-\u0026gt;\u0026#34;, head-\u0026gt;dNode-\u0026gt;key, head-\u0026gt;dNode-\u0026gt;val); head = head-\u0026gt;next; } printf(\u0026#34;\\n\u0026#34;); } void printHashTable(HashTable* tb) { for (int i = 0; i \u0026lt; tb-\u0026gt;bucket_num; ++i) { HashNode* head = tb-\u0026gt;bucket[i]; if (head == NULL) { continue; } printf(\u0026#34;index：%d, \u0026#34;, i); printListNode(head); } } 2 LRU的c++代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 struct DNode { DNode() : key(-1), value(-1), prev(nullptr), next(nullptr) {} DNode(int k, int v) : key(k), value(v), prev(nullptr), next(nullptr) {} int key; int value; DNode* prev; DNode* next; }; class LRUCache { public: LRUCache(int capacity) { cap = capacity; size = 0; head = new DNode(); tail = new DNode(); head-\u0026gt;next = tail; head-\u0026gt;prev = tail; tail-\u0026gt;prev = head; tail-\u0026gt;next = head; } int get(int key) { auto item = hashTable.find(key); if (item != hashTable.end()) { DNode* node = item-\u0026gt;second; removeNode(node); insertNodeToHead(node); return node-\u0026gt;value; } return -1; } void put(int key, int value) { auto item = hashTable.find(key); if (item != hashTable.end()) { DNode* node = item-\u0026gt;second; if (node-\u0026gt;value != value) { node-\u0026gt;value = value; } removeNode(node); insertNodeToHead(node); } else { DNode* node = new DNode(key, value); hashTable[key] = node; insertNodeToHead(node); ++size; if (size \u0026gt; cap) { --size; DNode* lastNode = tail-\u0026gt;prev; hashTable.erase(lastNode-\u0026gt;key); removeNode(lastNode); delete lastNode; } } } private: unordered_map\u0026lt;int, DNode*\u0026gt; hashTable; DNode* head; DNode* tail; int cap; int size; void removeNode(DNode* node) { node-\u0026gt;prev-\u0026gt;next = node-\u0026gt;next; node-\u0026gt;next-\u0026gt;prev = node-\u0026gt;prev; } void insertNodeToHead(DNode* node) { node-\u0026gt;next = head-\u0026gt;next; node-\u0026gt;prev = head; head-\u0026gt;next-\u0026gt;prev = node; head-\u0026gt;next = node; } }; ","date":"2024-11-18T17:06:55+08:00","permalink":"http://localhost:1313/post/data_structure/hash_table/lru/","tags":["哈希表","单向链表","双向链表"],"title":"LRU的C代码实现"},{"categories":["Linux"],"contents":"本文主要记录c语言编码过程中的一些注意事项。\n1 C语言编码注意事项 1.1 申请的动态内存一定要做初始化工作 例如：如下所示的代码，若未对table-\u0026gt;bucket指针数组赋初值，该数组中就有可能存在非法值，导致代码访问到非法内存。\n1 2 3 4 5 6 7 8 9 10 11 12 int initHashTable(HashTable* table, int bucket_num) { table-\u0026gt;bucket_num = bucket_num; table-\u0026gt;bucket = (HashNode**)malloc(sizeof(HashNode*) * bucket_num); if (table-\u0026gt;bucket == NULL) { printf(\u0026#34;Alloc memory failed.\\n\u0026#34;); return -1; } // 此处一定要做初始化工作，否则可能存在非法内存访问的情况 memset(table-\u0026gt;bucket, 0, sizeof(HashNode*) * bucket_num); return 0; } 1.2 对结构体变量初始化时，需要初始化所有的变量 实例如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 struct ListNode { int val; struct ListNode *next; }; ListNode* initNode(int val) { ListNode* node = (ListNode*)malloc(sizeof(ListNode)); if (node == NULL) { return NULL; } node-\u0026gt;val = val; // 注意此处一定要初始化，否则有可能访问到非法内存 node-\u0026gt;next = NULL; } 1.3 c语言初始化数组的方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 //Unless that value is 0 (in which case you can omit some part of the initializer and //the corresponding elements will be initialized to 0), there\u0026#39;s no easy way. //Don\u0026#39;t overlook the obvious solution, though: int myArray[10] = { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 }; //Elements with missing values will be initialized to 0: // initialize to 1,2,0,0,0... int myArray[10] = { 1, 2 }; //So this will initialize all elements to 0: int myArray[10] = { 0 }; // all elements 0 //In C++, an empty initialization list will also initialize every element to 0. This is not allowed with C: int myArray[10] = {}; // all elements 0 in C++ //Remember that objects with static storage duration will initialize to 0 if no initializer is specified: static int myArray[10]; // all elements 0 1.4 字符数组初始化的方法 1 2 3 4 5 6 7 8 9 //If you don\u0026#39;t want to change the strings, then you could simply do const char *a[2]; a[0] = \u0026#34;blah\u0026#34;; a[1] = \u0026#34;hmm\u0026#34;; //If you do want to be able to change the actual string content, the you have to do something like char a[2][14]; strcpy(a[0], \u0026#34;blah\u0026#34;); strcpy(a[1], \u0026#34;hmm\u0026#34;); 1.5 16进制字符串转换为整数字符串 1 2 3 4 5 char str[] = \u0026#34;0x1800785\u0026#34;; int num; sscanf(str, \u0026#34;%x\u0026#34;, \u0026amp;num); printf(\u0026#34;0x%x %i\\n\u0026#34;, num, num); 1.6 typedef用法 1 2 3 4 5 6 7 // typedef existing_name alias_name; typedef unsigned int UINT; typedef struct Node { int val; struct Node* next; } Node; 2 C语言中和指针相关知识 2.1 与指针有关的函数声明 1 2 3 4 5 6 7 8 //声明返回指针数组的函数 int (*func(int i))[10]; //声明一个指向函数的指针(pf) bool (*pf)(const string \u0026amp;, const string \u0026amp;); //声明一个名字为pf的函数，该函数返回bool* bool *pf(cosnt string\u0026amp;, const string \u0026amp;); //声明一个返回函数指针的函数 int (*f1(int))(int *, int); 2.2 与指针有关的数组声明 指针数组：array of pointers，即用于存储指针的数组,也就是数组元素都是指针\n数组指针：a pointer to an array，即指向数组的指针\n例如： int* a[4] 指针数组\n表示：数组a中的元素都为int型指针\n元素表示： *a[i]和*(a[i])是一样的，因为[]优先级高于*\nint (*a)[4] 数组指针 表示：指向数组a的指针 元素表示：(*a)[i] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 int main(){ int c[4]={1,2,3,4}; int *a[4]; //指针数组 int (*b)[4]; //数组指针 b=\u0026amp;c; //将数组c中元素赋给数组a for(int i=0;i\u0026lt;4;i++){ a[i]=\u0026amp;c[i]; } //输出看下结果 cout\u0026lt;\u0026lt;*a[1]\u0026lt;\u0026lt;endl; //输出2就对 cout\u0026lt;\u0026lt;(*b)[2]\u0026lt;\u0026lt;endl; //输出3就对 return 0; } 2.3 数组名和指针的区别 2.3.1 数组名不是指针 验证程序：\n1 2 3 int data[10]; cout \u0026lt;\u0026lt; sizeof(data) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; data \u0026lt;\u0026lt; \u0026amp;data \u0026lt;\u0026lt; endl; 说明：第一行的输出结果为40，说明data不是一个指针，编译器将data当作一个数组来处理。此处data为包含10个整型元素的数组。\n2.3.2 数组名作为常量指针 数组名可以转换为指向其指代实体的指针，而且是一个指针常量。该指针指向数组的第一个元素。\n验证程序：\n1 2 3 4 5 6 char str1[10] = \u0026#34;I Love U\u0026#34;; str1++;\t//该语句编译时会出错，因为str1是常量 strcpy(str2, str1);\t//标记2 cout \u0026lt;\u0026lt; \u0026#34;string array 1: \u0026#34; \u0026lt;\u0026lt; str1 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;string array 2: \u0026#34; \u0026lt;\u0026lt; str2 \u0026lt;\u0026lt; endl; 说明：标准C库函数strcpy的函数原形中能接纳的两个参数都为char型指针，而我们在调用中传给它的却是两个数组名。\n2.3.3 指向数组的指针 指向数组的指针则是另外一种变量类型(在32平台下，长度为4），仅仅意味着数组的存放地址。\n验证程序：\n1 2 3 char str1[10] = \u0026#34;I Love U\u0026#34;; char *pStr = str; //标记1 cout \u0026lt;\u0026lt; sizeof(pStr) \u0026lt;\u0026lt; endl; 2.3.4 数组名当作函数实参 数组名在当作实参传入函数内部时，失去数组名的特性，成为普通的指针。\n1 2 3 4 5 6 7 8 9 10 #include \u0026lt;iostream\u0026gt; void arrayTest(char str[]){ cout \u0026lt;\u0026lt; sizeof(str) \u0026lt;\u0026lt; endl; } int main() { char str1[10] = \u0026#34;I Love U\u0026#34;; arrayTest(str1); return 0; } 说明：程序的输出结果为4。\n(1) 数组名作为函数形参时，在函数体内，其失去了本身的内涵，仅仅只是一个指针；\n(2) 很遗憾，在失去其内涵的同时，它还失去了其常量特性，可以作自增、自减等操作，可以被修改。\n3 glibc源码阅读 3.1 实用gdb阅读glibc接口的方法 将glibc源码下载到本地，并解压。 在gdb中添加glibc源码路径； 方法1：在.gdbinit文件中添加命令directory glibc_src_path 方法2：gdb调试二进制时，增加-d参数:-d directory 3.2 理解glibc的简单方法：使用musl libc库 musl libc库实现了和glibc一样的功能，但是代码更简洁易懂。\n可以通过阅读这个代码理解glibc中接口是如何实现的。\nmusl libc库网址\n","date":"2024-11-17T21:39:06+08:00","permalink":"http://localhost:1313/post/linux/c_language_usful_tips/","tags":["c语言"],"title":"c语言基础和编码注意事项"},{"categories":["数据结构"],"contents":"本文介绍哈希表的基本特性和具体实现。\n1 哈希表的基本特性 哈希表产生的背景：因为数组的数组的查找复杂度为$O(n)$, 为了\n2 哈希表(拉链法)的c语言实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;assert.h\u0026gt; #define FREE(ptr) \\ free(ptr); \\ ptr = NULL; typedef int KEY; typedef int VALUE; // hashTable的结点定义 struct HashNode { KEY key; VALUE value; struct HashNode* next; }; typedef struct HashNode HashNode; // hashTable的定义 struct HashTable { int (*initHashTable)(struct HashTable* table, int bucket_num); // init function void (*destroyHashTable)(struct HashTable* table); // destroy function int (*hashFunc)(struct HashTable* table, KEY key); // hash function HashNode* (*find)(struct HashTable* table, KEY key); // find function void (*insertHashNode)(struct HashTable* table, HashNode* node); // insert function HashNode** bucket; // bucket array int bucket_num; // bucket num }; typedef struct HashTable HashTable; int initHashTable(HashTable* table, int bucket_num) { table-\u0026gt;bucket_num = bucket_num; table-\u0026gt;bucket = (HashNode**)malloc(sizeof(HashNode*) * bucket_num); if (table-\u0026gt;bucket == NULL) { printf(\u0026#34;Alloc memory failed.\\n\u0026#34;); return -1; } memset(table-\u0026gt;bucket, 0, sizeof(HashNode*) * bucket_num); return 0; } HashNode* findLinkListNode(HashNode* head, KEY key) { if (head == NULL) { return NULL; } while (head) { if (head-\u0026gt;key == key) { return head; } head = head-\u0026gt;next; } return NULL; } void destroyLinkList(HashNode* head) { if (head == NULL) { return; } HashNode* cur = head-\u0026gt;next; while (cur) { HashNode* prev = cur-\u0026gt;next; head-\u0026gt;next = prev; FREE(cur); cur = head-\u0026gt;next; } } void destroyHashTable(HashTable* table) { int num = table-\u0026gt;bucket_num; HashNode** arr = table-\u0026gt;bucket; for (int i = 0; i \u0026lt; num; ++i) { if (arr[i]) { destroyLinkList(arr[i]); } } FREE(arr); FREE(table); } int hashFunc(HashTable* table, KEY key) { return key % table-\u0026gt;bucket_num; } HashNode* findHashNode(HashTable* table, KEY key) { int index = table-\u0026gt;hashFunc(table, key); assert(index \u0026gt;= 0 \u0026amp;\u0026amp; index \u0026lt; table-\u0026gt;bucket_num); return findLinkListNode(table-\u0026gt;bucket[index], key); } void insertHashNode(HashTable* table, HashNode* node) { if (node == NULL) { return; } int index = table-\u0026gt;hashFunc(table, node-\u0026gt;key); assert(index \u0026gt;= 0 \u0026amp;\u0026amp; index \u0026lt; table-\u0026gt;bucket_num); HashNode* head = table-\u0026gt;bucket[index]; if (head) { HashNode* prev = head-\u0026gt;next; node-\u0026gt;next = prev; head-\u0026gt;next = node; } else { table-\u0026gt;bucket[index] = node; } } HashTable* InitializeHashTable(void) { HashTable* table = (HashTable*)malloc(sizeof(HashTable)); if (table == NULL) { printf(\u0026#34;Melloc memory failed.\\n\u0026#34;); return NULL; } memset(table, 0, sizeof(HashTable)); table-\u0026gt;initHashTable = initHashTable; table-\u0026gt;destroyHashTable = destroyHashTable; table-\u0026gt;hashFunc = hashFunc; table-\u0026gt;findHashNode = findHashNode; table-\u0026gt;insertHashNode = insertHashNode; return table; } HashNode* initHashNode(KEY key, VALUE value) { HashNode* node = (HashNode*)malloc(sizeof(HashNode)); if (node == NULL) { printf(\u0026#34;Melloc memory failed.\\n\u0026#34;); return NULL; } node-\u0026gt;key = key; node-\u0026gt;value = value; node-\u0026gt;next = NULL; return node; } 3 哈希函数 针对key为整数的情况，直接使用对桶大小取余的方式就可以。但是针对复杂的key，例如key为一个链表结点的地址，就需要更加复杂的哈希函数。以下是针对复杂的key的哈希算法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 size_t _Hash_bytes(const void* ptr, size_t len, size_t seed) { size_t hash = seed; const uint8_t* cptr = (const uint8_t*)(ptr); for (; len; --len) { hash = (hash * 131) + *cptr++; } return hash; } int hashFunc(HashTable* table, KEY key) { const void* ptr = (const void*)(key); size_t hash = _Hash_bytes(ptr, 2, rand()); return abs(hash) % table-\u0026gt;bucket_num; } ","date":"2024-11-16T22:09:29+08:00","permalink":"http://localhost:1313/post/data_structure/hash_table/hash_table/","tags":["哈希表"],"title":"哈希表"},{"categories":["数据结构"],"contents":"本文主要介绍单链表常见的功能函数。\n1 单链表常见功能函数 链表相关的功能有：反转链表，获取链表的长度，获取链表的中间结点，判断两条链表是否相加，判断链表是否有环，合并两个有序链表等。\n1.1 翻转单链表 1.1.1 迭代方式翻转单链表 迭代方式翻转链表也称为链表头插法。\n方法1：新增一个临时头结点 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // 新增额外头结点的 struct ListNode* reverseList(struct ListNode* head) { if (head == NULL || head-\u0026gt;next == NULL) { return head; } struct ListNode* headp = (struct ListNode*)malloc(sizeof(struct ListNode)); headp-\u0026gt;val = 0; headp-\u0026gt;next = NULL; struct ListNode* tail = NULL; struct ListNode* cur = head; while (cur) { struct ListNode* pre = cur-\u0026gt;next; tail = headp-\u0026gt;next; headp-\u0026gt;next = cur; cur-\u0026gt;next = tail; cur = pre; } cur = headp-\u0026gt;next; free(headp); headp = NULL; return cur; } 方法2：不新增头结点，进行翻转 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 struct ListNode* reverseList(struct ListNode* head) { if (head == NULL || head-\u0026gt;next == NULL) { return head; } struct ListNode* cur = head-\u0026gt;next; head-\u0026gt;next = NULL; while (cur) { struct ListNode* pre = cur-\u0026gt;next; cur-\u0026gt;next = head; head = cur; cur = pre; } return head; } 1.1.2 递归方式翻转单链表 递归方式代码比较简单，但是要不太容易理解。递归的关键是抽象出一个通用的模型以及边界条件的处理。\n1 2 3 4 5 6 7 8 9 10 11 12 struct ListNode* reverseList(struct ListNode* head) { if (head == NULL || head-\u0026gt;next == NULL) { return head; } struct ListNode* prev = reverseList(head-\u0026gt;next); head-\u0026gt;next-\u0026gt;next = head; head-\u0026gt;next = NULL; return prev; } 1.2 获取单链表长度 1 2 3 4 5 6 7 8 9 10 11 12 13 14 int GetListNum(struct ListNode* head) { if (head == NULL) { return 0; } int cnt = 0; struct ListNode* tmp = head; while (tmp) { ++cnt; tmp = tmp-\u0026gt;next; } return cnt; } 1.3 获取单链表中间结点 功能说明：\n该函数返回链表中心点的前一个结点，即轴对称的尾结点。 例如，若链表有3个结点，则返回的是第1个结点的地址。若链表有4个结点，则返回的是第二个结点的地址。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 struct ListNode* GetMidNode(struct ListNode* head) { int cnt = GetListNum(head); int i = 0; tmp = head; struct ListNode* cur = NULL; while (i \u0026lt; cnt/2 \u0026amp;\u0026amp; tmp) { cur = tmp; tmp = tmp-\u0026gt;next; ++i; } return cur; } 1.4 判断单链表是否存在环 方法说明：\n方法1：使用hashtable。 方法2：使用快慢指针。具体方法是慢指针每次前进一步，快指针每次前进两步。若链表存在环，则经过若干步后，快指针肯定会追上慢指针，即两个指针指向同一个结点。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 bool hasCycle(struct ListNode *head) { if (head == NULL || head-\u0026gt;next == NULL) { return false; } struct ListNode* slow = head; struct ListNode* fast = head-\u0026gt;next; while (slow != fast) { if (fast == NULL || fast-\u0026gt;next == NULL) { return false; } slow = slow-\u0026gt;next; fast = fast-\u0026gt;next-\u0026gt;next; } return true; } 1.4.1 进阶：获取单链表环的入口结点 方法1：使用hashtable。 方法2：使用快慢指针。 2 链表高级特性 3 C++中的链表","date":"2024-11-16T21:29:14+08:00","permalink":"http://localhost:1313/post/data_structure/linklist/link_list_function/","tags":["链表"],"title":"单链表常见功能函数"},{"categories":[],"contents":"","date":"2024-11-16T15:35:21+08:00","permalink":"http://localhost:1313/search/","tags":[],"title":"站内搜索结果"},{"categories":["Linux"],"contents":"这篇文章介绍C语言结构体字节对齐的问题。\n1 结构体字节对齐的规则 结构体变量的首地址能够被其最宽基本类型成员的大小所整除；???\n数据类型自身的对齐：例如，在x86_64系统，char型数据自身对齐值为1字节，short型数据为2字节，int/float型为4字节，long/double/void*型为8字节。\n结构体或者类的自身的对齐：其成员中自身对齐值中的最大值。\n指定对齐值的情况下的对齐规则：#pragma pack (value)时的指定对齐值value。指定规则后以指定规则进行对齐。\n使用伪指令#pragma pack(n)：C编译器将按照n个字节对齐； 使用伪指令#pragma pack()： 取消自定义字节对齐方式。 数据成员、结构体和类的有效对齐值：若存在指定对齐值，需要自身对齐值和指定对齐值中较小者，即有效对齐值=min{自身对齐值，当前指定的pack值}。\n2 x86环境各种基本数据类型的字节数 数据类型 x86 x86_64 char 1 1 short 2 2 int 4 4 long 4 8 float 4 4 double 8 8 void* 4 8 3 示例程序 当前的实例程序假定结构体首地址为0。环境关键信息如下：\nArchithecture: x86_64\nGCC version: 4.4.7\n3.1 指定1字节对齐的示例分析 1 2 3 4 5 6 7 8 #pragma pack(1) struct test { char a; // not padding int b; // not pading short c; }; #pragma pack() sizeof(struct test); // 7 字节 说明：\n变量a，char自身对齐值为1, 指定值为1; 两者取小的值为1。首地址为0，变量a是对齐的，因此变量a占用1个字节。此时偏移1字节。\n变量b, int类型自身对齐值为4, 指定值为1，两者取小的偏移值为1。当前偏移1字节，因此变量b前不需要填充，b占用4字节。此时偏移5字节。\n变量c, short类型自身对齐值为2，指定值为1，两者取小的偏移单位为1。当前偏移5字节，因此变量c前也不需要填充，c占用2字节。此时偏移7字节。\n结构体自身的对齐值取最大变量的长度(int)，即4字节。但是指定的长度为1字节，两者取小即可得到整个结构体的对齐单位为1字节。因此，整个结构体占用7字节。\n3.2 指定2字节对齐的示例分析 1 2 3 4 5 6 7 8 #pragma pack(2) struct test { char a; // pading 1Byte int b; // not padding short c; }; #pragma pack() sizeof(struct test); // 8 字节 说明：\n变量a，char自身对齐值为1, 指定值为2; 两者取小的值为1。首地址为0，变量a是对齐的，因此变量a占用1个字节。此时偏移1字节。\n变量b, int类型自身对齐值为4, 指定值为2，两者取小的偏移值为2。当前偏移1字节，因此变量b前需要填充1字节，b占用4字节。此时偏移6字节。\n变量c, short类型自身对齐值为2，指定值为2，两者取小的偏移单位为2。当前偏移6字节，因此变量c前不需要填充，c占用2字节。此时偏移8字节。\n结构体自身的对齐值取最大变量的长度(int)，即4字节。但是指定的长度为2字节，两者取小即可得到整个结构体的对齐单位为2字节。当前偏移长度为8字节，已经是对齐单位整数倍，所以无需填充。因此，整个结构体占用8字节。\n3.3 指定4字节对齐的示例分析 1 2 3 4 5 6 7 8 #pragma pack(4) struct test { char a; int b; short c; }; #pragma pack() sizeof(struct test); // 12字节 说明： 变量a，char自身对齐值为1, 指定值为4; 两者取小的值为1。首地址为0，变量a默认是对齐的，因此变量a占用1个字节，无需填充。当前偏移1字节。\n变量b, int类型自身对齐值为4, 指定值为4，两者取小的偏移值为4。当前偏移1字节，因此变量b前需要填充3字节，b占用4字节。当前偏移8字节。\n变量c, short类型自身对齐值为2，指定值为4，两者取小的偏移单位为2。当前偏移8字节，因此变量c前不需要填充，c占用2字节。当前偏移10字节。\n结构体自身的对齐值取最大变量的长度(int)，即4字节。指定的长度为4字节，两者取小即可得到整个结构体的对齐单位为4字节。当前偏移长度为10字节，不是对齐单位整数倍，所以需要填充2字节。因此，整个结构体占用12字节。\n3.3 指定8字节对齐的示例分析 1 2 3 4 5 6 7 8 #pragma pack(8) struct test { char a; int b; short c; }; #pragma pack() sizeof(struct test); // 12字节 说明： 变量a，char自身对齐值为1, 指定值为8; 两者取小的值为1。首地址为0，变量a默认是对齐的，因此变量a占用1个字节，无需填充。当前偏移1字节。\n变量b, int类型自身对齐值为4, 指定值为8，两者取小的偏移值为4。当前偏移1字节，因此变量b前需要填充3字节，b占用4字节。当前偏移8字节。\n变量c, short类型自身对齐值为2，指定值为8，两者取小的偏移单位为2。当前偏移8字节，因此变量c前不需要填充，c占用2字节。当前偏移10字节。\n结构体自身的对齐值取最大变量的长度(int)，即4字节。指定的长度为8字节，两者取小即可得到整个结构体的对齐单位为4字节。当前偏移长度为10字节，不是对齐单位整数倍，所以需要填充2字节。因此，整个结构体占用12字节。\n3.4 不指定字节，按照默认对齐的示例分析 1 2 3 4 5 6 7 struct test { char a; int b; short c; long d; }; sizeof(struct test); // 24字节 说明： 变量a，char自身对齐值为1; 首地址为0，变量a默认是对齐的，因此变量a占用1个字节，无需填充。当前偏移1字节。\n变量b, int类型自身对齐值为4。当前偏移1字节，因此变量b前需要填充3字节，b占用4字节。当前偏移8字节。\n变量c, short类型自身对齐值为2。当前偏移8字节，因此变量c前不需要填充，c占用2字节。当前偏移10字节。\n变量d, long类型自身对齐值为8。当前偏移10字节，因此变量d前需要填充6个字节，c占用8字节。当前偏移24字节。\n结构体自身的对齐值取最大变量的长度(long)，即8字节。无指定的对齐长度，因此整个结构体的对齐单位为8字节。当前偏移长度为24字节，是对齐单位整数倍，所以不需要填充。因此，整个结构体占用24字节。\n","date":"2024-11-15T22:52:34+08:00","permalink":"http://localhost:1313/post/linux/struct_alignment/","tags":["结构体字节对齐"],"title":"C语言结构体字节对齐问题"},{"categories":["数据结构"],"contents":"本文介绍链表的基本特性以及链表常用的操作。\n1 链表的特性 链表是一种链式存储数据的结构。相邻的两个结点之间在物理地址上并不是连续存放的。因此就决定了链表无法进行随机访问，只能按照链接关系进行顺序访问。 只能单向变量的链表称为单链表，可以双向访问的链表称为双向链表。\n2 链表的基本操作 链表的常用操作有：创建链表，链表结点的插入、删除，销毁链表等。\n2.1 链表结点的定义 链表结点的定义是一种递归形式的定义，链表中的指针是链表结点类型的指针。\n1 2 3 4 struct ListNode { int val; struct ListNode *next; }; 2.1 链表的创建 2.2 链表的销毁","date":"2024-11-15T17:52:42+08:00","permalink":"http://localhost:1313/post/data_structure/linklist/link_list_introduction/","tags":["链表"],"title":"链表基本特性及其相关操作"},{"categories":["Linux"],"contents":"本文记录Linux常用命令的用法。\n1 linux命令的综合使用 1 2 # 删除出指定文件之外的文件 ls | grep -xvF file.txt | xargs rm -rf -- 2 linux常用命令的使用方法 2.1 tar 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # tar常用的命令参数 # -j 使用bzip处理文件 # -J 使用xz处理文件 # -z 使用gzip处理文件 # -c 压缩文件 # -x 解压文件 # -C 指定操作目录 # -v 显示正在处理的文件 # 示例1. 打包为bz文件 tar -jcvf test.tar.bz ./test/ # 示例2. 解压gz文件 tar -zxvf test.gz 2.2 zip/unzip 1 2 3 4 5 # zip 示例：zip options archive inpath zip -r foo.zip foo # unzip示例： unzip -d dir xxx.zip mkdir output \u0026amp;\u0026amp; unzip -d ./output file.zip ","date":"2024-11-15T17:13:30+08:00","permalink":"http://localhost:1313/post/linux/linux_common_tools/","tags":["Linux常用命令"],"title":"Linux常用命令的用法"},{"categories":["算法"],"contents":"本文记录字符串匹配算法的演进已经具体实现。\n字符串匹配算法(String Search Algorigthm) 一点说明：\n原串：即子串匹配过程中， 待查找的字符串；\n搜索串：即用来匹配的特定的一个子串。\n1 KMP算法 (The Knuth-Morris-Pratt Algorithm) 优点：在暴力解法的基础上，减少匹配过程中查找字符串比较次数。\n缺点：当待查找的字符串没有重复搜索串时，算法退化为暴力解法。\n算法中的概念：\n局部匹配表(partial match table):查找过程中的子串中真前缀和真后缀的最大公共长度。\n字符串的真前缀(proper prefix)：例如 “S”, “Sn”, “Sna”, 和 “Snap” 都是 “Snape”的proper prefix。\n字符串的真后缀(proper suffix)：例如“d”,“agrid”, “grid”, “rid”, “id”和 都是“Hagrid”的proper suffix。\n计算局部匹配表(partial math table) 局部匹配表有时也称为next数组。该表是由子串的内容决定的。计算过程如下(以下过程以字符串\u0026quot;abababca\u0026quot;为例)：\n字符串长度为1时，字符串为\u0026quot;a\u0026quot;。因此对应表项为0。\n字符串长度为2时，字符串为“ab”，proper prefix包含“a”；proper suffix包含“b”，因此对应表项为0。\n字符串长度为3时，字符串为“aba”，proper prefix包含“a”, “ab”； proper suffix包含“a”,“ba”，因此对应表项为1。\n字符串长度为4时，字符串为“abab”，proper prefix包含“a”, “ab”,“aba”；proper suffix包含“b”，“ab”，“bab”，因此对应表项为2。\n字符串长度为5时，字符串为“ababa”，proper prefix包含“a”, “ab”,“aba”,“abab”；proper suffix包含“a”，“ba”，“aba”，“baba”，因此对应表项为3。\n字符串长度为6时，字符串为“ababab”，proper prefix包含“a”, “ab”,“aba”,“abab”,“ababa”；proper suffix包含“b”，“ab”，“bab”，“abab”,，因此对应表项为3。\n使用局部匹配表进行字符串匹配 设局部匹配表为table。如果存在部分匹配值partial_match_length，而且table[partial_match_length] \u0026gt; 1，则子串可以跳过的长度为：partial_match_length - table[partial_match_length - 1] 。例如：\n第一次匹配情况，如下图所示：\n该匹配中部分匹配长度(partial_match_length)为1。而对应的值table[partial_match_length - 1]即table[0]等于0。因此我们不需要跳过任何字母。 接下来的匹配情况如下图所示：\n该匹配中部分匹配长度为(partial_match_length)为5。这个值对应的table[partial_match_length - 1](即table[4])值为3。这意味着partial_match_length - table[partial_match_length - 1](即5 - talbe[4]，即5-3，即2)。即子串向右移动2个字符。如图所示：\n移动后的匹配情况如上图所示，匹配成功长度(partial_match_length)为3。对应的table[partial_match_length - 1](即table[2])值为1。意味着我们向后移动长度为：partial_match_length - table[partial_match_length - 1](即3 - table[2] = 3 - 1 = 2)。移动后的结果如图所示：\n因子串尾部以超过原串长度，因此结束匹配。\n2 BM算法 (Boyer-Moore Algorithm) 1977年，德克萨斯大学的Robert S. Boyer教授和J Strother Moore教授发明了这种算法。因此取这两个人的名字而得。word中的查找功能就是使用该算法。\n算法中的概念：\n坏字符(bad character)：字符串匹配过程中，与搜索串不匹配的字符。 好后缀(good suffix): 即搜索串与原串尾部能够匹配的字符串。 坏字符实例，如下图: 好后缀实例，如下图：\n比较规则：首先，将搜索串与原串对齐，从搜索串尾部从后往前比较。\n坏字符移动规则: 后移位数 = 坏字符的位置 - 搜索词中的上一次出现位置。说明，若搜索串中不包含坏字符，则搜索串上一次出现位置为-1。若包含该字符，则为离坏字符位置最近的那个位置。\n好后缀规则 :后移位数 = 好后缀的位置 - 搜索词中的上一次出现位置。好后缀位置以后缀最后一个位置为准。说明，若搜索串中不包含坏字符，则搜索串上一次出现位置为-1。例如：\n如果字符串\u0026quot;ABCDAB\u0026quot;的后一个\u0026quot;AB\u0026quot;是\u0026quot;好后缀\u0026quot;。那么它的位置是5（从0开始计算，取最后的\u0026quot;B\u0026quot;的值），在\u0026quot;搜索词中的上一次出现位置\u0026quot;是1（第一个\u0026quot;B\u0026quot;的位置），所以后移 5 - 1 = 4位，前一个\u0026quot;AB\u0026quot;移到后一个\u0026quot;AB\u0026quot;的位置。 如果字符串\u0026quot;ABCDEF\u0026quot;的\u0026quot;EF\u0026quot;是好后缀，则\u0026quot;EF\u0026quot;的位置是5 ，上一次出现的位置是 -1（即未出现），所以后移 5 - (-1) = 6位，即整个字符串移到\u0026quot;F\u0026quot;的后一位。 注意：\n以上两个规则的中的位置指的是搜索串中的位置。 当通过坏字符规则和好后缀移动规则得到的值不同时，取较大的值作为移动量。 下面以字符串为\u0026quot;HERE IS A SIMPLE EXAMPLE\u0026quot;，搜索词为\u0026quot;EXAMPLE\u0026quot;为例，进行说明：\nstep1：\n首先遇到坏字符，计算移动位置：6 - (-1) = 7. step2:\n遇到坏字符，计算移动位置：6 - 4 = 2.\nstep3:\n遇到好后缀，计算移动位置：6 - 0 = 6。\nstep4:\n坏字符和好后缀的选择问题：\n坏字符的结果：\n后后缀的结果：\nstep5:\n3 Sunday算法(Sunday Algorigthm) sunday算法是对BM算法的改进。改进之处：当匹配失败时，判断搜索串下次匹配位置的第一个字符是否与搜索串第一个字符是否相同。进而减少匹配次数。\n","date":"2024-11-15T16:01:16+08:00","permalink":"http://localhost:1313/post/algorithm/string_match_algorightm/","tags":["字符串匹配"],"title":"字符串匹配算法"},{"categories":["环境搭建"],"contents":"Hugo中一些实用的配置。\n1 设置网站的页面宽度 在文件themes\\even\\assets\\sass\\_variables.scss中找到配置项$global-body-width，默认值为800。\n调整这个值就可以改变网站中页面的宽度。\n2 Hugo中使用图片的方法 在根目录static目录下创建目录放置图片即可。在markdown文件中按照形如/image/logo.png的方式进行引用即可。\n3 修改Hugo even主题主页的字体 将文件themes\\even\\assets\\sass\\_partial\\_header\\_logo.scss 中.logo的font-family属性按照如下形式修改即可：\n1 2 3 4 .logo { font-size: $logo-font-size; font-family: $global-serif-font-family; } 4 修改网站的语言 修改方法：修改网站工程根目录的config.toml文件，将defaultContentLanguage属性改为zh-cn 即可。切换后会使用theme主题i18n目录下对应的yaml文件。\n5 添加站内搜索功能 我自己的修改：\n源码仓：git@github.com:alvincat/MyGithubWebsite.git/master: 5f7a66cfe4e0a6cb94f33518297828c894e431b4\n模板仓：git@github.com:alvincat/HugoThemeEven.git/master: 088afb3d0cc34329a64b4e596a54e3e2af0c634b\n主要参考文档：\n给Hugo中的Even主题添加搜索功能 - 飞狐的部落格\n其他参考文档：\n给hugo添加搜索功能 | 搜百谷\nSuper fast, keyboard-optimized, client side Hugo search\n6 将页面置顶 若需要在主页将某个页面置顶，只需要在页面对应的md文件的文件头中添加weight: 1即可。 weight:1表示将该页面放在第1的位置，若需要将某个页面放在第二个位置，在源文件的头部添加weight:2即可。\n7 使用自己的域名的方法 7.1 注册域名 可以在namesilo网站购买个人域名。在网站首页输入自己想要的域名，可以查看是否被占用以及购买的价格。\n参考文档：购买个人域名方法\n7.2 关联github webpage 关联github page的方法参考文档： How To Add a Custom Domain To a GitHub Pages Site 使用自定义域名来访问GitHub上部署的hugo博客(GitHub Pages)\n温馨提示：\n在namesilo的【DNS管理】中，若点击\u0026quot;CNAME\u0026quot;，提示\u0026quot;WWW\u0026quot;已被占用，可以将已经存在\u0026quot;www\u0026quot;的标签删除，新建即可。\n","date":"2024-11-14T23:34:32+08:00","permalink":"http://localhost:1313/post/hugo/hugo_some_usful_setting/","tags":["Hugo"],"title":"Hugo中一些实用的配置"},{"categories":["Tools"],"contents":"本文记录Git常用命令。\n1 Git常用命令 1.1 查询命令 1 2 3 4 5 git status # 查看当前git状态 git log # 查询修改记录 git tag -l # 查询tag # git log精简模式显示指定信息 git log --pretty=format:\u0026#34;%h,%an,%aI,%s\u0026#34; | head 1.2 代码下载上传 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # down load source code git clone -b main git@github.com:alvincat/MyGithubWebsite.git MyWebsite # recurse update submodule git submodule update --init --recursive git push # pull = fetch + merge # pull --rebase = fetch + rebase # so recommand use: git pull --rebase git pull --rebase git push --set-upstream origin gh_pages # upload new branch # or git push -u origin \u0026lt;your_branch_name\u0026gt; 1.3 分支相关操作 1 2 3 4 5 6 git branch # 查看本地所有分支 git branch | grep \u0026#34;*\u0026#34; #查看当前分支 git checkout branch_name # 切换分支 git checkout -b gh_pages # create branch git branch -D gh_pages # 删除本地分支 git push origin --delete main # 删除远端分支 1.4 修改相关操作 1 2 3 4 5 6 7 8 9 10 11 git commit -m \u0026#34;\u0026#34; # add commit git add file1 file2 # add to local cache git stash # 暂存当前修改 git stash pop # 恢复暂存内容 git reset --hard origin/master # 强制更新当前分支代码为master分支 git reset --mixed commit_id # 将制定commit_id以后的提交回退至未提交 git rebase -i head~2 git cherry-pick commit_id 1.5 远程仓库操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # 查询本地关联的代码仓 git remote -v # 修改代码仓地址 git remote add origin url xxx # 添加远程分支, 其中origin为远程代码仓在本地的name, 本地代码可以关联多个远程代码仓 git remote origin https://github.com/olOwOlo/hugo-theme-even git remote add myEvenBackup git@github.com:alvincat/HugoThemeEven.git # 提交代码时可以指定代码仓进行 # 提交代码至https://github.com/olOwOlo/hugo-theme-even的master分支 git push -u origin master # 提交代码至git@github.com:alvincat/HugoThemeEven.git的master分支 git push -u myEvenBackup master 2 Git相关配置 2.1 Git添加ssh公钥 设置用户名和邮箱\n1 2 # 设置用户名 git config --global user.name \u0026#34;username\u0026#34; 设置邮箱 git config \u0026ndash;global user.email your_email@example.com\n查看用户名和密码 git config user.name git config user.email\n查看其他配置信息(git设置列表) git config \u0026ndash;list\n1 2 3 4 5 2. 执行命令生成ssh公钥和私钥 + windows环境 ```shell # 使用Ed25519加密算法生成公钥和私钥 ssh-keygen -t ed25519 -C \u0026#34;your_email@example.com\u0026#34; Linux或者MacOS环境\n1 2 # 使用Ed25519加密算法生成公钥和私钥 ssh-keygen -t ed25519-sk -C \u0026#34;your_email@example.com\u0026#34; 将生成的公钥文件id_ed25519.pub中的内容添加至github即可使用ssh上传下载代码。 温馨提示：\n若添加公钥后，提交代码提示错误：push declined due to email privacy restrictions\n原因：将github关联的email设置为私密，对外不可见。\n解决方法：\n方法1：进入https://github.com/settings/emails页面，将【Block command line pushes that expose my email】勾选去掉。 方法2：使用github提供的转换邮件地址。(在标签【Keep my email addresses private】的内容中提供，形如：12345678+username@users.noreply.github.com)。使用这个邮件地址更新密钥即可。 2.2 gitignore的用法 git在提交代码时，存在部分本地生成的和代码无关的文件，不需要提交。这种文件或者目录就需要使用gitignore的机制进行过滤。使用方法如下：\n在代码根目录创建文件.gitignore 在文件中添加需要过滤的文件和目录，注意若要过滤整个目录，需要在目录后跟/ 常见情况解决方法：\n添加到.gitignore文件中的目录，再次提交后并未生效。解决方法，执行代码：git rm -r --cached \u0026lt;folder\u0026gt; ","date":"2024-11-14T17:13:30+08:00","permalink":"http://localhost:1313/post/tools/git_commond/","tags":["Git"],"title":"Git常用命令"},{"categories":["环境搭建"],"contents":"本文记录Hugo配置github静态页面的关键步骤。\n1 Hugo简介 Hugo是由Go语言实现的静态网站生成器。简单、易用、高效、易扩展、快速部署。\nHugo官网：Hugo官网\nHugo的官方文档：Hugo中文文档\n2 使用Hugo发布静态网站的准备工作 2.1 下载安装部署网站工具 2.1.1 下载安装git Git下载地址：Download Git\nWindows下安装方法：运行二进制程序，然后按照提示操作即可。\n2.1.2 下载安装go 官方下载地址：Download and install - The Go Programming Language\nGo语言中文网下载地址：Go语言中文网下载地址\n我下载的go版本是：go1.17.3\n安装配置完成后，使用命令go version 查看版本号。\n温馨提示：若下载的是免安装版本，需要手动配置环境变量，否则无法使用。\n2.1.3 下载安装hugo-extend Hugo v0.138.0下载地址： Hugo v0.138.0下载地址\n我下载的是：hugo_extended_withdeploy_0.138.0_windows-amd64.zip\n安装配置完成后，使用命令hugo version 查看版本号。\n温馨提示：若下载的是免安装版本，需要手动配置环境变量，否则无法使用。\n2.2 创建代码仓 在github创建私有库MyGithubWebsite: 用于存放网站工程源码 在github创建公共代码username.github.io: 用于保存网站内容。\ngithub规定必须将网站内容放在形如username.github.io的代码仓中，此处的username为你的github的用户名。 2.3 下载代码 1 git clone git@github.com:alvincat/MyGithubWebsite.git MyWebsite 2.4 初始化网站 1 2 # 在网站根目录的上层目录执行命令，MyWebsite为网站工程根目录名 hugo new site MyWebsite --force 2.5 Hugo使用even模板 2.5.1 下载even模板 1 2 # 进入根目录，执行命令下载网站模板 git clone https://github.com/olOwOlo/hugo-theme-even themes/even 2.5.2 even模板配置 在even主题的 exampleSite 目录下有一个 config.toml 文件，将这个 config.toml 文件复制到你的站点根目录下，根据自己的需求更改即可。\n为了定制 favicon，你需要在站点根目录的 static 文件夹下放置下述所有文件，这将覆盖 themes/even/static/ 文件夹下的那些文件。\nandroid-chrome-192x192.png android-chrome-512x512.png apple-touch-icon.png browserconfig.xml favicon.ico favicon-16x16.png favicon-32x32.png manifest.json mstile-150x150.png safari-pinned-tab.svg 2.5.3 even文章模板配置 你可以通过 front-matter 针对每一篇文章单独进行设置。themes/even/archetypes/default.md 文件陈列了所有可用的参数。\n将该文件复制到站点根目录的 archetypes 文件夹下将会有所帮助。\n3 使用Hugo撰写博客 3.1 使用hugo创建文件 1 hugo new post/hello.md 注意:\n对于even这个主题，你应该使用 post 而不是 posts，即 hugo new post/some-content.md 建议使用hugo new命令来新建文件，而不要直接在post目录下创建文件。 3.2 hugo本地调试博客文章 1 hugo server -D 登陆浏览器查看结果：localhost\n3.3 发布网站 在站点根目录执行 以下Hugo 命令生成最终页面：\n1 hugo -D --baseURL=\u0026#34;https://alvincat.github.io/\u0026#34; 执行这条命令，就会在public目录下生成最终网站内容。\n将public的内容推送到username.github.io仓库，就可以访问网站了\n3.4 创建.gitignore文件，忽略部分文件 3.5 本地调试完成后，提交代码至github 1 2 3 git add file git commit -m \u0026#34;add file\u0026#34; git push 温馨提示：\n在本地调试完成提交前，建议先将public目录下的内容清空，重新编译后再提交，以免public目录存在修改的残留文件。\n4 使用github actions功能自动发布网站的方法 4.1 创建personal access token 按照setting -\u0026gt; Developer Settings -\u0026gt; Personal access tokens的顺序打开创建token界面。如下图所示。 按照Tokens(classic) -\u0026gt; Generate new token -\u0026gt; Generate new token(classic)的顺序创建token。如下图所示： 在创建token的界面勾选【workflow]按钮。如下图所示： 点击创建后，就会生成一串token编码。此时需要复制这串编码，后面添加的时候需要使用。 4.2 添加secrets 进入网站工程的setting界面，如下图所示： 进入添加secret界面，填写secretname和步骤5.1生成的token。(注意： 此处的secret name后续在配置文件中会用到。）如下图所示： 添加完成后就会提示添加成功。如下图所示：\n4.3 添加active自动化配置文件 在网站工程根目录创建目录.github/workflows/，然后再该目录下创建一个yml文件，文件名自定。此处文件名为hugo.yml。文件内容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 name: GitHub Pages on: push: branches: - master # 博客工程根目录的默认分支，我的是master，请以实际为准 jobs: deploy: runs-on: ubuntu-latest concurrency: group: ${{ github.workflow }}-${{ github.ref }} steps: - uses: actions/checkout@v2 with: submodules: false fetch-depth: 0 - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#39;latest\u0026#39; extended: true # 如果你使用的不是extended版本的hugo，将true改为false - name: Build run: hugo --minify - name: Deploy uses: peaceiris/actions-gh-pages@v3 if: ${{ github.ref == \u0026#39;refs/heads/master\u0026#39; }} # 博客工程根目录的默认分支，我的是master，请以实际为准 with: personal_token: ${{ secrets.YOUR_SECRET}} # 如果secret取了其他名称，将YOUR_SECRET替换掉 external_repository: alvincat/alvincat.github.io # 填写远程仓库，名字 publish_dir: ./public #cname: www.example.com # 填写你的自定义域名。如果没有用自定义域名，注释掉这行 该配置文件的作用就是当私有库MyGithubWebsite的master分支代码提交后，将public目录的内容推送到username.github.io的gh-pages分支。可以通过查看MyGithubWebsite的action页面确认，该配置是否生效。 如下图所示： 其实该功能也可以手动完成，当本地调试完成后，将public的内容推送到username.github.io的gh-pages分支。\n1 2 3 4 5 6 cd public git init git remote add origin git@github.com:alvincat/alvincat.github.io.git git add . git commit -m \u0026#39;add blog\u0026#39; git push origin gh-pages 4.4 修改username.github.io代码仓的page页面关联分支 当步骤5.4更新成功后，就会将生成的网站内容推送到username.github.io代码仓的gh-pages分支。因此需要将username.github.io代码仓的page关联分支切换为gh-pages。\n修改方法如下：\n5 优化方案 步骤4中的方案有个问题是：需要在两个代码仓中均存放public目录中的文件（好处是可以自动更新网站内容）。\n只保存一份public文件的方法：\n忽略源代码仓的public文件夹：即提交源代码仓中的修改时不提交public目录下的文件。 将public文件夹和username.github.io代码仓关联。 需要更新网站时，只需要将public目录中的内容push到username.github.io远程代码仓即可。 1 2 3 4 5 6 git init # 初始化git目录 git remote add webPage git@github.com:alvincat/alvincat.github.io.git # 关联远端代码仓 git fetch webPage # 更新代码 git checkout -b master # 创建本地分支 git pull webPage master # pull远端代码 git push -u webPage master # 提交代码 6 参考文献 将Hugo静态网站部署到Github Pages\nHugo + even + GitHub Pages+ Utterances搭建个人博客\n利用GitHub Action实现Hugo博客在GitHub Pages自动部署\nHugo + GitHub Action，搭建你的博客自动发布系统\n","date":"2024-11-14T16:51:30+08:00","permalink":"http://localhost:1313/post/hugo/hugo_build_static_page/","tags":["Hugo"],"title":"Hugo配置github静态页面的方法"},{"categories":[],"contents":"关于我的详细信息。\n个人信息 Name : alvincat 个人爱好 联系我 \u0026#x1f4e7; : alvincat@126.com Github: https://github.com/alvincat 友情链接","date":"2024-11-14T11:16:25+08:00","permalink":"http://localhost:1313/about/","tags":[],"title":"关于我"},{"categories":[""],"contents":"该页面为C++的导航页。\nC C语言常用功能\nC++ C++易混淆知识点\nC++中部分关键字的用法\nC++面向对象基础知识\nC++常用功能汇总\nC++常用库函数的用法\nC++ sring的用法\nC++ STL的用法\nC++ vector的内部实现和用法\nC++新特性\nC++ 算法库 Sort操作函数的使用方法\n","date":"2024-11-13T18:26:40+08:00","permalink":"http://localhost:1313/index/content_cpp/","tags":[""],"title":"C++导航页"},{"categories":[""],"contents":"该页面为工具使用的导航页。\n工具 编译调试工具 GCC常用编译命令和库函数\nGDB常用命令 GDB打印STL中各种容器的内容的方法\nQT入门文档\nGTest配置方法\n工程工具 Vim常用设置以及常用命令\nMarkdown使用技巧\nGit常用命令\ndocker安装和使用方法 网络工具使用方法\n其他 程序员入门必读\n","date":"2024-11-13T18:25:40+08:00","permalink":"http://localhost:1313/index/content_tools/","tags":[""],"title":"工具使用导航页"},{"categories":[""],"contents":"该页面为杂项的导航页。\n杂项 音乐\n","date":"2024-11-13T18:25:40+08:00","permalink":"http://localhost:1313/index/content_others/","tags":[""],"title":"杂项导航页"},{"categories":[""],"contents":"该页为的操作系统导航页。\n操作系统 环境配置 Ubuntu环境配置\n树莓派系统的初始化\n内核相关 Kernel_boot_process xv6-riscv_config_evn\n","date":"2024-11-13T17:57:26+08:00","permalink":"http://localhost:1313/index/content_os/","tags":[""],"title":"操作系统导航页"},{"categories":[""],"contents":"该页为的环境搭建导航页。\n环境搭建 Hugo配置github静态页面的方法\nHugo中一些实用的配置\n","date":"2024-11-13T16:58:15+08:00","permalink":"http://localhost:1313/index/content_environment_deploy/","tags":[""],"title":"环境搭建导航页"},{"categories":[""],"contents":"该页为的Linux相关内容的导航页。\nLinux C语言结构体字节对齐问题\nc语言编码注意事项\nLinux常用命令的用法\nLinux系统常用的系统配置\n并发编程中常见的问题\nLinux系统中进程打印堆栈的原理\nLinux系统中钩子的使用方法\nCSAPP 信息的处理与表示\nAPUE UNIX标准\n进程环境\n信号\n线程\n线程同步的方法\n进程同步的方法\n内存映射\n进程间通信的方法\nNginx Nginx源码结构简介\n","date":"2024-11-13T16:57:51+08:00","permalink":"http://localhost:1313/index/content_linux/","tags":[""],"title":"Linux相关内容的导航页"},{"categories":[""],"contents":"该页为数据结构的导航页。\n1 数据结构 1.1 线性结构 1.1.1 数组 1.1.1.1 数组 1.1.1.2 字符串 1.1.1.4 矩阵 1.1.2 链表 1.1.2.1 单向链表 单链表常见功能函数\n链表基本特性及其相关操作\n1.1.2.2 双向链表 1.1.3 栈 1.1.3.1 栈的原理和实现 1.1.3.1.1 栈的原理 1.1.3.1.2 栈的具体实现 C语言实现栈的方法\n1.1.3.2 单调栈 1.1.4 队列 1.1.4.1 队列的原理和实现 1.1.4.1.1 队列的原理 1.1.4.1.2 队列的实现 C语言实现一个队列的方法\n1.1.4.3 单调队列 1.1.4.3 优先级队列(堆) 1.2 哈希表 1.2.1 哈希表 哈希表的原理和实现\n1.2.2 LRU LRU的原理和实现\n1.2.3 LFU 1.3 树 1.3.1 树 1.3.2 二叉树 创建二叉树的方法\n二叉树的遍历方法\n1.3.3 二叉搜索树 1.3.3.1 BST 1.3.3.2 红黑树 1.3.4 字典树 1.3.5 线段树 1.3.6 树状数组 TrieTree\n1.4 图 1.4.01 图论基础 1.4.02 最短路径 1.4.03 并查集 1.4.04 拓扑排序 拓扑排序的原理和代码实现\n1.4.05 最小生成树 1.4.06 强连通分量 1.4.07 双连通分量 1.4.08 欧拉回路 1.5 有序集合","date":"2024-11-13T16:56:59+08:00","permalink":"http://localhost:1313/index/content_data_structure/","tags":[""],"title":"数据结构导航页"},{"categories":[""],"contents":"该页为算法的导航页。\n1 排序 1.1 交换类排序 1.1.1 冒泡排序 1.1.2 快速排序 1.2 选择类排序 1.2.1 选择排序 1.2.2 堆排序 堆排序的原理和实现\n1.3 插入类排序 1.3.1 插入排序 1.3.2 希尔排序 1.4 归并排序 1.5 计数排序 1.6 基数排序 1.7 桶排序 1.8 排序总结 排序总结\n2 查找 2.1 二分查找 3 回溯 回溯算法总结\n4 递归 5 分治 6 贪心 贪心算法\n7 动态规划 动态规划的原理和引用\n7.1 最长公共子序列(LCS) 8 搜索 8.1 深度优先搜索(DFS) 遍历-DFS\n8.2 广度优先搜索(BFS) 遍历-BFS\n9 记忆化搜索 10 字符串匹配 字符串匹配算法\n11 模拟 12 枚举","date":"2024-11-13T16:56:45+08:00","permalink":"http://localhost:1313/index/content_algorithm/","tags":[""],"title":"算法导航页"}]